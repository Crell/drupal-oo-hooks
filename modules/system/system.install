<?php
// $Id$

/**
 * Test and report Drupal installation requirements.
 */
function system_requirements($phase) {
  $requirements = array();
  // Ensure translations don't break at install time
  $t = get_t();

  // Report Drupal version
  if ($phase == 'runtime') {
    $requirements['drupal'] = array(
      'title' => $t('Drupal'),
      'value' => VERSION,
      'severity' => REQUIREMENT_INFO,
      'weight' => -10,
    );
  }

  // Test web server
  $software = $_SERVER['SERVER_SOFTWARE'];
  $requirements['webserver'] = array(
    'title' => $t('Web server'),
    'value' => $software,
  );
  // Use server info string, if present.
  if ($software && preg_match('![0-9]!', $software)) {
    list($server, $version) = split('[ /]', $software);
    switch ($server) {
      case 'Apache':
        if (version_compare($version, DRUPAL_MINIMUM_APACHE) < 0) {
          $requirements['webserver']['description'] = $t('Your Apache server is too old. Drupal requires at least Apache %version.', array('%version' => DRUPAL_MINIMUM_APACHE));
          $requirements['webserver']['severity'] = REQUIREMENT_ERROR;
        }
        break;

      default:
        $requirements['webserver']['description'] = $t('The web server you\'re using has not been tested with Drupal and might not work properly.');
        $requirements['webserver']['severity'] = REQUIREMENT_WARNING;
        break;
    }
  }
  else {
    $requirements['webserver']['value'] = $software ? $software : $t('Unknown');
    $requirements['webserver']['description'] = $t('Unable to determine your web server type and version. Drupal might not work properly.');
    $requirements['webserver']['severity'] = REQUIREMENT_WARNING;
  }

  // Test PHP version
  $requirements['php'] = array(
    'title' => $t('PHP'),
    'value' => ($phase == 'runtime') ? l(phpversion(), 'admin/logs/status/php') : phpversion(),
  );
  if (version_compare(phpversion(), DRUPAL_MINIMUM_PHP) < 0) {
    $requirements['php']['description'] = $t('Your PHP installation is too old. Drupal requires at least PHP %version.', array('%version' => DRUPAL_MINIMUM_PHP));
    $requirements['php']['severity'] = REQUIREMENT_ERROR;
  }

  // Test DB version
  global $db_type;
  if (function_exists('db_status_report')) {
    $requirements += db_status_report($phase);
  }

  // Test settings.php file writability
  if ($phase == 'runtime') {
    $conf_dir = drupal_verify_install_file(conf_path(), FILE_NOT_WRITABLE, 'dir');
    $conf_file = drupal_verify_install_file(conf_path() .'/settings.php', FILE_EXIST|FILE_READABLE|FILE_NOT_WRITABLE);
    if (!$conf_dir || !$conf_file) {
      $requirements['settings.php'] = array(
        'value' => $t('Not protected'),
        'severity' => REQUIREMENT_ERROR,
        'description' => '',
      );
      if (!$conf_dir) {
        $requirements['settings.php']['description'] .= $t('The directory %file is not protected from modifications and poses a security risk. You must change the directory\'s permissions to be non-writable. ', array('%file' => conf_path()));
      }
      if (!$conf_file) {
        $requirements['settings.php']['description'] .= $t('The file %file is not protected from modifications and poses a security risk. You must change the file\'s permissions to be non-writable.', array('%file' => conf_path() .'/settings.php'));
      }
    }
    else {
      $requirements['settings.php'] = array(
        'value' => $t('Protected'),
      );
    }
    $requirements['settings.php']['title'] = $t('Configuration file');
  }

  // Report cron status
  if ($phase == 'runtime') {
    $cron_last = variable_get('cron_last', NULL);

    if (is_numeric($cron_last)) {
      $requirements['cron']['value'] = $t('Last run !time ago', array('!time' => format_interval(time() - $cron_last)));
    }
    else {
      $requirements['cron'] = array(
        'description' => $t('Cron has not run. It appears cron jobs have not been setup on your system. Please check the help pages for <a href="@url">configuring cron jobs</a>.', array('@url' => 'http://drupal.org/cron')),
        'severity' => REQUIREMENT_ERROR,
        'value' => $t('Never run'),
      );
    }
    $requirements['cron'] += array('description' => '');

    $requirements['cron']['description'] .= ' '. $t('You can <a href="@cron">run cron manually</a>.', array('@cron' => url('admin/logs/status/run-cron')));

    $requirements['cron']['title'] = $t('Cron maintenance tasks');
  }

  // Test files directory
  if ($phase == 'runtime') {
    $directory = file_directory_path();
    $is_writable = is_writable($directory);
    $is_directory = is_dir($directory);
    if (!$is_writable || !$is_directory) {
      if (!$is_directory) {
        $error = $t('The directory %directory does not exist.', array('%directory' => $directory));
      }
      else {
        $error = $t('The directory %directory is not writable.', array('%directory' => $directory));
      }
      $requirements['file system'] = array(
        'value' => $t('Not writable'),
        'severity' => REQUIREMENT_ERROR,
        'description' => $error .' '. $t('You may need to set the correct directory at the <a href="@admin-file-system">file system settings page</a> or change the current directory\'s permissions so that it is writable.', array('@admin-file-system' => url('admin/settings/file-system'))),
      );
    }
    else {
      if (variable_get('file_downloads', FILE_DOWNLOADS_PUBLIC) == FILE_DOWNLOADS_PUBLIC) {
        $requirements['file system'] = array(
          'value' => $t('Writable (<em>public</em> download method)'),
        );
      }
      else {
        $requirements['file system'] = array(
          'value' => $t('Writable (<em>private</em> download method)'),
        );
      }
    }
    $requirements['file system']['title'] = $t('File system');
  }

  // See if updates are available in update.php.
  if ($phase == 'runtime') {
    $requirements['update'] = array(
      'title' => $t('Database updates'),
      'severity' => REQUIREMENT_OK,
      'value' => $t('Up to date'),
    );

    // Check installed modules.
    foreach (module_list() as $module) {
      $updates = drupal_get_schema_versions($module);
      if ($updates !== FALSE) {
        $default = drupal_get_installed_schema_version($module);
        if (max($updates) > $default) {
          $requirements['update']['severity'] = REQUIREMENT_ERROR;
          $requirements['update']['value'] = $t('Out of date');
          $requirements['update']['description'] = $t('Some modules have database schema updates to install. You should run the <a href="@update">database update script</a> immediately.', array('@update' => base_path() .'update.php'));
          break;
        }
      }
    }
  }

  // Verify the update.php access setting
  if ($phase == 'runtime') {
    if (!empty($GLOBALS['update_free_access'])) {
      $requirements['update access'] = array(
        'value' => $t('Not protected'),
        'severity' => REQUIREMENT_ERROR,
        'description' => $t('The update.php script is accessible to everyone without authentication check, which is a security risk. You must change the $update_free_access value in your settings.php back to FALSE.'),
      );
    }
    else {
      $requirements['update access'] = array(
        'value' => $t('Protected'),
      );
    }
    $requirements['update access']['title'] = $t('Access to update.php');
  }

  // Test Unicode library
  include_once './includes/unicode.inc';
  $requirements = array_merge($requirements, unicode_requirements());

  return $requirements;
}


/**
 * Implementation of hook_install().
 */
function system_install() {
  if ($GLOBALS['db_type'] == 'pgsql') {
    /* create unsigned types */
    db_query("CREATE DOMAIN int_unsigned integer CHECK (VALUE >= 0)");
    db_query("CREATE DOMAIN smallint_unsigned smallint CHECK (VALUE >= 0)");
    db_query("CREATE DOMAIN bigint_unsigned bigint CHECK (VALUE >= 0)");

    /* create functions */
    db_query('CREATE OR REPLACE FUNCTION "greatest"(numeric, numeric) RETURNS numeric AS
      \'SELECT CASE WHEN (($1 > $2) OR ($2 IS NULL)) THEN $1 ELSE $2 END;\'
      LANGUAGE \'sql\''
    );
    db_query('CREATE OR REPLACE FUNCTION "greatest"(numeric, numeric, numeric) RETURNS numeric AS
      \'SELECT greatest($1, greatest($2, $3));\'
      LANGUAGE \'sql\''
    );
    if (!db_result(db_query("SELECT COUNT(*) FROM pg_proc WHERE proname = 'rand'"))) {
      db_query('CREATE OR REPLACE FUNCTION "rand"() RETURNS float AS
        \'SELECT random();\'
        LANGUAGE \'sql\''
      );
    }

    if (!db_result(db_query("SELECT COUNT(*) FROM pg_proc WHERE proname = 'concat'"))) {
      db_query('CREATE OR REPLACE FUNCTION "concat"(text, text) RETURNS text AS
        \'SELECT $1 || $2;\'
        LANGUAGE \'sql\''
      );
    }
    db_query('CREATE OR REPLACE FUNCTION "if"(boolean, text, text) RETURNS text AS
      \'SELECT CASE WHEN $1 THEN $2 ELSE $3 END;\'
      LANGUAGE \'sql\''
    );
    db_query('CREATE OR REPLACE FUNCTION "if"(boolean, integer, integer) RETURNS integer AS
      \'SELECT CASE WHEN $1 THEN $2 ELSE $3 END;\'
      LANGUAGE \'sql\''
    );
  }

  // Create tables.
  $modules = array('system', 'filter', 'block', 'user', 'node', 'comment', 'taxonomy');
  foreach ($modules as $module) {
    drupal_install_schema($module);
  }

  // Load system theme data appropriately.
  system_theme_data();

  // Inserting uid 0 here confuses MySQL -- the next user might be created as
  // uid 2 which is not what we want. So we insert the first user here, the
  // anonymous user. uid is 1 here for now, but very soon it will be changed
  // to 0.
  db_query("INSERT INTO {users} (name, mail) VALUES('%s', '%s')", '', '');
  // We need some placeholders here as name and mail are uniques and data is
  // presumed to be a serialized array. Install will change uid 1 immediately
  // anyways. So we insert the superuser here, the uid is 2 here for now, but
  // very soon it will be changed to 1.
  db_query("INSERT INTO {users} (name, mail, created, data) VALUES('%s', '%s', %d, '%s')", 'placeholder-for-uid-1', 'placeholder-for-uid-1', time(), serialize(array()));
  // This sets the above two users to 1 -1 = 0 (anonymous) and
  // 2- 1 = 1 (superuser). We skip uid 2 but that's not a big problem.
  db_query('UPDATE {users} SET uid = uid - 1');

  db_query("INSERT INTO {role} (name) VALUES ('%s')", 'anonymous user');
  db_query("INSERT INTO {role} (name) VALUES ('%s')", 'authenticated user');

  db_query("INSERT INTO {permission} (rid, perm, tid) VALUES (%d, '%s', %d)", 1, 'access content', 0);
  db_query("INSERT INTO {permission} (rid, perm, tid) VALUES (%d, '%s', %d)", 2, 'access comments, access content, post comments, post comments without approval', 0);

  db_query("INSERT INTO {variable} (name, value) VALUES ('%s', '%s')", 'theme_default', 's:7:"garland";');
  db_query("UPDATE {system} SET status = %d WHERE type = '%s' AND name = '%s'", 1, 'theme', 'garland');
  db_query("INSERT INTO {blocks} (module, delta, theme, status, pages) VALUES ('%s', '%s', '%s', %d, '%s')", 'user', '0', 'garland', 1, '');
  db_query("INSERT INTO {blocks} (module, delta, theme, status, pages) VALUES ('%s', '%s', '%s', %d, '%s')", 'user', '1', 'garland', 1, '');

  db_query("INSERT INTO {node_access} (nid, gid, realm, grant_view, grant_update, grant_delete) VALUES (%d, %d, '%s', %d, %d, %d)", 0, 0, 'all', 1, 0, 0);

  // Add input formats.
  db_query("INSERT INTO {filter_formats} (name, roles, cache) VALUES ('%s', '%s', %d)", 'Filtered HTML', ',1,2,', 1);
  db_query("INSERT INTO {filter_formats} (name, roles, cache) VALUES ('%s', '%s', %d)", 'Full HTML', '', 1);

  // Enable filters for each input format.

  // Filtered HTML:
  // URL filter.
  db_query("INSERT INTO {filters} (format, module, delta, weight) VALUES (%d, '%s', %d, %d)", 1, 'filter', 2, 0);
  // HTML filter.
  db_query("INSERT INTO {filters} (format, module, delta, weight) VALUES (%d, '%s', %d, %d)", 1, 'filter', 0, 1);
  // Line break filter.
  db_query("INSERT INTO {filters} (format, module, delta, weight) VALUES (%d, '%s', %d, %d)", 1, 'filter', 1, 2);
  // HTML corrector filter.
  db_query("INSERT INTO {filters} (format, module, delta, weight) VALUES (%d, '%s', %d, %d)", 1, 'filter', 3, 10);

  // Full HTML:
  // URL filter.
  db_query("INSERT INTO {filters} (format, module, delta, weight) VALUES (%d, '%s', %d, %d)", 2, 'filter', 2, 0);
  // Line break filter.
  db_query("INSERT INTO {filters} (format, module, delta, weight) VALUES (%d, '%s', %d, %d)", 2, 'filter', 1, 1);
  // HTML corrector filter.
  db_query("INSERT INTO {filters} (format, module, delta, weight) VALUES (%d, '%s', %d, %d)", 1, 'filter', 3, 10);

  db_query("INSERT INTO {variable} (name, value) VALUES ('%s','%s')", 'filter_html_1', 'i:1;');

  db_query("INSERT INTO {variable} (name, value) VALUES ('%s', '%s')", 'node_options_forum', 'a:1:{i:0;s:6:"status";}');
}

/**
 * Implementation of hook_schema().
 */
function system_schema() {
  // NOTE: {variable} needs to be created before all other tables, as
  // some database drivers, e.g. Oracle and DB2, will require variable_get()
  // and variable_set() for overcoming some database specific limitations.
  $schema['variable'] = array(
    'description' => t('Named variable/value pairs created by Drupal core or any other module or theme.  All variables are cached in memory at the start of every Drupal request so developers should not be careless about what is stored here.'),
    'fields' => array(
      'name' => array(
        'description' => t('The name of the variable.'),
        'type' => 'varchar',
        'length' => 128,
        'not null' => TRUE,
        'default' => ''),
      'value' => array(
        'description' => t('The value of the variable.'),
        'type' => 'text',
        'not null' => TRUE,
        'size' => 'big'),
      ),
    'primary key' => array('name'),
    );

  $schema['actions'] = array(
    'description' => t('Stores action information.'),
    'fields' => array(
      'aid' => array(
        'description' => t('Primary Key: Unique actions ID.'),
        'type' => 'varchar',
        'length' => 255,
        'not null' => TRUE,
        'default' => '0'),
      'type' => array(
        'description' => t('The object that that action acts on (node, user, comment, system or custom types.)'),
        'type' => 'varchar',
        'length' => 32,
        'not null' => TRUE,
        'default' => ''),
      'callback' => array(
        'description' => t('The callback function that executes when the action runs.'),
        'type' => 'varchar',
        'length' => 255,
        'not null' => TRUE,
        'default' => ''),
      'parameters' => array(
        'description' => t('Parameters to be passed to the callback function.'),
        'type' => 'text',
        'not null' => TRUE,
        'size' => 'big'),
      'description' => array(
        'description' => t('Description of the action.'),
        'type' => 'varchar',
        'length' => 255,
        'not null' => TRUE,
        'default' => '0'),
      ),
    'primary key' => array('aid'),
    );

  $schema['actions_aid'] = array(
    'description' => t('Stores action IDs for non-default actions.'),
    'fields' => array(
      'aid' => array(
        'description' => t('Primary Key: Unique actions ID.'),
        'type' => 'serial',
        'unsigned' => TRUE,
        'not null' => TRUE),
      ),
    'primary key' => array('aid'),
    );

  $schema['batch'] = array(
    'description' => t('Stores details about batches (processes that run in multiple HTTP requests).'),
    'fields' => array(
      'bid' => array(
        'description' => t('Primary Key: Unique batch ID.'),
        'type' => 'serial',
        'unsigned' => TRUE,
        'not null' => TRUE),
      'token' => array(
        'description' => t("A string token generated against the current user's session id and the batch id, used to ensure that only the user who submitted the batch can effectively access it."),
        'type' => 'varchar',
        'length' => 64,
        'not null' => TRUE),
      'timestamp' => array(
        'description' => t('A Unix timestamp indicating when this batch was submitted for processing. Stale batches are purged at cron time.'),
        'type' => 'int',
        'not null' => TRUE),
      'batch' => array(
        'description' => t('A serialized array containing the processing data for the batch.'),
        'type' => 'text',
        'not null' => FALSE,
        'size' => 'big')
      ),
    'primary key' => array('bid'),
    'indexes' => array('token' => array('token')),
    );

  $schema['cache'] = array(
    'description' => t('Generic cache table for caching things not separated out into their own tables. Contributed modules may also use this to store cached items.'),
    'fields' => array(
      'cid' => array(
        'description' => t('Primary Key: Unique cache ID.'),
        'type' => 'varchar',
        'length' => 255,
        'not null' => TRUE,
        'default' => ''),
      'data' => array(
        'description' => t('A collection of data to cache.'),
        'type' => 'blob',
        'not null' => FALSE,
        'size' => 'big'),
      'expire' => array(
        'description' => t('A Unix timestamp indicating when the cache entry should expire, or 0 for never.'),
        'type' => 'int',
        'not null' => TRUE,
        'default' => 0),
      'created' => array(
        'description' => t('A Unix timestamp indicating when the cache entry was created.'),
        'type' => 'int',
        'not null' => TRUE,
        'default' => 0),
      'headers' => array(
        'description' => t('Any custom HTTP headers to be added to cached data.'),
        'type' => 'text',
        'not null' => FALSE),
      'serialized' => array(
        'description' => t('A flag to indicate whether content is serialized (1) or not (0).'),
        'type' => 'int',
        'size' => 'small',
        'not null' => TRUE,
        'default' => 0)
      ),
    'indexes' => array('expire' => array('expire')),
    'primary key' => array('cid'),
    );

  $schema['cache_form'] = $schema['cache'];
  $schema['cache_form']['description'] = t('Cache table for the form system to store recently built forms and their storage data, to be used in subsequent page requests.');
  $schema['cache_page'] = $schema['cache'];
  $schema['cache_page']['description'] = t('Cache table used to store compressed pages for anonymous users, if page caching is enabled.');
  $schema['cache_menu'] = $schema['cache'];
  $schema['cache_menu']['description'] = t('Cache table for the menu system to store router information as well as generated link trees for various menu/page/user combinations.');

  $schema['files'] = array(
    'description' => t('Stores information for uploaded files.'),
    'fields' => array(
      'fid' => array(
        'description' => t('Primary Key: Unique files ID.'),
        'type' => 'serial',
        'unsigned' => TRUE,
        'not null' => TRUE),
      'uid' => array(
        'description' => t('The {users}.uid of the user who is associated with the file.'),
        'type' => 'int',
        'unsigned' => TRUE,
        'not null' => TRUE,
        'default' => 0),
      'filename' => array(
        'description' => t('Name of the file.'),
        'type' => 'varchar',
        'length' => 255,
        'not null' => TRUE,
        'default' => ''),
      'filepath' => array(
        'description' => t('Path of the file relative to Drupal root.'),
        'type' => 'varchar',
        'length' => 255,
        'not null' => TRUE,
        'default' => ''),
      'filemime' => array(
        'description' => t('The file MIME type.'),
        'type' => 'varchar',
        'length' => 255,
        'not null' => TRUE,
        'default' => ''),
      'filesize' => array(
        'description' => t('The size of the file in bytes.'),
        'type' => 'int',
        'unsigned' => TRUE,
        'not null' => TRUE,
        'default' => 0),
      'status' => array(
        'description' => t('A flag indicating whether file is temporary (1) or permanent (0).'),
        'type' => 'int',
        'not null' => TRUE,
        'default' => 0),
      'timestamp' => array(
        'description' => t('UNIX timestamp for when the file was added.'),
        'type' => 'int',
        'unsigned' => TRUE,
        'not null' => TRUE,
        'default' => 0),
      ),
    'indexes' => array(
      'uid' => array('uid'),
      'status' => array('status'),
      'timestamp' => array('timestamp'),
      ),
    'primary key' => array('fid'),
    );

  $schema['flood'] = array(
    'description' => t('Flood controls the threshold of events, such as the number of contact attempts.'),
    'fields' => array(
      'fid' => array(
        'description' => t('Unique flood event ID.'),
        'type' => 'serial',
        'not null' => TRUE),
      'event' => array(
        'description' => t('Name of event (e.g. contact).'),
        'type' => 'varchar',
        'length' => 64,
        'not null' => TRUE,
        'default' => ''),
      'hostname' => array(
        'description' => t('Hostname of the visitor.'),
        'type' => 'varchar',
        'length' => 128,
        'not null' => TRUE,
        'default' => ''),
      'timestamp' => array(
        'description' => t('Timestamp of the event.'),
        'type' => 'int',
        'not null' => TRUE,
        'default' => 0)
      ),
    'primary key' => array('fid'),
    );

  $schema['history'] = array(
    'description' => t('A record of which {users} have read which {node}s.'),
    'fields' => array(
      'uid' => array(
        'description' => t('The {users}.uid that read the {node} nid.'),
        'type' => 'int',
        'not null' => TRUE,
        'default' => 0),
      'nid' => array(
        'description' => t('The {node}.nid that was read.'),
        'type' => 'int',
        'not null' => TRUE,
        'default' => 0),
      'timestamp' => array(
        'description' => t('The Unix timestamp at which the read occurred.'),
        'type' => 'int',
        'not null' => TRUE,
        'default' => 0)
      ),
    'primary key' => array('uid', 'nid'),
    );
  $schema['menu_router'] = array(
    'description' => t('Maps paths to various callbacks (access, page and title)'),
    'fields' => array(
      'path' => array(
        'description' => t('Primary Key: the Drupal path this entry describes'),
        'type' => 'varchar',
        'length' => 255,
        'not null' => TRUE,
        'default' => ''),
      'load_functions' => array(
        'description' => t('A serialized array of function names (like node_load) to be called to load an object corresponding to a part of the current path.'),
        'type' => 'varchar',
        'length' => 255,
        'not null' => TRUE,
        'default' => ''),
      'to_arg_functions' => array(
        'description' => t('A serialized array of function names (like user_current_to_arg) to be called to replace a part of the router path with another string.'),
        'type' => 'varchar',
        'length' => 255,
        'not null' => TRUE,
        'default' => ''),
      'access_callback' => array(
        'description' => t('The callback which determines the access to this router path. Defaults to user_access.'),
        'type' => 'varchar',
        'length' => 255,
        'not null' => TRUE,
        'default' => ''),
      'access_arguments' => array(
        'description' => t('A serialized array of arguments for the access callback.'),
        'type' => 'text',
        'not null' => FALSE),
      'page_callback' => array(
        'description' => t('The name of the function that renders the page.'),
        'type' => 'varchar',
        'length' => 255,
        'not null' => TRUE,
        'default' => ''),
      'page_arguments' => array(
        'description' => t('A serialized array of arguments for the page callback.'),
        'type' => 'text',
        'not null' => FALSE),
      'fit' => array(
        'description' => t('A numeric representation of how specific the path is.'),
        'type' => 'int',
        'not null' => TRUE,
        'default' => 0),
      'number_parts' => array(
        'description' => t('Number of parts in this router path.'),
        'type' => 'int',
        'not null' => TRUE,
        'default' => 0,
        'size' => 'small'),
      'tab_parent' => array(
        'description' => t('Only for local tasks (tabs) - the router path of the parent page (which may also be a local task).'),
        'type' => 'varchar',
        'length' => 255,
        'not null' => TRUE,
        'default' => ''),
      'tab_root' => array(
        'description' => t('Router path of the closest non-tab parent page.  For pages that are not local tasks, this will be the same as the path.'),
        'type' => 'varchar',
        'length' => 255,
        'not null' => TRUE,
        'default' => ''),
      'title' => array(
        'description' => t('The title for the current page, or the title for the tab if this is a local task.'),
        'type' => 'varchar',
        'length' => 255,
        'not null' => TRUE,
        'default' => ''),
      'title_callback' => array(
        'description' => t('A function which will alter the title. Defaults to t()'),
        'type' => 'varchar',
        'length' => 255,
        'not null' => TRUE,
        'default' => ''),
      'title_arguments' => array(
        'description' => t('A serialized array of arguments for the title callback.  If empty, the title will be used as the sole argument for the title callback.'),
        'type' => 'varchar',
        'length' => 255,
        'not null' => TRUE,
        'default' => ''),
      'type' => array(
        'description' => t('Numeric representation of the type of the menu item, like MENU_LOCAL_TASK.'),
        'type' => 'int',
        'not null' => TRUE,
        'default' => 0),
      'block_callback' => array(
        'description' => t('Name of a function used to render the block on the system administration page for this item.'),
        'type' => 'varchar',
        'length' => 255,
        'not null' => TRUE,
        'default' => ''),
      'description' => array(
        'description' => t('A description of this item.'),
        'type' => 'text',
        'not null' => TRUE),
      'position' => array(
        'description' => t('The position of the block (left or right) on the system administration page for this item.'),
        'type' => 'varchar',
        'length' => 255,
        'not null' => TRUE,
        'default' => ''),
      'weight' => array(
        'description' => t('Weight of the element. Lighter weights are higher up, heavier weights go down.'),
        'type' => 'int',
        'not null' => TRUE,
        'default' => 0),
      'file' => array(
        'description' => t('The file to include for this element, usually the page callback function lives in this file.'),
        'type' => 'text',
        'size' => 'medium')
      ),
    'indexes' => array(
      'fit' => array('fit'),
      'tab_parent' => array('tab_parent')
      ),
    'primary key' => array('path'),
    );

  $schema['menu_links'] = array(
    'description' => t('Contains the individual links within a menu.'),
    'fields' => array(
     'menu_name' => array(
        'description' => t("The menu name. All links with the same menu name (such as 'navigation') are part of the same menu."),
        'type' => 'varchar',
        'length' => 32,
        'not null' => TRUE,
        'default' => ''),
      'mlid' => array(
        'description' => t('The menu link ID (mlid) is the integer primary key.'),
        'type' => 'serial',
        'unsigned' => TRUE,
        'not null' => TRUE),
      'plid' => array(
        'description' => t('The parent link ID (plid) is the mlid of the link above in the hierarchy, or zero if the link is at the top level in its menu.'),
        'type' => 'int',
        'unsigned' => TRUE,
        'not null' => TRUE,
        'default' => 0),
      'link_path' => array(
        'description' => t('The Drupal path or external path this link point to.'),
        'type' => 'varchar',
        'length' => 255,
        'not null' => TRUE,
        'default' => ''),
      'router_path' => array(
        'description' => t('For links corresponding to a Drupal path (external = 0), this connects the link to a {menu_router}.path for joins.'),
        'type' => 'varchar',
        'length' => 255,
        'not null' => TRUE,
        'default' => ''),
      'link_title' => array(
      'description' => t('The text displayed for the link, which may be modified by a title callback stored in {menu_router}.'),
        'type' => 'varchar',
        'length' => 255,
        'not null' => TRUE,
        'default' => ''),
      'options' => array(
        'description' => t('A serialized array of options to be passed to the url() or l() function, such as a query string or HTML attributes.'),
        'type' => 'text',
        'not null' => FALSE),
      'module' => array(
        'description' => t('The name of the module that generated this link.'),
        'type' => 'varchar',
        'length' => 255,
        'not null' => TRUE,
        'default' => 'system'),
      'hidden' => array(
        'description' => t('A flag for whether the link should be rendered in menus. (1 = a disabled menu item that may be shown on admin screens, -1 = a menu callback, 0 = a normal, visible link)'),
        'type' => 'int',
        'not null' => TRUE,
        'default' => 0,
        'size' => 'small'),
      'external' => array(
        'description' => t('A flag to indicate if the link points to a full URL starting with a protocol, like http:// (1 = external, 0 = internal).'),
        'type' => 'int',
        'not null' => TRUE,
        'default' => 0,
        'size' => 'small'),
      'has_children' => array(
        'description' => t('Flag indicating whether any links have this link as a parent (1 = children exist, 0 = no children).'),
        'type' => 'int',
        'not null' => TRUE,
        'default' => 0,
        'size' => 'small'),
      'expanded' => array(
        'description' => t('Flag for whether this link should be rendered as expanded in menus - expanded links always have their child links displayed, instead of only when the link is in the active trail (1 = expanded, 0 = not expanded)'),
        'type' => 'int',
        'not null' => TRUE,
        'default' => 0,
        'size' => 'small'),
      'weight' => array(
        'description' => t('Link weight among links in the same menu at the same depth.'),
        'type' => 'int',
        'not null' => TRUE,
        'default' => 0),
      'depth' => array(
        'description' => t('The depth relative to the top level. A link with plid == 0 will have depth == 1.'),
        'type' => 'int',
        'not null' => TRUE,
        'default' => 0,
        'size' => 'small'),
      'customized' => array(
        'description' => t('A flag to indicate that the user has manually created or edited the link (1 = customized, 0 = not customized).'),
        'type' => 'int',
        'not null' => TRUE,
        'default' => 0,
        'size' => 'small'),
      'p1' => array(
        'description' => t('The first mlid in the materialized path. If N = depth, then pN must equal the mlid.  If depth > 1 then p(N-1) must equal the plid. All pX where X > depth must equal zero. The columns p1 .. p9 are also called the parents.'),
        'type' => 'int',
        'unsigned' => TRUE,
        'not null' => TRUE,
        'default' => 0),
      'p2' => array(
        'description' => t('The second mlid in the materialized path. See p1.'),
        'type' => 'int',
        'unsigned' => TRUE,
        'not null' => TRUE,
        'default' => 0),
      'p3' => array(
        'description' => t('The third mlid in the materialized path. See p1.'),
        'type' => 'int',
        'unsigned' => TRUE,
        'not null' => TRUE,
        'default' => 0),
      'p4' => array(
        'description' => t('The fourth mlid in the materialized path. See p1.'),
        'type' => 'int',
        'unsigned' => TRUE,
        'not null' => TRUE,
        'default' => 0),
      'p5' => array(
        'description' => t('The fifth mlid in the materialized path. See p1.'),
        'type' => 'int',
        'unsigned' => TRUE,
        'not null' => TRUE,
        'default' => 0),
      'p6' => array(
        'description' => t('The sixth mlid in the materialized path. See p1.'),
        'type' => 'int',
        'unsigned' => TRUE,
        'not null' => TRUE,
        'default' => 0),
      'p7' => array(
        'description' => t('The seventh mlid in the materialized path. See p1.'),
        'type' => 'int',
        'unsigned' => TRUE,
        'not null' => TRUE,
        'default' => 0),
      'p8' => array(
        'description' => t('The eighth mlid in the materialized path. See p1.'),
        'type' => 'int',
        'unsigned' => TRUE,
        'not null' => TRUE,
        'default' => 0),
      'p9' => array(
        'description' => t('The ninth mlid in the materialized path. See p1.'),
        'type' => 'int',
        'unsigned' => TRUE,
        'not null' => TRUE,
        'default' => 0),
      'updated' => array(
        'description' => t('Flag that indicates that this link was generated during the update from Drupal 5.'),
        'type' => 'int',
        'not null' => TRUE,
        'default' => 0,
        'size' => 'small'),
      ),
    'indexes' => array(
      'path_menu' => array(array('link_path', 128), 'menu_name'),
      'menu_plid_expand_child' => array(
        'menu_name', 'plid', 'expanded', 'has_children'),
      'menu_parents' => array(
        'menu_name', 'p1', 'p2', 'p3', 'p4', 'p5', 'p6', 'p7', 'p8', 'p9'),
      'router_path' => array(array('router_path', 128)),
      ),
    'primary key' => array('mlid'),
    );

  $schema['sessions'] = array(
    'description' => t("Drupal's session handlers read and write into the sessions table. Each record represents a user session, either anonymous or authenticated."),
    'fields' => array(
      'uid' => array(
        'description' => t('The {users}.uid corresponding to a session, or 0 for anonymous user.'),
        'type' => 'int',
        'unsigned' => TRUE,
        'not null' => TRUE),
      'sid' => array(
        'description' => t("Primary key: A session ID. The value is generated by PHP's Session API."),
        'type' => 'varchar',
        'length' => 64,
        'not null' => TRUE,
        'default' => ''),
      'hostname' => array(
        'description' => t('The IP address that last used this session ID (sid).'),
        'type' => 'varchar',
        'length' => 128,
        'not null' => TRUE,
        'default' => ''),
      'timestamp' => array(
        'description' => t('The Unix timestamp when this session last requested a page. Old records are purged by PHP automatically.'),
        'type' => 'int',
        'not null' => TRUE,
        'default' => 0),
      'cache' => array(
        'description' => t("The time of this user's last post. This is used when the site has specified a minimum_cache_lifetime. See cache_get()."),
        'type' => 'int',
        'not null' => TRUE,
        'default' => 0),
      'session' => array(
        'description' => t('The serialized contents of $_SESSION, an array of name/value pairs that persists across page requests by this session ID.  Drupal loads $_SESSION from here at the start of each request and saves it at the end.'),
        'type' => 'text',
        'not null' => FALSE,
        'size' => 'big')
      ),
    'primary key' => array('sid'),
    'indexes' => array(
      'timestamp' => array('timestamp'),
      'uid' => array('uid')
      ),
    );

  $schema['system'] = array(
    'description' => t("A list of all modules, themes, and theme engines that are or have been installed in Drupal's file system."),
    'fields' => array(
      'filename' => array(
        'description' => t('The path of the primary file for this item, relative to the Drupal root; e.g. modules/node/node.module.'),
        'type' => 'varchar',
        'length' => 255,
        'not null' => TRUE,
        'default' => ''),
      'name' => array(
        'description' => t('The name of the item; e.g. node.'),
        'type' => 'varchar',
        'length' => 255,
        'not null' => TRUE,
        'default' => ''),
      'type' => array(
        'description' => t('The type of the item, either module, theme, or theme_engine.'),
        'type' => 'varchar',
        'length' => 255,
        'not null' => TRUE,
        'default' => ''),
      'owner' => array(
        'description' => t("A theme's 'parent'. Can be either a theme or an engine."),
        'type' => 'varchar',
        'length' => 255,
        'not null' => TRUE,
        'default' => ''),
      'status' => array(
        'description' => t('Boolean indicating whether or not this item is enabled.'),
        'type' => 'int',
        'not null' => TRUE,
        'default' => 0),
      'throttle' => array(
        'description' => t('Boolean indicating whether this item is disabled when the throttle.module disables throttlable items.'),
        'type' => 'int',
        'not null' => TRUE,
        'default' => 0,
        'size' => 'tiny'),
      'bootstrap' => array(
        'description' => t("Boolean indicating whether this module is loaded during Drupal's early bootstrapping phase (e.g. even before the page cache is consulted)."),
        'type' => 'int',
        'not null' => TRUE,
        'default' => 0),
      'schema_version' => array(
        'description' => t("The module's database schema version number.  -1 if the module is not installed (its tables do not exist); 0 or the largest N of the module's hook_update_N() function that has either been run or existed when the module was first installed."),
        'type' => 'int',
        'not null' => TRUE,
        'default' => -1,
        'size' => 'small'),
      'weight' => array(
        'description' => t("The order in which this module's hooks should be invoked relative to other modules.  Equal-weighted modules are ordered by name."),
        'type' => 'int',
        'not null' => TRUE,
        'default' => 0),
      'info' => array(
        'description' => t("A serialized array containing information from the module's .info file; keys can include name, description, package, version, core, dependencies, depedents, and php."),
        'type' => 'text',
        'not null' => FALSE)
      ),
    'primary key' => array('filename'),
    'indexes' => array('weight' => array('weight')),
    );

  $schema['url_alias'] = array(
    'description' => t('A list of URL aliases for Drupal paths; a user may visit either the source or destination path.'),
    'fields' => array(
      'pid' => array(
        'description' => t('A unique path alias identifier.'),
        'type' => 'serial',
        'unsigned' => TRUE,
        'not null' => TRUE),
      'src' => array(
        'description' => t('The Drupal path this alias is for; e.g. node/12.'),
        'type' => 'varchar',
        'length' => 128,
        'not null' => TRUE,
        'default' => ''),
      'dst' => array(
        'description' => t('The alias for this path; e.g. title-of-the-story.'),
        'type' => 'varchar',
        'length' => 128,
        'not null' => TRUE,
        'default' => ''),
      'language' => array(
        'description' => t('The language this alias is for; if blank, the alias will be used for unknown languages.  Each Drupal path can have an alias for each supported language.'),
        'type' => 'varchar',
        'length' => 12,
        'not null' => TRUE,
        'default' => '')
      ),
    'unique keys' => array('dst_language' => array('dst', 'language')),
    'primary key' => array('pid'),
    'indexes' => array('src' => array('src')),
    );

  return $schema;
}


// Updates for core

function system_update_110() {
  $ret = array();

  // TODO: needs PGSQL version
  if ($GLOBALS['db_type'] == 'mysql') {
    /*
    ** Search
    */

    $ret[] = update_sql('DROP TABLE {search_index}');
    $ret[] = update_sql("CREATE TABLE {search_index} (
      word varchar(50) NOT NULL default '',
      sid int unsigned NOT NULL default '0',
      type varchar(16) default NULL,
      fromsid int unsigned NOT NULL default '0',
      fromtype varchar(16) default NULL,
      score int unsigned default NULL,
      KEY sid (sid),
      KEY fromsid (fromsid),
      KEY word (word)
      )");

    $ret[] = update_sql("CREATE TABLE {search_total} (
      word varchar(50) NOT NULL default '',
      count int unsigned default NULL,
      PRIMARY KEY word (word)
      )");


    /*
    ** Blocks
    */

    $ret[] = update_sql('ALTER TABLE {blocks} DROP path');
    $ret[] = update_sql('ALTER TABLE {blocks} ADD visibility tinyint NOT NULL');
    $ret[] = update_sql('ALTER TABLE {blocks} ADD pages text NOT NULL');
  }
  elseif ($GLOBALS['db_type'] == 'pgsql') {
    /*
    ** Search
    */
    $ret[] = update_sql('DROP TABLE {search_index}');
    $ret[] = update_sql("CREATE TABLE {search_index} (
      word varchar(50) NOT NULL default '',
      sid integer NOT NULL default '0',
      type varchar(16) default NULL,
      fromsid integer NOT NULL default '0',
      fromtype varchar(16) default NULL,
      score integer default NULL
      )");
    $ret[] = update_sql("CREATE INDEX {search_index}_sid_idx on {search_index}(sid)");
    $ret[] = update_sql("CREATE INDEX {search_index}_fromsid_idx on {search_index}(fromsid)");
    $ret[] = update_sql("CREATE INDEX {search_index}_word_idx on {search_index}(word)");

    $ret[] = update_sql("CREATE TABLE {search_total} (
      word varchar(50) NOT NULL default '' PRIMARY KEY,
      count integer default NULL
      )");


    /*
    ** Blocks
    */
    // Postgres can only drop columns since 7.4
    #$ret[] = update_sql('ALTER TABLE {blocks} DROP path');

    $ret[] = update_sql('ALTER TABLE {blocks} ADD visibility smallint');
    $ret[] = update_sql("ALTER TABLE {blocks} ALTER COLUMN visibility set default 0");
    $ret[] = update_sql('UPDATE {blocks} SET visibility = 0');
    $ret[] = update_sql('ALTER TABLE {blocks} ALTER COLUMN visibility SET NOT NULL');
    $ret[] = update_sql('ALTER TABLE {blocks} ADD pages text');
    $ret[] = update_sql("ALTER TABLE {blocks} ALTER COLUMN pages set default ''");
    $ret[] = update_sql("UPDATE {blocks} SET pages = ''");
    $ret[] = update_sql('ALTER TABLE {blocks} ALTER COLUMN pages SET NOT NULL');

  }

  $ret[] = update_sql("DELETE FROM {variable} WHERE name = 'node_cron_last'");

  $ret[] = update_sql('UPDATE {blocks} SET status = 1, custom = 2 WHERE status = 0 AND custom = 1');

  return $ret;
}

function system_update_111() {
  $ret = array();

  $ret[] = update_sql("DELETE FROM {variable} WHERE name LIKE 'throttle_%'");

  if ($GLOBALS['db_type'] == 'mysql') {
    $ret[] = update_sql('ALTER TABLE {sessions} ADD PRIMARY KEY sid (sid)');
  }
  elseif ($GLOBALS['db_type'] == 'pgsql') {
    $ret[] = update_sql('ALTER TABLE {sessions} ADD UNIQUE(sid)');
  }

  return $ret;
}

function system_update_112() {
  $ret = array();

  if ($GLOBALS['db_type'] == 'mysql') {
    $ret[] = update_sql("CREATE TABLE {flood} (
      event varchar(64) NOT NULL default '',
      hostname varchar(128) NOT NULL default '',
      timestamp int NOT NULL default '0'
     );");
  }
  elseif ($GLOBALS['db_type'] == 'pgsql') {
    $ret[] = update_sql("CREATE TABLE {flood} (
      event varchar(64) NOT NULL default '',
      hostname varchar(128) NOT NULL default '',
      timestamp integer NOT NULL default 0
     );");
  }

  return $ret;
}

function system_update_113() {
  $ret = array();

  if ($GLOBALS['db_type'] == 'mysql') {
    $ret[] = update_sql('ALTER TABLE {accesslog} ADD aid int NOT NULL auto_increment, ADD PRIMARY KEY (aid)');
  }
  elseif ($GLOBALS['db_type'] == 'pgsql') {
    $ret[] = update_sql("SELECT * INTO TEMPORARY {accesslog}_t FROM {accesslog}");
    $ret[] = update_sql("DROP TABLE {accesslog}");
    $ret[] = update_sql("CREATE TABLE {accesslog} (
      aid serial,
      title varchar(255) default NULL,
      path varchar(255) default NULL,
      url varchar(255) default NULL,
      hostname varchar(128) default NULL,
      uid integer default '0',
      timestamp integer NOT NULL default '0'
    )");
    $ret[] = update_sql("INSERT INTO {accesslog} (title, path, url, hostname, uid, timestamp) SELECT title, path, url, hostname, uid, timestamp FROM {accesslog}_t");

    $ret[] = update_sql("DROP TABLE {accesslog}_t");
    $ret[] = update_sql("CREATE INDEX {accesslog}_timestamp_idx ON {accesslog} (timestamp);");

  }

  // Flush the menu cache:
  cache_clear_all('menu:', TRUE);

  return $ret;
}

function system_update_114() {
  $ret = array();
  if ($GLOBALS['db_type'] == 'mysql') {
    $ret[] = update_sql("CREATE TABLE {queue} (
      nid int unsigned NOT NULL,
      uid int unsigned NOT NULL,
      vote int NOT NULL default '0',
      PRIMARY KEY (nid, uid)
     )");
  }
  else if ($GLOBALS['db_type'] == 'pgsql') {
    $ret[] = update_sql("CREATE TABLE {queue} (
      nid integer NOT NULL default '0',
      uid integer NOT NULL default '0',
      vote integer NOT NULL default '0',
      PRIMARY KEY (nid, uid)
    )");
    $ret[] = update_sql("CREATE INDEX {queue}_nid_idx ON queue(nid)");
    $ret[] = update_sql("CREATE INDEX {queue}_uid_idx ON queue(uid)");
  }

  $result = db_query("SELECT nid, votes, score, users FROM {node}");
  while ($node = db_fetch_object($result)) {
    if (isset($node->users)) {
      $arr = explode(',', $node->users);
      unset($node->users);
      foreach ($arr as $value) {
        $arr2 = explode('=', trim($value));
        if (isset($arr2[0]) && isset($arr2[1])) {
          switch ($arr2[1]) {
            case '+ 1':
              db_query("INSERT INTO {queue} (nid, uid, vote) VALUES (%d, %d, %d)", $node->nid, (int)$arr2[0], 1);
              break;
            case '- 1':
              db_query("INSERT INTO {queue} (nid, uid, vote) VALUES (%d, %d, %d)", $node->nid, (int)$arr2[0], -1);
              break;
            default:
              db_query("INSERT INTO {queue} (nid, uid, vote) VALUES (%d, %d, %d)", $node->nid, (int)$arr2[0], 0);
          }
        }
      }
    }
  }

  if ($GLOBALS['db_type'] == 'mysql') {
    // Postgres only supports dropping of columns since 7.4
    $ret[] = update_sql("ALTER TABLE {node} DROP votes");
    $ret[] = update_sql("ALTER TABLE {node} DROP score");
    $ret[] = update_sql("ALTER TABLE {node} DROP users");
  }

  return $ret;
}

function system_update_115() {
  $ret = array();

  // This update has been moved to update_fix_watchdog_115 in update.php because it
  // is needed for the basic functioning of the update script.

  return $ret;
}

function system_update_116() {
  return array(update_sql("DELETE FROM {system} WHERE name = 'admin'"));
}

function system_update_117() {
  $ret = array();
  if ($GLOBALS['db_type'] == 'mysql') {
    $ret[] = update_sql("CREATE TABLE {vocabulary_node_types} (
                         vid int NOT NULL default '0',
                         type varchar(16) NOT NULL default '',
                         PRIMARY KEY (vid, type))");
  }
  else if ($GLOBALS['db_type'] == 'pgsql') {
    $ret[] = update_sql("CREATE TABLE {vocabulary_node_types} (
                         vid serial,
                         type varchar(16) NOT NULL default '',
                          PRIMARY KEY (vid, type)) ");
  }
  return $ret;
}

function system_update_118() {
  $ret = array();
  $node_types = array();
  $result = db_query('SELECT vid, nodes FROM {vocabulary}');
  while ($vocabulary = db_fetch_object($result)) {
    $node_types[$vocabulary->vid] = explode(',', $vocabulary->nodes);
  }
  foreach ($node_types as $vid => $type_array) {
    foreach ($type_array as $type) {
      db_query("INSERT INTO {vocabulary_node_types} (vid, type) VALUES (%d, '%s')", $vid, $type);
    }
  }
  if ($GLOBALS['db_type'] == 'mysql') {
    $ret[] = update_sql("ALTER TABLE {vocabulary} DROP nodes");
  }
  return $ret;
}

function system_update_119() {
  $ret = array();

  foreach (node_get_types() as $type => $name) {
    $node_options = array();
    if (variable_get('node_status_'. $type, 1)) {
      $node_options[] = 'status';
    }
    if (variable_get('node_moderate_'. $type, 0)) {
      $node_options[] = 'moderate';
    }
    if (variable_get('node_promote_'. $type, 1)) {
      $node_options[] = 'promote';
    }
    if (variable_get('node_sticky_'. $type, 0)) {
      $node_options[] = 'sticky';
    }
    if (variable_get('node_revision_'. $type, 0)) {
      $node_options[] = 'revision';
    }
    variable_set('node_options_'. $type, $node_options);
    variable_del('node_status_'. $type);
    variable_del('node_moderate_'. $type);
    variable_del('node_promote_'. $type);
    variable_del('node_sticky_'. $type);
    variable_del('node_revision_'. $type);
  }

  return $ret;
}

function system_update_120() {
  $ret = array();

  // Rewrite old URL aliases. Works for both PostgreSQL and MySQL
  $result = db_query("SELECT pid, src FROM {url_alias} WHERE src LIKE 'blog/%%'");
  while ($alias = db_fetch_object($result)) {
    list(, $page, $op, $uid) = explode('/', $alias->src);
    if ($page == 'feed') {
      $new = "blog/$uid/feed";
      update_sql("UPDATE {url_alias} SET src = '%s' WHERE pid = '%s'", $new, $alias->pid);
    }
  }

  return $ret;
}

function system_update_121() {
  $ret = array();

  // Remove the unused page table.
  $ret[] = update_sql('DROP TABLE {page}');

  return $ret;
}

function system_update_122() {

  $ret = array();
  $ret[] = update_sql("ALTER TABLE {blocks} ADD types text");
  return $ret;

}

function system_update_123() {
  $ret = array();

  if ($GLOBALS['db_type'] == 'mysql') {
    $ret[] = update_sql("ALTER TABLE {vocabulary} ADD module varchar(255) NOT NULL default ''");
  }
  elseif ($GLOBALS['db_type'] == 'pgsql') {
    $ret[] = update_sql("ALTER TABLE {vocabulary} ADD module varchar(255)");
    $ret[] = update_sql("UPDATE {vocabulary} SET module = ''");
    $ret[] = update_sql("ALTER TABLE {vocabulary} ALTER COLUMN module SET NOT NULL");
    $ret[] = update_sql("ALTER TABLE {vocabulary} ALTER COLUMN module SET DEFAULT ''");
  }

  $ret[] = update_sql("UPDATE {vocabulary} SET module = 'taxonomy'");
  $vid = variable_get('forum_nav_vocabulary', '');
  if (!empty($vid)) {
    $ret[] = update_sql("UPDATE {vocabulary} SET module = 'forum' WHERE vid = " . $vid);
  }

  return $ret;
}

function system_update_124() {
  $ret = array();

  if ($GLOBALS['db_type'] == 'mysql') {
    // redo update_105, correctly creating node_comment_statistics
    $ret[] = update_sql("DROP TABLE IF EXISTS {node_comment_statistics}");

    $ret[] = update_sql("CREATE TABLE {node_comment_statistics} (
      nid int unsigned NOT NULL auto_increment,
      last_comment_timestamp int NOT NULL default '0',
      last_comment_name varchar(60) default NULL,
      last_comment_uid int NOT NULL default '0',
      comment_count int unsigned NOT NULL default '0',
      PRIMARY KEY (nid),
      KEY node_comment_timestamp (last_comment_timestamp)
      )");
  }

  else {
    // also drop incorrectly named table for PostgreSQL
    $ret[] = update_sql("DROP TABLE {node}_comment_statistics");

    $ret[] = update_sql("CREATE TABLE {node_comment_statistics} (
      nid integer NOT NULL,
      last_comment_timestamp integer NOT NULL default '0',
      last_comment_name varchar(60)  default NULL,
      last_comment_uid integer NOT NULL default '0',
      comment_count integer NOT NULL default '0',
      PRIMARY KEY (nid)
    )");

    $ret[] = update_sql("CREATE INDEX {node_comment_statistics}_timestamp_idx ON {node_comment_statistics}(last_comment_timestamp);
");
  }

  // initialize table
  $ret[] = update_sql("INSERT INTO {node_comment_statistics} (nid, last_comment_timestamp, last_comment_name, last_comment_uid, comment_count) SELECT n.nid, n.changed, NULL, 0, 0 FROM {node} n");

  // fill table
  $result = db_query("SELECT c.nid, c.timestamp, c.name, c.uid, COUNT(c.nid) as comment_count FROM {node} n LEFT JOIN {comments} c ON c.nid = n.nid WHERE c.status = 0 GROUP BY c.nid, c.timestamp, c.name, c.uid");
  while ($comment_record = db_fetch_object($result)) {
    $count = db_result(db_query('SELECT COUNT(cid) FROM {comments} WHERE nid = %d AND status = 0', $comment_record->nid));
    db_query("UPDATE {node_comment_statistics} SET comment_count = %d, last_comment_timestamp = %d, last_comment_name = '%s', last_comment_uid = %d WHERE nid = %d", $count, $comment_record->timestamp, $comment_record->name, $comment_record->uid, $comment_record->nid);
  }

  return $ret;
}

function system_update_125() {
  // Postgres only update.
  $ret = array();

  if ($GLOBALS['db_type'] == 'pgsql') {

    $ret[] = update_sql("CREATE OR REPLACE FUNCTION if(boolean, anyelement, anyelement) RETURNS anyelement AS '
          SELECT CASE WHEN $1 THEN $2 ELSE $3 END;
        ' LANGUAGE 'sql'");

    $ret[] = update_sql("CREATE FUNCTION greatest(integer, integer, integer) RETURNS integer AS '
                          SELECT greatest($1, greatest($2, $3));
                        ' LANGUAGE 'sql'");

  }

  return $ret;
}

function system_update_126() {
  variable_set('forum_block_num_0', variable_get('forum_block_num', 5));
  variable_set('forum_block_num_1', variable_get('forum_block_num', 5));
  variable_del('forum_block_num');

  return array();
}

function system_update_127() {
  $ret = array();
  if ($GLOBALS['db_type'] == 'pgsql') {
    $ret[] = update_sql("ALTER TABLE {poll} RENAME voters TO polled");
  }
  else if ($GLOBALS['db_type'] == 'mysql') {
    $ret[] = update_sql("ALTER TABLE {poll} CHANGE voters polled longtext");
  }
  return $ret;
}

function system_update_128() {
  $ret = array();

  if ($GLOBALS['db_type'] == 'mysql') {
    $ret[] = update_sql('ALTER TABLE {term_node} ADD PRIMARY KEY (tid,nid)');
  }
  elseif ($GLOBALS['db_type'] == 'pgsql') {
    $ret[] = update_sql('ALTER TABLE {term_node} ADD PRIMARY KEY (tid,nid)');
  }

  return $ret;
}

function system_update_129() {
  $ret = array();

  if ($GLOBALS['db_type'] == 'mysql') {
    $ret[] = update_sql("ALTER TABLE {vocabulary} ADD tags tinyint unsigned default '0' NOT NULL");
  }
  elseif ($GLOBALS['db_type'] == 'pgsql') {
    db_add_column($ret, 'vocabulary', 'tags', 'smallint', array('default' => 0, 'not null' => TRUE));
  }

  return $ret;
}

function system_update_130() {
  $ret = array();

  // This update has been moved to update_fix_sessions in update.php because it
  // is needed for the basic functioning of the update script.

  return $ret;
}

function system_update_131() {
  $ret = array();

  if ($GLOBALS['db_type'] == 'mysql') {
    $ret[] = update_sql("ALTER TABLE {boxes} DROP INDEX title");
    // Removed recreation of the index, which is not present in the db schema
  }
  elseif ($GLOBALS['db_type'] == 'pgsql') {
    $ret[] = update_sql("ALTER TABLE {boxes} DROP CONSTRAINT {boxes}_title_key");
  }

  return $ret;
}

function system_update_132() {
  /**
   * PostgreSQL only update.
   */
  $ret = array();

  if (!variable_get('update_132_done', FALSE)) {
    if ($GLOBALS['db_type'] == 'pgsql') {
      $ret[] = update_sql('DROP TABLE {search_total}');
      $ret[] = update_sql("CREATE TABLE {search_total} (
        word varchar(50) NOT NULL default '',
             count float default NULL)");
      $ret[] = update_sql('CREATE INDEX {search_total}_word_idx ON {search_total}(word)');

      /**
       * Wipe the search index
       */
      include_once './'. drupal_get_path('module', 'search') .'/search.module';
      search_wipe();
    }

    variable_del('update_132_done');
  }

  return $ret;
}

function system_update_133() {
  $ret = array();

  if ($GLOBALS['db_type'] == 'mysql') {
    $ret[] = update_sql("CREATE TABLE {contact} (
      subject varchar(255) NOT NULL default '',
      recipients longtext NOT NULL,
      reply longtext NOT NULL
      )");
    $ret[] = update_sql("ALTER TABLE {users} ADD login int NOT NULL default '0'");
  }
  elseif ($GLOBALS['db_type'] == 'pgsql') {
    // Table {contact} is changed in update_143() so I have moved it's creation there.
    // It was never created here for postgres because of errors.

    db_add_column($ret, 'users', 'login', 'int', array('default' => 0, 'not null' => TRUE));
  }

  return $ret;
}

function system_update_134() {
  $ret = array();
  $ret[] = update_sql('ALTER TABLE {blocks} DROP types');
  return $ret;
}

function system_update_135() {
  if (!variable_get('update_135_done', FALSE)) {
    $result = db_query("SELECT delta FROM {blocks} WHERE module = 'aggregator'");
    while ($block = db_fetch_object($result)) {
      list($type, $id) = explode(':', $block->delta);
      db_query("UPDATE {blocks} SET delta = '%s' WHERE module = 'aggregator' AND delta = '%s'", $type .'-'. $id, $block->delta);
    }

    variable_del('update_135_done');
  }
  return array();
}

function system_update_136() {
  $ret = array();

  switch ($GLOBALS['db_type']) {
    case 'pgsql':
      $ret[] = update_sql("DROP INDEX {users}_changed_idx"); // We drop the index first because it won't be renamed
      $ret[] = update_sql("ALTER TABLE {users} RENAME changed TO access");
      $ret[] = update_sql("CREATE INDEX {users}_access_idx on {users}(access)"); // Re-add the index
      break;
    case 'mysql':
    case 'mysqli':
      $ret[] = update_sql("ALTER TABLE {users} CHANGE COLUMN changed access int NOT NULL default '0'");
      break;
  }

  $ret[] = update_sql('UPDATE {users} SET access = login WHERE login > created');
  $ret[] = update_sql('UPDATE {users} SET access = created WHERE access = 0');
  return $ret;
}

function system_update_137() {
  $ret = array();

  if (!variable_get('update_137_done', FALSE)) {
    if ($GLOBALS['db_type'] == 'mysql') {
      $ret[] = update_sql("ALTER TABLE {locales_source} CHANGE location location varchar(255) NOT NULL default ''");
    }
    elseif ($GLOBALS['db_type'] == 'pgsql') {
      db_change_column($ret, 'locales_source', 'location', 'location', 'varchar(255)', array('not null' => TRUE, 'default' => "''"));
    }
    variable_del('update_137_done');
  }

  return $ret;
}

function system_update_138() {
  $ret = array();
  // duplicate of update_97 which never got into the default database.* files.
  $ret[] = update_sql("INSERT INTO {url_alias} (src, dst) VALUES ('node/feed', 'rss.xml')");
  return $ret;
}

function system_update_139() {
  $ret = array();
  switch ($GLOBALS['db_type']) {
    case 'pgsql':
      db_add_column($ret, 'accesslog', 'timer', 'int', array('not null' => TRUE, 'default' => 0));
      break;
    case 'mysql':
    case 'mysqli':
      $ret[] = update_sql("ALTER TABLE {accesslog} ADD timer int unsigned NOT NULL default '0'");
      break;
  }

  return $ret;
}

function system_update_140() {
  $ret = array();

  if ($GLOBALS['db_type'] == 'mysql') {
    $ret[] = update_sql("ALTER TABLE {url_alias} ADD INDEX (src)");
  }
  elseif ($GLOBALS['db_type'] == 'pgsql') {
    $ret[] = update_sql("CREATE INDEX {url_alias}_src_idx ON {url_alias}(src)");
  }
  return $ret;
}

function system_update_141() {
  $ret = array();

  variable_del('upload_maxsize_total');

  return $ret;
}

function system_update_142() {
  $ret = array();

  // This update has been moved to update_fix_sessions in update.php because it
  // is needed for the basic functioning of the update script.

  return $ret;
}

function system_update_143() {
  $ret = array();

  if ($GLOBALS['db_type'] == 'mysql') {
    $ret[] = update_sql("ALTER TABLE {contact} CHANGE subject category VARCHAR(255) NOT NULL ");
    $ret[] = update_sql("ALTER TABLE {contact} ADD PRIMARY KEY (category)");
  }
  elseif ($GLOBALS['db_type'] == 'pgsql') {
    // Why the table is created here? See update_133().
    $ret[] = update_sql("CREATE TABLE {contact} (
      category varchar(255) NOT NULL default '',
      recipients text NOT NULL default '',
      reply text NOT NULL default '',
      PRIMARY KEY (category))");
  }

  return $ret;
}

function system_update_144() {
  $ret = array();
  if ($GLOBALS['db_type'] == 'mysql') {
    $ret[] = update_sql("ALTER TABLE {node} CHANGE type type VARCHAR(32) NOT NULL");
  }
  elseif ($GLOBALS['db_type'] == 'pgsql') {
    $ret[] = update_sql("DROP INDEX {node}_type_idx"); // Drop indexes using "type" column
    $ret[] = update_sql("DROP INDEX {node}_title_idx");
    db_change_column($ret, 'node', 'type', 'type', 'varchar(32)', array('not null' => TRUE, 'default' => "''"));
    // Let's recreate the indexes
    $ret[] = update_sql("CREATE INDEX {node}_type_idx ON {node}(type)");
    $ret[] = update_sql("CREATE INDEX {node}_title_type_idx ON {node}(title,type)");
    $ret[] = update_sql("CREATE INDEX {node}_status_type_nid_idx ON {node}(status,type,nid)");
  }
  return $ret;
}

function system_update_145() {
  $default_theme = variable_get('theme_default', 'garland');

  $themes = list_themes();
  if (!array_key_exists($default_theme, $themes)) {
    variable_set('theme_default', 'garland');
    $default_theme = 'garland';
  }

  $ret = array();

  switch ($GLOBALS['db_type']) {
    case 'pgsql':
      db_change_column($ret, 'blocks', 'region', 'region', 'varchar(64)', array('default' => "'left'", 'not null' => TRUE));
      db_add_column($ret, 'blocks', 'theme', 'varchar(255)', array('not null' => TRUE, 'default' => "''"));
      break;
    case 'mysql':
    case 'mysqli':
      $ret[] = update_sql("ALTER TABLE {blocks} CHANGE region region varchar(64) default 'left' NOT NULL");
      $ret[] = update_sql("ALTER TABLE {blocks} ADD theme varchar(255) NOT NULL default ''");
      break;
  }

  // Initialize block data for default theme
  $ret[] = update_sql("UPDATE {blocks} SET region = 'left' WHERE region = '0'");
  $ret[] = update_sql("UPDATE {blocks} SET region = 'right' WHERE region = '1'");
  db_query("UPDATE {blocks} SET theme = '%s'", $default_theme);

  // Initialize block data for other enabled themes.
  $themes = list_themes();
  foreach (array_keys($themes) as $theme) {
    if (($theme != $default_theme) && $themes[$theme]->status == 1) {
      system_initialize_theme_blocks($theme);
    }
  }

  return $ret;
}

function system_update_146() {
  $ret = array();

  if ($GLOBALS['db_type'] == 'mysql') {
    $ret[] = update_sql("CREATE TABLE {node_revisions}
                                SELECT nid, nid AS vid, uid, type, title, body, teaser, changed AS timestamp, format
                                FROM {node}");

    $ret[] = update_sql("ALTER TABLE {node_revisions} CHANGE nid nid int unsigned NOT NULL default '0'");
    $ret[] = update_sql("ALTER TABLE {node_revisions} ADD log longtext");

    $ret[] = update_sql("ALTER TABLE {node} ADD vid int unsigned NOT NULL default '0'");
    $ret[] = update_sql("ALTER TABLE {files} ADD vid int unsigned NOT NULL default '0'");
    $ret[] = update_sql("ALTER TABLE {book} ADD vid int unsigned NOT NULL default '0'");
    $ret[] = update_sql("ALTER TABLE {forum} ADD vid int unsigned NOT NULL default '0'");

    $ret[] = update_sql("ALTER TABLE {book} DROP PRIMARY KEY");
    $ret[] = update_sql("ALTER TABLE {forum} DROP PRIMARY KEY");
    $ret[] = update_sql("ALTER TABLE {files} DROP PRIMARY KEY");

    $ret[] = update_sql("UPDATE {node} SET vid = nid");
    $ret[] = update_sql("UPDATE {forum} SET vid = nid");
    $ret[] = update_sql("UPDATE {book} SET vid = nid");
    $ret[] = update_sql("UPDATE {files} SET vid = nid");

    $ret[] = update_sql("ALTER TABLE {book} ADD PRIMARY KEY vid (vid)");
    $ret[] = update_sql("ALTER TABLE {forum} ADD PRIMARY KEY vid (vid)");
    $ret[] = update_sql("ALTER TABLE {node_revisions} ADD PRIMARY KEY vid (vid)");
    $ret[] = update_sql("ALTER TABLE {node_revisions} ADD KEY nid (nid)");
    $ret[] = update_sql("ALTER TABLE {node_revisions} ADD KEY uid (uid)");

    $ret[] = update_sql("CREATE TABLE {old_revisions} SELECT nid, type, revisions FROM {node} WHERE revisions != ''");

    $ret[] = update_sql("ALTER TABLE {book} ADD KEY nid (nid)");
    $ret[] = update_sql("ALTER TABLE {forum} ADD KEY nid (nid)");
    $ret[] = update_sql("ALTER TABLE {files} ADD KEY fid (fid)");
    $ret[] = update_sql("ALTER TABLE {files} ADD KEY vid (vid)");
    $vid = db_next_id('{node}_nid');
    $ret[] = update_sql("INSERT INTO {sequences} (name, id) VALUES ('{node_revisions}_vid', $vid)");
  }
  else { // pgsql
    $ret[] = update_sql("CREATE TABLE {node_revisions} (
      nid integer NOT NULL default '0',
      vid integer NOT NULL default '0',
      uid integer NOT NULL default '0',
      title varchar(128) NOT NULL default '',
      body text NOT NULL default '',
      teaser text NOT NULL default '',
      log text NOT NULL default '',
      timestamp integer NOT NULL default '0',
      format int NOT NULL default '0',
      PRIMARY KEY (vid))");
    $ret[] = update_sql("INSERT INTO {node_revisions} (nid, vid, uid, title, body, teaser, timestamp, format)
      SELECT nid, nid AS vid, uid, title, body, teaser, changed AS timestamp, format
      FROM {node}");
    $ret[] = update_sql('CREATE INDEX {node_revisions}_nid_idx ON {node_revisions}(nid)');
    $ret[] = update_sql('CREATE INDEX {node_revisions}_uid_idx ON {node_revisions}(uid)');
    $vid = db_next_id('{node}_nid');
    $ret[] = update_sql("CREATE SEQUENCE {node_revisions}_vid_seq INCREMENT 1 START $vid");

    db_add_column($ret, 'node',  'vid', 'int', array('not null' => TRUE, 'default' => 0));
    db_add_column($ret, 'files', 'vid', 'int', array('not null' => TRUE, 'default' => 0));
    db_add_column($ret, 'book',  'vid', 'int', array('not null' => TRUE, 'default' => 0));
    db_add_column($ret, 'forum', 'vid', 'int', array('not null' => TRUE, 'default' => 0));

    $ret[] = update_sql("ALTER TABLE {book} DROP CONSTRAINT {book}_pkey");
    $ret[] = update_sql("ALTER TABLE {forum} DROP CONSTRAINT {forum}_pkey");
    $ret[] = update_sql("ALTER TABLE {files} DROP CONSTRAINT {files}_pkey");

    $ret[] = update_sql("UPDATE {node} SET vid = nid");
    $ret[] = update_sql("UPDATE {forum} SET vid = nid");
    $ret[] = update_sql("UPDATE {book} SET vid = nid");
    $ret[] = update_sql("UPDATE {files} SET vid = nid");

    $ret[] = update_sql("ALTER TABLE {book} ADD PRIMARY KEY (vid)");
    $ret[] = update_sql("ALTER TABLE {forum} ADD PRIMARY KEY (vid)");

    $ret[] = update_sql("CREATE TABLE {old_revisions} AS SELECT nid, type, revisions FROM {node} WHERE revisions != ''");

    $ret[] = update_sql('CREATE INDEX {node}_vid_idx ON {node}(vid)');
    $ret[] = update_sql('CREATE INDEX {forum}_nid_idx ON {forum}(nid)');
    $ret[] = update_sql('CREATE INDEX {files}_fid_idx ON {files}(fid)');
    $ret[] = update_sql('CREATE INDEX {files}_vid_idx ON {files}(vid)');
  }

  // Move logs too.
  $result = db_query("SELECT nid, log FROM {book} WHERE log != ''");
  while ($row = db_fetch_object($result)) {
    db_query("UPDATE {node_revisions} SET log = '%s' WHERE vid = %d", $row->log, $row->nid);
  }

  $ret[] = update_sql("ALTER TABLE {book} DROP log");
  $ret[] = update_sql("ALTER TABLE {node} DROP teaser");
  $ret[] = update_sql("ALTER TABLE {node} DROP body");
  $ret[] = update_sql("ALTER TABLE {node} DROP format");
  $ret[] = update_sql("ALTER TABLE {node} DROP revisions");

  return $ret;
}

function system_update_147() {
  $ret = array();

  // this update is mysql only, pgsql should get it right in the first try.
  if ($GLOBALS['db_type'] == 'mysql') {
    $ret[] = update_sql("ALTER TABLE {node_revisions} DROP type");
  }

  return $ret;
}

function system_update_148() {
  $ret = array();

  // Add support for tracking users' session ids (useful for tracking anon users)
  switch ($GLOBALS['db_type']) {
    case 'pgsql':
      db_add_column($ret, 'accesslog', 'sid', 'varchar(32)', array('not null' => TRUE, 'default' => "''"));
      break;
    case 'mysql':
    case 'mysqli':
      $ret[] = update_sql("ALTER TABLE {accesslog} ADD sid varchar(32) NOT NULL default ''");
      break;
  }

  return $ret;
}

function system_update_149() {
  $ret = array();

  switch ($GLOBALS['db_type']) {
    case 'pgsql':
      db_add_column($ret, 'files', 'description', 'varchar(255)', array('not null' => TRUE, 'default' => "''"));
      break;
    case 'mysql':
    case 'mysqli':
      $ret[] = update_sql("ALTER TABLE {files} ADD COLUMN description VARCHAR(255) NOT NULL DEFAULT ''");
      break;
    default:
      break;
  }

  return $ret;
}

function system_update_150() {
  $ret = array();

  $ret[] = update_sql("DELETE FROM {variable} WHERE name = 'node_cron_last'");
  $ret[] = update_sql("DELETE FROM {variable} WHERE name = 'minimum_word_size'");
  $ret[] = update_sql("DELETE FROM {variable} WHERE name = 'remove_short'");

  $ret[] = update_sql("DELETE FROM {node_counter} WHERE nid = 0");

  $ret[] = update_sql('DROP TABLE {search_index}');
  $ret[] = update_sql('DROP TABLE {search_total}');

  switch ($GLOBALS['db_type']) {
    case 'mysqli':
    case 'mysql':
      $ret[] = update_sql("CREATE TABLE {search_dataset} (
                           sid int unsigned NOT NULL default '0',
                           type varchar(16) default NULL,
                           data longtext NOT NULL,
                           KEY sid_type (sid, type)
                           )");

      $ret[] = update_sql("CREATE TABLE {search_index} (
                           word varchar(50) NOT NULL default '',
                           sid int unsigned NOT NULL default '0',
                           type varchar(16) default NULL,
                           fromsid int unsigned NOT NULL default '0',
                           fromtype varchar(16) default NULL,
                           score float default NULL,
                           KEY sid_type (sid, type),
                           KEY from_sid_type (fromsid, fromtype),
                           KEY word (word)
                           )");

      $ret[] = update_sql("CREATE TABLE {search_total} (
                           word varchar(50) NOT NULL default '',
                           count float default NULL,
                           PRIMARY KEY word (word)
                           )");
      break;
    case 'pgsql':
      $ret[] = update_sql("CREATE TABLE {search_dataset} (
        sid integer NOT NULL default '0',
        type varchar(16) default NULL,
        data text NOT NULL default '')");
      $ret[] = update_sql("CREATE INDEX {search_dataset}_sid_type_idx ON {search_dataset}(sid, type)");

      $ret[] = update_sql("CREATE TABLE {search_index} (
        word varchar(50) NOT NULL default '',
        sid integer NOT NULL default '0',
        type varchar(16) default NULL,
        fromsid integer NOT NULL default '0',
        fromtype varchar(16) default NULL,
        score float default NULL)");
      $ret[] = update_sql("CREATE INDEX {search_index}_sid_type_idx ON {search_index}(sid, type)");
      $ret[] = update_sql("CREATE INDEX {search_index}_fromsid_fromtype_idx ON {search_index}(fromsid, fromtype)");
      $ret[] = update_sql("CREATE INDEX {search_index}_word_idx ON {search_index}(word)");

      $ret[] = update_sql("CREATE TABLE {search_total} (
        word varchar(50) NOT NULL default '',
        count float default NULL,
        PRIMARY KEY(word))");
      break;
    default:
      break;
  }
  return $ret;
}

function system_update_151() {
  $ret = array();

  $ts = variable_get('theme_settings', NULL);

  // set up data array so we can loop over both sets of links
  $menus = array(0 => array('links_var' => 'primary_links',
                            'toggle_var' => 'toggle_primary_links',
                            'more_var' => 'primary_links_more',
                            'menu_name' => 'Primary links',
                            'menu_var' => 'menu_primary_menu',
                            'pid' => 0),
                 1 => array('links_var' => 'secondary_links',
                            'toggle_var' => 'toggle_secondary_links',
                            'more_var' => 'secondary_links_more',
                            'menu_name' => 'Secondary links',
                            'menu_var' => 'menu_secondary_menu',
                            'pid' => 0));

  for ($loop = 0; $loop <= 1 ; $loop ++) {
    // create new Primary and Secondary links menus
    $menus[$loop]['pid'] = db_next_id('{menu}_mid');
    $ret[] = update_sql("INSERT INTO {menu} (mid, pid, path, title, description, weight, type) " .
                         "VALUES ({$menus[$loop]['pid']}, 0, '', '{$menus[$loop]['menu_name']}', '', 0, 115)");

    // Gather links from various settings into a single array.
    $phptemplate_links = variable_get("phptemplate_". $menus[$loop]['links_var'], array());
    if (empty($phptemplate_links)) {
      $phptemplate_links = array('text' => array(), 'link' => array());
    }
    if (isset($ts) && is_array($ts)) {
      if (is_array($ts[$menus[$loop]['links_var']])) {
        $theme_links = $ts[$menus[$loop]['links_var']];
      }
      else {
        // Convert old xtemplate style links.
        preg_match_all('/<a\s+.*?href=[\"\'\s]?(.*?)[\"\'\s]?>(.*?)<\/a>/i', $ts[$menus[$loop]['links_var']], $urls);
        $theme_links['text'] = $urls[2];
        $theme_links['link'] = $urls[1];
      }
    }
    else {
      $theme_links = array('text' => array(), 'link' => array());
    }
    $links['text'] = array_merge($phptemplate_links['text'], $theme_links['text']);
    $links['link'] = array_merge($phptemplate_links['link'], $theme_links['link']);

    // insert all entries from theme links into new menus
    $num_inserted = 0;
    for ($i = 0; $i < count($links['text']); $i++) {
      if ($links['text'][$i] != "" && $links['link'][$i] != "") {
        $num_inserted ++;
        $node_unalias = db_fetch_array(db_query("SELECT src FROM {url_alias} WHERE dst = '%s'", $links['link'][$i]));
        if (isset($node_unalias) && is_array($node_unalias)) {
          $href = $node_unalias['src'];
        }
        else {
          $href = $links['link'][$i];
        }

        $mid = db_next_id('{menu}_mid');
        $ret[] = update_sql("INSERT INTO {menu} (mid, pid, path, title, description, weight, type) " .
                             "VALUES ($mid, {$menus[$loop]['pid']}, '" . db_escape_string($href) .
                             "', '" . db_escape_string($links['text'][$i]) .
                             "', '" . db_escape_string($links['description'][$i]) . "', 0, 118)");
      }
    }
    // delete Secondary links if not populated.
    if ($loop == 1 && $num_inserted == 0) {
      db_query("DELETE FROM {menu} WHERE mid={$menus[$loop]['pid']}");
    }

    // Set menu_primary_menu and menu_primary_menu variables if links were
    // imported. If the user had links but the toggle display was off, they
    // will need to disable the new links manually in admins/settings/menu.
    if ($num_inserted == 0) {
      variable_set($menus[$loop]['menu_var'], 0);
    }
    else {
      variable_set($menus[$loop]['menu_var'], $menus[$loop]['pid']);
    }
    variable_del('phptemplate_'. $menus[$loop]['links_var']);
    variable_del('phptemplate_'. $menus[$loop]['links_var'] .'_more');
    variable_del($menus[$loop]['toggle_var']);
    variable_del($menus[$loop]['more_var']);
    // If user has old xtemplate links in a string, leave them in the var.
    if (isset($ts) && is_array($ts) && is_array($ts[$menus[$loop]['links_var']])) {
      variable_del($menus[$loop]['links_var']);
    }
  }

  if (isset($ts) && is_array($ts)) {
    variable_set('theme_settings', $ts);
  }

  $ret[] = update_sql("UPDATE {system} SET status = 1 WHERE name = 'menu'");

  return $ret;
}

function system_update_152() {
  $ret = array();

  // Postgresql only update
  switch ($GLOBALS['db_type']) {
    case 'pgsql':
      $ret[] = update_sql("ALTER TABLE {forum} DROP shadow");
      break;
    case 'mysql':
    case 'mysqli':
      break;
  }

  return $ret;
}

function system_update_153() {
  $ret = array();
  switch ($GLOBALS['db_type']) {
    case 'pgsql':
      $ret[] = update_sql("ALTER TABLE {contact} DROP CONSTRAINT {contact}_pkey");
      $ret[] = update_sql("CREATE SEQUENCE {contact}_cid_seq");
      db_add_column($ret, 'contact', 'cid', 'int', array('not null' => TRUE, 'default' => "nextval('{contact}_cid_seq')"));
      $ret[] = update_sql("ALTER TABLE {contact} ADD PRIMARY KEY (cid)");
      $ret[] = update_sql("ALTER TABLE {contact} ADD CONSTRAINT {contact}_category_key UNIQUE (category)");
      break;
    case 'mysql':
    case 'mysqli':
      $ret[] = update_sql("ALTER TABLE {contact} DROP PRIMARY KEY");
      $ret[] = update_sql("ALTER TABLE {contact} ADD COLUMN cid int NOT NULL PRIMARY KEY auto_increment");
      $ret[] = update_sql("ALTER TABLE {contact} ADD UNIQUE KEY category (category)");
      break;
  }
  return $ret;
}

function system_update_154() {
  $ret = array();
  switch ($GLOBALS['db_type']) {
    case 'pgsql':
      db_add_column($ret, 'contact', 'weight', 'smallint', array('not null' => TRUE, 'default' => 0));
      db_add_column($ret, 'contact', 'selected', 'smallint', array('not null' => TRUE, 'default' => 0));
      break;
    case 'mysql':
    case 'mysqli':
      $ret[] = update_sql("ALTER TABLE {contact} ADD COLUMN weight tinyint NOT NULL DEFAULT 0");
      $ret[] = update_sql("ALTER TABLE {contact} ADD COLUMN selected tinyint NOT NULL DEFAULT 0");
      break;
  }
  return $ret;
}

function system_update_155() {
  $ret = array();

  // Postgresql only update
  switch ($GLOBALS['db_type']) {
    case 'pgsql':
      $ret[] = update_sql("DROP TABLE {cache}");
      $ret[] = update_sql("CREATE TABLE {cache} (
        cid varchar(255) NOT NULL default '',
        data bytea default '',
        expire integer NOT NULL default '0',
        created integer NOT NULL default '0',
        headers text default '',
        PRIMARY KEY (cid)
        )");
      $ret[] = update_sql("CREATE INDEX {cache}_expire_idx ON {cache}(expire)");
      break;
    case 'mysql':
    case 'mysqli':
      break;
  }

  return $ret;
}

function system_update_156() {
  $ret = array();
  $ret[] = update_sql("DELETE FROM {cache}");
  system_themes();
  return $ret;
}

function system_update_157() {
  $ret = array();
  $ret[] = update_sql("DELETE FROM {url_alias} WHERE src = 'node/feed' AND dst = 'rss.xml'");
  $ret[] = update_sql("INSERT INTO {url_alias} (src, dst) VALUES ('rss.xml', 'node/feed')");
  return $ret;
}

function system_update_158() {
  $ret = array();

  switch ($GLOBALS['db_type']) {
    case 'mysqli':
    case 'mysql':
      $ret[] = update_sql("ALTER TABLE {old_revisions} ADD done tinyint NOT NULL DEFAULT 0");
      $ret[] = update_sql("ALTER TABLE {old_revisions} ADD INDEX (done)");
      break;

    case 'pgsql':
      db_add_column($ret, 'old_revisions', 'done', 'smallint', array('not null' => TRUE, 'default' => 0));
      $ret[] = update_sql('CREATE INDEX {old_revisions}_done_idx ON {old_revisions}(done)');
      break;
  }

  return $ret;
}

/**
 * Retrieve data out of the old_revisions table and put into new revision
 * system.
 *
 * The old_revisions table is not deleted because any data which could not be
 * put into the new system is retained.
 */
function system_update_159() {
  $ret = array();

  $result = db_query_range("SELECT * FROM {old_revisions} WHERE done = 0 AND type IN ('page', 'story', 'poll', 'book', 'forum', 'blog') ORDER BY nid DESC", 0, 20);
  $num_rows = db_result(db_query_range("SELECT COUNT(*) FROM {old_revisions} WHERE done = 0 AND type IN ('page', 'story', 'poll', 'book', 'forum', 'blog') ORDER BY nid DESC", 0, 20));

  if ($num_rows) {
    $vid = db_next_id('{node_revisions}_vid');
    while ($node = db_fetch_object($result)) {
      $revisions = unserialize($node->revisions);
      if (isset($revisions) && is_array($revisions) && count($revisions) > 0) {
        $revisions_query = array();
        $revisions_args = array();
        $book_query = array();
        $book_args = array();
        $forum_query = array();
        $forum_args = array();
        foreach ($revisions as $version) {
          $revision = array();
          foreach ($version['node'] as $node_field => $node_value) {
            $revision[$node_field] = $node_value;
          }
          $revision['uid'] = $version['uid'];
          $revision['timestamp'] = $version['timestamp'];
          $vid++;
          $revisions_query[] = "(%d, %d, %d, '%s', '%s', '%s', '%s', %d, %d)";
          $revisions_args = array_merge($revisions_args, array($node->nid, $vid, $revision['uid'], $revision['title'], $revision['body'], $revision['teaser'], $revision['log'], $revision['timestamp'], $revision['format']));
          switch ($node->type) {
            case 'forum':
              if ($revision['tid'] > 0) {
                $forum_query[] = "(%d, %d, %d)";
                $forum_args = array_merge($forum_args, array($vid, $node->nid, $revision['tid']));
              }
              break;

            case 'book':
              $book_query[] = "(%d, %d, %d, %d)";
              $book_args = array_merge($book_args, array($vid, $node->nid, $revision['parent'], $revision['weight']));
              break;
          }
        }
        if (count($revisions_query)) {
          $revision_status = db_query("INSERT INTO {node_revisions} (nid, vid, uid, title, body, teaser, log, timestamp, format) VALUES ". implode(',', $revisions_query), $revisions_args);
        }
        if (count($forum_query)) {
          $forum_status = db_query("INSERT INTO {forum} (vid, nid, tid) VALUES ". implode(',', $forum_query), $forum_args);
        }
        if (count($book_query)) {
          $book_status = db_query("INSERT INTO {book} (vid, nid, parent, weight) VALUES ". implode(',', $book_query), $book_args);
        }
        $delete = FALSE;
        switch ($node->type) {
          case 'forum':
            if ($forum_status && $revision_status) {
              $delete = TRUE;
            }
            break;

          case 'book':
            if ($book_status && $revision_status) {
              $delete = TRUE;
            }
            break;

          default:
            if ($revision_status) {
              $delete = TRUE;
            }
            break;
        }

        if ($delete) {
          db_query('DELETE FROM {old_revisions} WHERE nid = %d', $node->nid);
        }
        else {
          db_query('UPDATE {old_revisions} SET done = 1 WHERE nid = %d', $node->nid);
        }

        switch ($GLOBALS['db_type']) {
          case 'mysqli':
          case 'mysql':
            $ret[] = update_sql("UPDATE {sequences} SET id = $vid WHERE name = '{node_revisions}_vid'");
            break;

          case 'pgsql':
            $ret[] = update_sql("SELECT setval('{node_revisions}_vid_seq', $vid)");
            break;
        }
      }
      else {
        db_query('UPDATE {old_revisions} SET done = 1 WHERE nid = %d', $node->nid);
        watchdog('php', "Recovering old revisions for node %nid failed.", array('%nid' => $node->nid), WATCHDOG_WARNING);
      }
    }
  }

  if ($num_rows < 20) {
    $ret[] = update_sql('ALTER TABLE {old_revisions} DROP done');
  }
  else {
    $ret['#finished'] = FALSE;
  }

  return $ret;
}

function system_update_160() {
  $types = module_invoke('node', 'get_types');
  if (is_array($types)) {
    foreach ($types as $type) {
      if (!is_array(variable_get("node_options_$type", array()))) {
        variable_set("node_options_$type", array());
      }
    }
  }
  return array();
}

function system_update_161() {
  variable_del('forum_icon_path');
  return array();
}

function system_update_162() {
  $ret = array();

  // PostgreSQL only update
  switch ($GLOBALS['db_type']) {
    case 'pgsql':

      $ret[] = update_sql('DROP INDEX {book}_parent');
      $ret[] = update_sql('CREATE INDEX {book}_parent_idx ON {book}(parent)');

      $ret[] = update_sql('DROP INDEX {node_comment_statistics}_timestamp_idx');
      $ret[] = update_sql('CREATE INDEX {node_comment_statistics}_last_comment_timestamp_idx ON {node_comment_statistics}(last_comment_timestamp)');

      $ret[] = update_sql('ALTER TABLE {filters} ALTER delta SET DEFAULT 0');
      $ret[] = update_sql('DROP INDEX {filters}_module_idx');

      $ret[] = update_sql('DROP INDEX {locales_target}_lid_idx');
      $ret[] = update_sql('DROP INDEX {locales_target}_lang_idx');
      $ret[] = update_sql('CREATE INDEX {locales_target}_locale_idx ON {locales_target}(locale)');

      $ret[] = update_sql('DROP INDEX {node}_created');
      $ret[] = update_sql('CREATE INDEX {node}_created_idx ON {node}(created)');
      $ret[] = update_sql('DROP INDEX {node}_changed');
      $ret[] = update_sql('CREATE INDEX {node}_changed_idx ON {node}(changed)');

      $ret[] = update_sql('DROP INDEX {profile_fields}_category');
      $ret[] = update_sql('CREATE INDEX {profile_fields}_category_idx ON {profile_fields}(category)');

      $ret[] = update_sql('DROP INDEX {url_alias}_dst_idx');
      $ret[] = update_sql('CREATE UNIQUE INDEX {url_alias}_dst_idx ON {url_alias}(dst)');

      $ret[] = update_sql('CREATE INDEX {sessions}_uid_idx ON {sessions}(uid)');
      $ret[] = update_sql('CREATE INDEX {sessions}_timestamp_idx ON {sessions}(timestamp)');

      $ret[] = update_sql('ALTER TABLE {accesslog} DROP mask');

      db_change_column($ret, 'accesslog', 'path', 'path', 'text');
      db_change_column($ret, 'accesslog', 'url', 'url', 'text');
      db_change_column($ret, 'watchdog', 'link', 'link', 'text', array('not null' => TRUE, 'default' => "''"));
      db_change_column($ret, 'watchdog', 'location', 'location', 'text', array('not null' => TRUE, 'default' => "''"));
      db_change_column($ret, 'watchdog', 'referer', 'referer', 'text', array('not null' => TRUE, 'default' => "''"));

      break;
  }

  return $ret;
}

function system_update_163() {
  $ret = array();
  if ($GLOBALS['db_type'] == 'mysql' || $GLOBALS['db_type'] == 'mysqli') {
    $ret[] = update_sql('ALTER TABLE {cache} CHANGE data data LONGBLOB');
  }
  return $ret;
}

function system_update_164() {
  $ret = array();

  switch ($GLOBALS['db_type']) {
    case 'mysql':
    case 'mysqli':
      $ret[] = update_sql("CREATE TABLE {poll_votes} (
          nid int unsigned NOT NULL,
          uid int unsigned NOT NULL default 0,
          hostname varchar(128) NOT NULL default '',
          INDEX (nid),
          INDEX (uid),
          INDEX (hostname)
      )");
      break;

    case 'pgsql':
      $ret[] = update_sql("CREATE TABLE {poll_votes} (
          nid int NOT NULL,
          uid int NOT NULL default 0,
          hostname varchar(128) NOT NULL default ''
      )");
      $ret[] = update_sql('CREATE INDEX {poll_votes}_nid_idx ON {poll_votes} (nid)');
      $ret[] = update_sql('CREATE INDEX {poll_votes}_uid_idx ON {poll_votes} (uid)');
      $ret[] = update_sql('CREATE INDEX {poll_votes}_hostname_idx ON {poll_votes} (hostname)');
      break;
  }

  $result = db_query('SELECT nid, polled FROM {poll}');
  while ($poll = db_fetch_object($result)) {
    foreach (explode(' ', $poll->polled) as $polled) {
      if ($polled[0] == '_') {
        // $polled is a user id
        db_query('INSERT INTO {poll_votes} (nid, uid) VALUES (%d, %d)', $poll->nid, substr($polled, 1, -1));
      }
      else {
        // $polled is a host
        db_query("INSERT INTO {poll_votes} (nid, hostname) VALUES (%d, '%s')", $poll->nid, $polled);
      }
    }
  }

  $ret[] = update_sql('ALTER TABLE {poll} DROP polled');

  return $ret;
}

function system_update_165() {
  $cron_last = max(variable_get('drupal_cron_last', 0), variable_get('ping_cron_last', 0));
  variable_set('cron_last', $cron_last);
  variable_del('drupal_cron_last');
  variable_del('ping_cron_last');
  return array();
}

function system_update_166() {
  $ret = array();

  $ret[] = update_sql("DROP TABLE {directory}");
  switch ($GLOBALS['db_type']) {
    case 'mysqli':
    case 'mysql':
      $ret[] = update_sql("CREATE TABLE {client} (
        cid int unsigned NOT NULL auto_increment,
        link varchar(255) NOT NULL default '',
        name varchar(128) NOT NULL default '',
        mail varchar(128) NOT NULL default '',
        slogan longtext NOT NULL,
        mission longtext NOT NULL,
        users int NOT NULL default '0',
        nodes int NOT NULL default '0',
        version varchar(35) NOT NULL default'',
        created int NOT NULL default '0',
        changed int NOT NULL default '0',
        PRIMARY KEY (cid)
      )");
      $ret[] = update_sql("CREATE TABLE {client_system} (
        cid int NOT NULL default '0',
        name varchar(255) NOT NULL default '',
        type varchar(255) NOT NULL default '',
        PRIMARY KEY (cid,name)
      )");
      break;

    case 'pgsql':
      $ret[] = update_sql("CREATE TABLE {client} (
        cid SERIAL,
        link varchar(255) NOT NULL default '',
        name varchar(128) NOT NULL default '',
        mail varchar(128) NOT NULL default '',
        slogan text NOT NULL default '',
        mission text NOT NULL default '',
        users integer NOT NULL default '0',
        nodes integer NOT NULL default '0',
        version varchar(35) NOT NULL default'',
        created integer NOT NULL default '0',
        changed integer NOT NULL default '0',
        PRIMARY KEY (cid)
      )");
      $ret[] = update_sql("CREATE TABLE {client_system} (
        cid integer NOT NULL,
        name varchar(255) NOT NULL default '',
        type varchar(255) NOT NULL default '',
        PRIMARY KEY (cid,name)
      )");
      break;
  }

  return $ret;
}

function system_update_167() {
  $ret = array();

  switch ($GLOBALS['db_type']) {
    case 'mysqli':
    case 'mysql':
      $ret[] = update_sql("ALTER TABLE {vocabulary_node_types} CHANGE type type varchar(32) NOT NULL default ''");
      break;
    case 'pgsql':
      db_change_column($ret, 'vocabulary_node_types', 'type', 'type', 'varchar(32)', array('not null' => TRUE, 'default' => "''"));
      $ret[] = update_sql("ALTER TABLE {vocabulary_node_types} ADD PRIMARY KEY (vid, type)");
      break;
  }

  return $ret;
}

function system_update_168() {
  $ret = array();

  $ret[] = update_sql("ALTER TABLE {term_hierarchy} ADD PRIMARY KEY (tid, parent)");

  return $ret;
}

function system_update_169() {
  // Warn PGSQL admins if their database is set up incorrectly
  if ($GLOBALS['db_type'] == 'pgsql') {
    $encoding = db_result(db_query('SHOW server_encoding'));
    if (!in_array(strtolower($encoding), array('unicode', 'utf8'))) {
      $msg = 'Your PostgreSQL database is set up with the wrong character encoding ('. $encoding .'). It is possible it will not work as expected. It is advised to recreate it with UTF-8/Unicode encoding. More information can be found in the <a href="http://www.postgresql.org/docs/7.4/interactive/multibyte.html">PostgreSQL documentation</a>.';
      watchdog('php', $msg, array(), WATCHDOG_WARNING);
      drupal_set_message($msg, 'status');
    }
  }

  // Note: 'access' table manually updated in update.php
  return _system_update_utf8(array(
    'accesslog', 'aggregator_category',
    'aggregator_category_feed', 'aggregator_category_item',
    'aggregator_feed', 'aggregator_item', 'authmap', 'blocks',
    'book', 'boxes', 'cache', 'comments', 'contact',
    'node_comment_statistics', 'client', 'client_system', 'files',
    'filter_formats', 'filters', 'flood', 'forum', 'history',
    'locales_meta', 'locales_source', 'locales_target', 'menu',
    'node', 'node_access', 'node_revisions', 'profile_fields',
    'profile_values', 'url_alias', 'permission', 'poll', 'poll_votes',
    'poll_choices', 'role', 'search_dataset', 'search_index',
    'search_total', 'sessions', 'sequences', 'node_counter',
    'system', 'term_data', 'term_hierarchy', 'term_node',
    'term_relation', 'term_synonym', 'users', 'users_roles', 'variable',
    'vocabulary', 'vocabulary_node_types', 'watchdog'
  ));
}

function system_update_170() {
  if (!variable_get('update_170_done', FALSE)) {
    switch ($GLOBALS['db_type']) {
      case 'pgsql':
        $ret = array();
        db_change_column($ret, 'system', 'schema_version', 'schema_version', 'smallint', array('not null' => TRUE, 'default' => -1));
        break;

      case 'mysql':
      case 'mysqli':
        db_query('ALTER TABLE {system} CHANGE schema_version schema_version smallint not null default -1');
        break;
    }
    // Set schema version -1 (uninstalled) for disabled modules (only affects contrib).
    db_query('UPDATE {system} SET schema_version = -1 WHERE status = 0 AND schema_version = 0');
  }
  return array();
}

function system_update_171() {
  $ret = array();
  $ret[] = update_sql('DELETE FROM {users_roles} WHERE rid IN ('. DRUPAL_ANONYMOUS_RID .', '. DRUPAL_AUTHENTICATED_RID .')');
  return $ret;
}

function system_update_172() {
  // Multi-part update
  if (!isset($_SESSION['system_update_172'])) {
    $_SESSION['system_update_172'] = 0;
    $_SESSION['system_update_172_max'] = db_result(db_query('SELECT MAX(cid) FROM {comments}'));
  }

  include_once './'. drupal_get_path('module', 'comment') .'/comment.module';

  $limit = 20;
  $result = db_query_range("SELECT cid, thread FROM {comments} WHERE cid > %d ORDER BY cid ASC", $_SESSION['system_update_172'], 0, $limit);
  while ($comment = db_fetch_object($result)) {
    $_SESSION['system_update_172'] = $comment->cid;
    $thread = explode('.', rtrim($comment->thread, '/'));
    foreach ($thread as $i => $offset) {
      // Decode old-style comment codes: 1,2,...,9,90,91,92,...,99,990,991,...
      $thread[$i] = int2vancode((strlen($offset) - 1) * 10 + substr($offset, -1, 1));
    }
    $thread = implode('.', $thread) .'/';
    db_query("UPDATE {comments} SET thread = '%s' WHERE cid = %d", $thread, $comment->cid);
  }

  if ($_SESSION['system_update_172'] == $_SESSION['system_update_172_max']) {
    unset($_SESSION['system_update_172']);
    unset($_SESSION['system_update_172_max']);
    return array();
  }
  return array('#finished' => $_SESSION['system_update_172'] / $_SESSION['system_update_172_max']);
}

function system_update_173() {
  $ret = array();
  // State tracker to determine whether we keep a backup of the files table or not.
  $safe = TRUE;

  // PostgreSQL needs CREATE TABLE foobar _AS_ SELECT ...
  $AS = ($GLOBALS['db_type'] == 'pgsql') ? 'AS' : '';

  // Backup the files table.
  $ret[] = update_sql("CREATE TABLE {files_backup} $AS SELECT * FROM {files}");

  // Do some files table sanity checking and cleanup.
  $ret[] = update_sql('DELETE FROM {files} WHERE fid = 0');
  $ret[] = update_sql('UPDATE {files} SET vid = nid WHERE vid = 0');

  // Create a temporary table to build the new file_revisions and files tables from.
  $ret[] = update_sql("CREATE TABLE {files_tmp} $AS SELECT * FROM {files}");
  $ret[] = update_sql('DROP TABLE {files}');

  switch ($GLOBALS['db_type']) {
    case 'pgsql':
      // create file_revisions table
      $ret[] = update_sql("CREATE TABLE {file_revisions} (
        fid integer NOT NULL default 0,
        vid integer NOT NULL default 0,
        description varchar(255) NOT NULL default '',
        list smallint NOT NULL default 0,
        PRIMARY KEY (fid, vid))");
      $result = update_sql("INSERT INTO {file_revisions} SELECT DISTINCT ON (fid,vid) fid, vid, description, list FROM {files_tmp}");
      $ret[] = $result;
      if ($result['success'] === FALSE) {
        $safe = FALSE;
      }

      // Create normalized files table
      $ret[] = update_sql("CREATE TABLE {files} (
        fid SERIAL,
        nid integer NOT NULL default 0,
        filename varchar(255) NOT NULL default '',
        filepath varchar(255) NOT NULL default '',
        filemime varchar(255) NOT NULL default '',
        filesize integer NOT NULL default 0,
        PRIMARY KEY (fid))");
      $result = update_sql("INSERT INTO {files} SELECT DISTINCT ON (fid) fid, nid, filename, filepath, filemime, filesize FROM {files_tmp}");
      $ret[] = $result;
      if ($result['success'] === FALSE) {
        $safe = FALSE;
      }

      $ret[] = update_sql("SELECT setval('{files}_fid_seq', max(fid)) FROM {files}");

      break;

    case 'mysqli':
    case 'mysql':
      // create file_revisions table
      $ret[] = update_sql("CREATE TABLE {file_revisions} (
        fid int unsigned NOT NULL default 0,
        vid int unsigned NOT NULL default 0,
        description varchar(255) NOT NULL default '',
        list tinyint unsigned NOT NULL default 0,
        PRIMARY KEY (fid, vid)
        ) /*!40100 DEFAULT CHARACTER SET utf8 */");

      // Try as you might mysql only does distinct row if you are selecting more than 1 column.
      $result = update_sql('INSERT INTO {file_revisions} SELECT DISTINCT fid , vid, description, list FROM {files_tmp}');
      $ret[] = $result;
      if ($result['success'] === FALSE) {
        $safe = FALSE;
      }

      $ret[] = update_sql("CREATE TABLE {files} (
        fid int unsigned NOT NULL default 0,
        nid int unsigned NOT NULL default 0,
        filename varchar(255) NOT NULL default '',
        filepath varchar(255) NOT NULL default '',
        filemime varchar(255) NOT NULL default '',
        filesize int unsigned NOT NULL default 0,
        PRIMARY KEY (fid)
        ) /*!40100 DEFAULT CHARACTER SET utf8 */");
      $result = update_sql("INSERT INTO {files} SELECT DISTINCT fid, nid, filename, filepath, filemime, filesize FROM {files_tmp}");
      $ret[] = $result;
      if ($result['success'] === FALSE) {
        $safe = FALSE;
      }

      break;
  }

  $ret[] = update_sql("DROP TABLE {files_tmp}");

  // Remove original files table if all went well. Otherwise preserve it and notify user.
  if ($safe) {
    $ret[] = update_sql("DROP TABLE {files_backup}");
  }
  else {
    drupal_set_message('Normalizing files table failed. A backup of the original table called {files_backup} remains in your database.');
  }

  return $ret;
}

function system_update_174() {
  // This update (update comments system variables on upgrade) has been removed.
  return array();
}

function system_update_175() {
  $result = db_query('SELECT * FROM {url_alias}');
  while ($path = db_fetch_object($result)) {
    $path->src = urldecode($path->src);
    $path->dst = urldecode($path->dst);
    db_query("UPDATE {url_alias} SET dst = '%s', src = '%s' WHERE pid = %d", $path->dst, $path->src, $path->pid);
  }
  return array();
}

function system_update_176() {
  $ret = array();
  $ret[] = update_sql('ALTER TABLE {filter_formats} ADD UNIQUE (name)');
  return $ret;
}

function system_update_177() {
  $ret = array();
  $message_ids = array(
    'welcome_subject' => 'Welcome subject',
    'welcome_body' => 'Welcome body text',
    'approval_subject' => 'Approval subject',
    'approval_body' => 'Approval body text',
    'pass_subject' => 'Password reset subject',
    'pass_body' => 'Password reset body text',
  );
  foreach ($message_ids as $message_id => $message_text) {
    if ($admin_setting = variable_get('user_mail_'. $message_id, FALSE)) {
      // Insert newlines and escape for display as HTML
      $admin_setting = nl2br(check_plain($message_text ."\n\n". $admin_setting));
      watchdog('legacy', $admin_setting);
      $last = db_fetch_object(db_query('SELECT max(wid) AS wid FROM {watchdog}'));
      // Deleting is required, because _user_mail_text() checks for the existance of the variable.
      variable_del('user_mail_'. $message_id);
      $ret[] = array(
        'query' => strtr('The mail template %message_id has been reset to the default. The old template <a href="@url">has been saved</a>.', array('%message_id' => 'user_mail_'. $message_id, '@url' => url('admin/logs/event/'. $last->wid))),
        'success' => TRUE
      );
    }
  }
  return $ret;
}

function _update_178_url_fix($text) {
  // Key is the attribute to replace.
  $urlpatterns['href'] = "/<a[^>]+href=\"([^\"]+)/i";
  $urlpatterns['src']  = "/<img[^>]+src=\"([^\"]+)/i";

  $old = $text;
  foreach ($urlpatterns as $type => $pattern) {
    if (preg_match_all($pattern, $text, $matches)) {
      foreach ($matches[1] as $url) {
        if ($url != '' && !strstr($url, 'mailto:') && !strstr($url, '://') && !strstr($url, '../') && !strstr($url, './') && $url[0] != '/' && $url[0] != '#') {
          $text = preg_replace('|'. $type .'\s*=\s*"'. preg_quote($url) .'\s*"|', $type .'="'. base_path() . $url .'"', $text);
        }
      }
    }
  }
  return $text != $old ? $text : FALSE;
}

function _update_178_url_formats() {
  $formats = array();

  // Any format with the HTML filter in it
  $result = db_query("SELECT format FROM {filters} WHERE module = 'filter' AND delta = 0");
  while ($format = db_fetch_object($result)) {
    $formats[$format->format] = TRUE;
  }

  // Any format with only the linebreak filter in it
  $result = db_query("SELECT format FROM {filters} WHERE module = 'filter' AND delta = 2");
  while ($format = db_fetch_object($result)) {
    if (db_result(db_query('SELECT COUNT(*) FROM {filters} WHERE format = %d', $format->format)) == 1) {
      $formats[$format->format] = TRUE;
    }
  }

  // Any format with 'HTML' in its name
  $result = db_query("SELECT format FROM {filter_formats} WHERE name LIKE '%HTML%'");
  while ($format = db_fetch_object($result)) {
    $formats[$format->format] = TRUE;
  }

  return $formats;
}

/**
 * Update base paths for relative URLs in node and comment content.
 */
function system_update_178() {

  if (variable_get('clean_url', 0) == 1) {
    // Multi-part update
    if (!isset($_SESSION['system_update_178_comment'])) {
      // Check which formats need to be converted
      $formats = _update_178_url_formats();
      if (count($formats) == 0) {
        return array();
      }

      // Build format query string
      $_SESSION['formats'] = array_keys($formats);
      $_SESSION['format_string'] = '('. substr(str_repeat('%d, ', count($formats)), 0, -2) .')';

      // Begin update
      $_SESSION['system_update_178_comment'] = 0;
      $_SESSION['system_update_178_node'] = 0;
      $_SESSION['system_update_178_comment_max'] = db_result(db_query('SELECT MAX(cid) FROM {comments} WHERE format IN '. $_SESSION['format_string'], $_SESSION['formats']));
      $_SESSION['system_update_178_node_max'] = db_result(db_query('SELECT MAX(vid) FROM {node_revisions} WHERE format IN '. $_SESSION['format_string'], $_SESSION['formats']));
    }

    $limit = 20;

    // Comments
    if ($_SESSION['system_update_178_comment'] != $_SESSION['system_update_178_comment_max']) {
      $args = array_merge(array($_SESSION['system_update_178_comment']), $_SESSION['formats']);
      $result = db_query_range("SELECT cid, comment FROM {comments} WHERE cid > %d AND format IN ". $_SESSION['format_string'] .' ORDER BY cid ASC', $args, 0, $limit);
      while ($comment = db_fetch_object($result)) {
        $_SESSION['system_update_178_comment'] = $comment->cid;
        $comment->comment = _update_178_url_fix($comment->comment);
        if ($comment->comment !== FALSE) {
          db_query("UPDATE {comments} SET comment = '%s' WHERE cid = %d", $comment->comment, $comment->cid);
        }
      }
    }

    // Node revisions
    $args = array_merge(array($_SESSION['system_update_178_node']), $_SESSION['formats']);
    $result = db_query_range("SELECT vid, teaser, body FROM {node_revisions} WHERE vid > %d AND format IN ". $_SESSION['format_string'] .' ORDER BY vid ASC', $args, 0, $limit);
    while ($node = db_fetch_object($result)) {
      $_SESSION['system_update_178_node'] = $node->vid;
      $set = array();
      $args = array();

      $node->teaser = _update_178_url_fix($node->teaser);
      if ($node->teaser !== FALSE) {
        $set[] = "teaser = '%s'";
        $args[] = $node->teaser;
      }

      $node->body = _update_178_url_fix($node->body);
      if ($node->body !== FALSE) {
        $set[] = "body = '%s'";
        $args[] = $node->body;
      }

      if (count($set)) {
        $args[] = $node->vid;
        db_query('UPDATE {node_revisions} SET '. implode(', ', $set) .' WHERE vid = %d', $args);
      }

    }

    if ($_SESSION['system_update_178_comment'] == $_SESSION['system_update_178_comment_max'] &&
        $_SESSION['system_update_178_node'] == $_SESSION['system_update_178_node_max']) {
      unset($_SESSION['system_update_178_comment']);
      unset($_SESSION['system_update_178_comment_max']);
      unset($_SESSION['system_update_178_node']);
      unset($_SESSION['system_update_178_node_max']);
      return array();
    }
    else {
      // Report percentage finished
      return array('#finished' =>
        ($_SESSION['system_update_178_comment'] + $_SESSION['system_update_178_node']) /
        ($_SESSION['system_update_178_comment_max'] + $_SESSION['system_update_178_node_max'])
      );
    }
  }

  return array();
}

/**
 * Update base paths for relative URLs in custom blocks, profiles and various variables.
 */
function system_update_179() {

  if (variable_get('clean_url', 0) == 1) {
    // Multi-part update
    if (!isset($_SESSION['system_update_179_uid'])) {
      // Check which formats need to be converted
      $formats = _update_178_url_formats();
      if (count($formats) == 0) {
        return array();
      }

      // Custom Blocks (too small for multipart)
      $format_string = '('. substr(str_repeat('%d, ', count($formats)), 0, -2) .')';
      $result = db_query("SELECT bid, body FROM {boxes} WHERE format IN ". $format_string, array_keys($formats));
      while ($block = db_fetch_object($result)) {
        $block->body = _update_178_url_fix($block->body);
        if ($block->body !== FALSE) {
          db_query("UPDATE {boxes} SET body = '%s' WHERE bid = %d", $block->body, $block->bid);
        }
      }

      // Variables (too small for multipart)
      $vars = array('site_mission', 'site_footer', 'user_registration_help');
      foreach (node_get_types() as $type => $name) {
        $vars[] = $type .'_help';
      }
      foreach ($vars as $var) {
        $value = variable_get($var, NULL);
        if (!is_null($value)) {
          $value = _update_178_url_fix($value);
          if ($value !== FALSE) {
            variable_set($var, $value);
          }
        }
      }

      // See if profiles need to be updated: is the default format HTML?
      if (!isset($formats[variable_get('filter_default_format', 1)])) {
        return array();
      }
      $result = db_query("SELECT fid FROM {profile_fields} WHERE type = 'textarea'");
      $fields = array();
      while ($field = db_fetch_object($result)) {
        $fields[] = $field->fid;
      }
      if (count($fields) == 0) {
        return array();
      }

      // Begin multi-part update for profiles
      $_SESSION['system_update_179_fields'] = $fields;
      $_SESSION['system_update_179_field_string'] = '('. substr(str_repeat('%d, ', count($fields)), 0, -2) .')';
      $_SESSION['system_update_179_uid'] = 0;
      $_SESSION['system_update_179_fid'] = 0;
      $_SESSION['system_update_179_max'] = db_result(db_query('SELECT MAX(uid) FROM {profile_values} WHERE fid IN '. $_SESSION['system_update_179_field_string'], $_SESSION['system_update_179_fields']));
    }

    // Fetch next 20 profile values to convert
    $limit = 20;
    $args = array_merge(array($_SESSION['system_update_179_uid'], $_SESSION['system_update_179_fid'], $_SESSION['system_update_179_uid']), $_SESSION['system_update_179_fields']);
    $result = db_query_range("SELECT fid, uid, value FROM {profile_values} WHERE ((uid = %d AND fid > %d) OR uid > %d) AND fid IN ". $_SESSION['system_update_179_field_string'] .' ORDER BY uid ASC, fid ASC', $args, 0, $limit);

    $has_rows = FALSE;
    while ($field = db_fetch_object($result)) {
      $_SESSION['system_update_179_uid'] = $field->uid;
      $_SESSION['system_update_179_fid'] = $field->fid;
      $field->value = _update_178_url_fix($field->value);
      if ($field->value !== FALSE) {
        db_query("UPDATE {profile_values} SET value = '%s' WHERE uid = %d AND fid = %d", $field->value, $field->uid, $field->fid);
      }
      $has_rows = TRUE;
    }

    // Done?
    if (!$has_rows) {
      unset($_SESSION['system_update_179_uid']);
      unset($_SESSION['system_update_179_fid']);
      unset($_SESSION['system_update_179_max']);
      return array();
    }
    else {
      // Report percentage finished
      // (Note: make sure we complete all fields for the last user by not reporting 100% too early)
      return array('#finished' => $_SESSION['system_update_179_uid'] / ($_SESSION['system_update_179_max'] + 1));
    }
  }

  return array();
}

function system_update_180() {
  $ret = array();

  switch ($GLOBALS['db_type']) {
    case 'mysql':
    case 'mysqli':
      $ret[] = update_sql("ALTER TABLE {node} DROP PRIMARY KEY");
      $ret[] = update_sql("ALTER TABLE {node} ADD PRIMARY KEY (nid, vid)");
      $ret[] = update_sql("ALTER TABLE {node} DROP INDEX vid");
      $ret[] = update_sql("ALTER TABLE {node} ADD UNIQUE (vid)");
      $ret[] = update_sql("ALTER TABLE {node} ADD INDEX (nid)");

      $ret[] = update_sql("ALTER TABLE {node_counter} CHANGE nid nid int NOT NULL DEFAULT '0'");
      break;
    case 'pgsql':
      $ret[] = update_sql("ALTER TABLE {node} DROP CONSTRAINT {node}_pkey"); // Change PK
      $ret[] = update_sql("ALTER TABLE {node} ADD PRIMARY KEY (nid, vid)");
      $ret[] = update_sql('DROP INDEX {node}_vid_idx'); // Change normal index to UNIQUE index
      $ret[] = update_sql('CREATE UNIQUE INDEX {node}_vid_idx ON {node}(vid)');
      $ret[] = update_sql('CREATE INDEX {node}_nid_idx ON {node}(nid)'); // Add index on nid
      break;
  }

  return $ret;
}

function system_update_181() {
  $ret = array();
  switch ($GLOBALS['db_type']) {
    case 'mysql':
    case 'mysqli':
      $ret[] = update_sql("ALTER TABLE {profile_fields} ADD autocomplete TINYint NOT NULL AFTER visibility ;");
      break;
    case 'pgsql':
      db_add_column($ret, 'profile_fields', 'autocomplete', 'smallint', array('not null' => TRUE, 'default' => 0));
      break;
  }
  return $ret;
}

/**
 * The lid field in pgSQL should not be UNIQUE, but an INDEX.
 */
function system_update_182() {
  $ret = array();

  if ($GLOBALS['db_type'] == 'pgsql') {
    $ret[] = update_sql('ALTER TABLE {locales_target} DROP CONSTRAINT {locales_target}_lid_key');
    $ret[] = update_sql('CREATE INDEX {locales_target}_lid_idx ON {locales_target} (lid)');
  }

  return $ret;
}

/**
 * @defgroup updates-4.7-to-5.0 System updates from 4.7 to 5.0
 * @{
 */

function system_update_1000() {
  $ret = array();
  switch ($GLOBALS['db_type']) {
    case 'mysql':
    case 'mysqli':
    $ret[] = update_sql("CREATE TABLE {blocks_roles} (
      module varchar(64) NOT NULL,
      delta varchar(32) NOT NULL,
      rid int unsigned NOT NULL,
      PRIMARY KEY (module, delta, rid)
      ) /*!40100 DEFAULT CHARACTER SET utf8 */;");
    break;

    case 'pgsql':
    $ret[] = update_sql("CREATE TABLE {blocks_roles} (
      module varchar(64) NOT NULL,
      delta varchar(32) NOT NULL,
      rid integer NOT NULL,
      PRIMARY KEY (module, delta, rid)
      );");
    break;

  }
  return $ret;
}

function system_update_1001() {
  // change DB schema for better poll support
  $ret = array();

  switch ($GLOBALS['db_type']) {
    case 'mysqli':
    case 'mysql':
      // alter poll_votes table
      $ret[] = update_sql("ALTER TABLE {poll_votes} ADD COLUMN chorder int NOT NULL default -1 AFTER uid");
      break;

    case 'pgsql':
      db_add_column($ret, 'poll_votes', 'chorder', 'int', array('not null' => TRUE, 'default' => "'-1'"));
      break;
  }

  return $ret;
}

function system_update_1002() {
  // Make the forum's vocabulary the highest in list, if present
  $ret = array();

  if ($vid = (int) variable_get('forum_nav_vocabulary', 0)) {
    $ret[] = update_sql('UPDATE {vocabulary} SET weight = -10 WHERE vid = '. $vid);
  }

  return $ret;
}

function system_update_1003() {
  // Make use of guid in feed items
  $ret = array();
  switch ($GLOBALS['db_type']) {
    case 'mysql':
    case 'mysqli':
      $ret[] = update_sql("ALTER TABLE {aggregator_item} ADD guid varchar(255) AFTER timestamp ;");
      break;
    case 'pgsql':
      db_add_column($ret, 'aggregator_item', 'guid', 'varchar(255)');
      break;
  }
  return $ret;
}


function system_update_1004() {
  // Increase the size of bid in boxes and aid in access
  $ret = array();
  switch ($GLOBALS['db_type']) {
    case 'mysql':
    case 'mysqli':
    $ret[] = update_sql("ALTER TABLE {access} CHANGE `aid` `aid` int  NOT NULL AUTO_INCREMENT ");
    $ret[] = update_sql("ALTER TABLE {boxes} CHANGE `bid` `bid` int NOT NULL AUTO_INCREMENT ");
      break;
    case 'pgsql':
      // No database update required for PostgreSQL because it already uses big SERIAL numbers.
      break;
  }
  return $ret;
}

function system_update_1005() {
  // Add ability to create dynamic node types like the CCK module
  $ret = array();

  // The node_type table may already exist for anyone who ever used CCK in 4.7,
  // even if CCK is no longer installed. We need to make sure any previously
  // created table gets renamed before we create the new node_type table in
  // order to ensure that the new table gets created without errors.
  // TODO: This check should be removed for Drupal 6.
  if (db_table_exists('node_type')) {
    switch ($GLOBALS['db_type']) {
      case 'mysql':
      case 'mysqli':
        $ret[] = update_sql('RENAME TABLE {node_type} TO {node_type_content}');
        break;

      case 'pgsql':
        $ret[] = update_sql('ALTER TABLE {node_type} RENAME TO {node_type_content}');
        break;
    }
  }

  switch ($GLOBALS['db_type']) {
    case 'mysqli':
    case 'mysql':
      // Create node_type table
      $ret[] = update_sql("CREATE TABLE {node_type} (
        type varchar(32) NOT NULL,
        name varchar(255) NOT NULL,
        module varchar(255) NOT NULL,
        description mediumtext NOT NULL,
        help mediumtext NOT NULL,
        has_title tinyint unsigned NOT NULL,
        title_label varchar(255) NOT NULL default '',
        has_body tinyint unsigned NOT NULL,
        body_label varchar(255) NOT NULL default '',
        min_word_count smallint unsigned NOT NULL,
        custom tinyint NOT NULL DEFAULT '0',
        modified tinyint NOT NULL DEFAULT '0',
        locked tinyint NOT NULL DEFAULT '0',
        orig_type varchar(255) NOT NULL default '',
        PRIMARY KEY (type)
        ) /*!40100 DEFAULT CHARACTER SET utf8 */;");
      break;

    case 'pgsql':
      // add new unsigned types for pgsql
      $ret[] = update_sql("CREATE DOMAIN int_unsigned integer CHECK (VALUE >= 0)");
      $ret[] = update_sql("CREATE DOMAIN smallint_unsigned smallint CHECK (VALUE >= 0)");
      $ret[] = update_sql("CREATE DOMAIN bigint_unsigned bigint CHECK (VALUE >= 0)");

      $ret[] = update_sql("CREATE TABLE {node_type} (
        type varchar(32) NOT NULL,
        name varchar(255) NOT NULL,
        module varchar(255) NOT NULL,
        description text NOT NULL,
        help text NOT NULL,
        has_title smallint_unsigned NOT NULL,
        title_label varchar(255) NOT NULL default '',
        has_body smallint_unsigned NOT NULL,
        body_label varchar(255) NOT NULL default '',
        min_word_count smallint_unsigned NOT NULL,
        custom smallint NOT NULL DEFAULT '0',
        modified smallint NOT NULL DEFAULT '0',
        locked smallint NOT NULL DEFAULT '0',
        orig_type varchar(255) NOT NULL default '',
        PRIMARY KEY (type)
        );");
      break;
  }

  // Insert default user-defined node types into the database.
  $types = array(
    array(
      'type' => 'page',
      'name' => t('Page'),
      'module' => 'node',
      'description' => t('If you want to add a static page, like a contact page or an about page, use a page.'),
      'custom' => TRUE,
      'modified' => TRUE,
      'locked' => FALSE,
    ),
    array(
      'type' => 'story',
      'name' => t('Story'),
      'module' => 'node',
      'description' => t('Stories are articles in their simplest form: they have a title, a teaser and a body, but can be extended by other modules. The teaser is part of the body too. Stories may be used as a personal blog or for news articles.'),
      'custom' => TRUE,
      'modified' => TRUE,
      'locked' => FALSE,
    )
  );

  foreach ($types as $type) {
    $type = (object) _node_type_set_defaults($type);
    node_type_save($type);
  }

  cache_clear_all();
  system_modules();
  menu_rebuild();
  node_types_rebuild();

  // Migrate old values for 'minimum_x_size' variables to the node_type table.
  $query = db_query('SELECT type FROM {node_type}');
  while ($result = db_fetch_object($query)) {
    $variable_name = 'minimum_'. $result->type .'_size';
    if ($value = db_fetch_object(db_query("SELECT value FROM {variable} WHERE name = '%s'", $variable_name))) {
      $value = (int) unserialize($value->value);
      db_query("UPDATE {node_type} SET min_word_count = %d, modified = %d WHERE type = '%s'", $value, 1, $result->type);
      variable_del($variable_name);
    }
  }

  node_types_rebuild();

  return $ret;
}

function system_update_1006() {
  // Add a customizable title to all blocks.
  $ret = array();
  switch ($GLOBALS['db_type']) {
    case 'mysql':
    case 'mysqli':
    $ret[] = update_sql("ALTER TABLE {blocks} ADD title VARCHAR(64) NOT NULL DEFAULT ''");
      break;
    case 'pgsql':
      db_add_column($ret, 'blocks', 'title', 'varchar(64)', array('default' => "''", 'not null' => TRUE));
      break;
  }
  // Migrate custom block titles to new column.
  $boxes = db_query('SELECT bid, title from {boxes}');
  while ($box = db_fetch_object($boxes)) {
    db_query("UPDATE {blocks} SET title = '%s' WHERE delta = %d and module = 'block'", $box->title, $box->bid);
  }
  switch ($GLOBALS['db_type']) {
    case 'mysql':
    case 'mysqli':
      $ret[] = update_sql('ALTER TABLE {boxes} DROP title');
      break;
    case 'pgsql':
      $ret[] = update_sql('ALTER TABLE {boxes} DROP COLUMN title');
      break;
  }
  return $ret;
}

function system_update_1007() {
  $ret = array();
  switch ($GLOBALS['db_type']) {
    case 'mysql':
    case 'mysqli':
      $ret[] = update_sql("ALTER TABLE {aggregator_item} ADD INDEX (fid)");
      break;
    case 'pgsql':
      $ret[] = update_sql("CREATE INDEX {aggregator_item}_fid_idx ON {aggregator_item} (fid)");
      break;
  }
  return $ret;
}

/**
 * Performance update for queries that are related to the locale.module
 */
function system_update_1008() {
  $ret = array();
  switch ($GLOBALS['db_type']) {
    case 'mysql':
    case 'mysqli':
      $ret[] = update_sql('ALTER TABLE {locales_source} ADD KEY source (source(30))');
      break;
    case 'pgsql':
      $ret[] = update_sql("CREATE INDEX {locales_source}_source_idx on {locales_source} (source)");
  }

  return $ret;
}

function system_update_1010() {
  $ret = array();

  // Disable urlfilter.module, if it exists.
  if (module_exists('urlfilter')) {
    module_disable(array('urlfilter'));
    $ret[] = update_sql("UPDATE {filter_formats} SET module = 'filter', delta = 3 WHERE module = 'urlfilter'");
    $ret[] = t('URL Filter module was disabled; this functionality has now been added to core.');
  }

  return $ret;
}

function system_update_1011() {
  $ret = array();
  $ret[] = update_sql('UPDATE {menu} SET mid = 2 WHERE mid = 0');
  cache_clear_all();
  return $ret;
}

function system_update_1012() {
  $ret = array();
  switch ($GLOBALS['db_type']) {
    case 'mysql':
    case 'mysqli':
      $ret[] = update_sql("ALTER TABLE {file_revisions} ADD INDEX(vid)");
      $ret[] = update_sql("ALTER TABLE {files} ADD INDEX(nid)");
      break;
    case 'pgsql':
      $ret[] = update_sql('CREATE INDEX {file_revisions}_vid_idx ON {file_revisions} (vid)');
      $ret[] = update_sql('CREATE INDEX {files}_nid_idx ON {files} (nid)');
      break;
  }
  return $ret;
}

function system_update_1013() {
  $ret = array();
  switch ($GLOBALS['db_type']) {
    case 'mysql':
    case 'mysqli':
      $ret[] = update_sql("ALTER TABLE {sessions} CHANGE COLUMN sid sid varchar(64) NOT NULL default ''");
      break;
    case 'pgsql':
      db_change_column($ret, 'sessions', 'sid', 'sid', 'varchar(64)',  array('not null' => TRUE, 'default' => "''"));
      break;
  }
  return $ret;
}

function system_update_1014() {
  variable_del('cron_busy');
  return array();
}

/**
 * Add an index on watchdog type.
 */
function system_update_1015() {
  $ret = array();
  switch ($GLOBALS['db_type']) {
    case 'mysql':
    case 'mysqli':
      $ret[] = update_sql('ALTER TABLE {watchdog} ADD INDEX (type)');
      break;
    case 'pgsql':
      $ret[] = update_sql('CREATE INDEX {watchdog}_type_idx ON {watchdog}(type)');
      break;
  }
  return $ret;
}

/**
 * Allow for longer URL encoded (%NN) UTF-8 characters in the location field of watchdog table.
 */
function system_update_1016() {
  $ret = array();
  switch ($GLOBALS['db_type']) {
    case 'mysql':
    case 'mysqli':
      $ret[] = update_sql("ALTER TABLE {watchdog} CHANGE COLUMN location location text NOT NULL");
      break;
    case 'pgsql':
      db_change_column($ret, 'watchdog', 'location', 'location', 'text',  array('not null' => TRUE, 'default' => "''"));
      break;
  }
  return $ret;
}

/**
 * Allow role names to be up to 64 characters.
 */
function system_update_1017() {
  $ret = array();
  switch ($GLOBALS['db_type']) {
    case 'pgsql':
      db_change_column($ret, 'role', 'name', 'name', 'varchar(64)', array('not null' => TRUE, 'default' => "''"));
      break;
    case 'mysql':
    case 'mysqli':
      $ret[] = update_sql("ALTER TABLE {role} CHANGE name name varchar(64) NOT NULL default ''");
      break;
  }
  return $ret;
}

/**
 * Change break tag (was removed, see 1020).
 */
function system_update_1018() {
  variable_set('update_1020_ok', TRUE);
  return array();
}

/**
 * Change variable format for user-defined e-mails.
 */
function system_update_1019() {
  $message_ids = array('welcome_subject', 'welcome_body',
                       'approval_subject', 'approval_body',
                       'pass_subject', 'pass_body',
  );
  foreach ($message_ids as $id) {
    // Replace all %vars with !vars
    if ($message = variable_get('user_mail_'. $id, NULL)) {
      $fixed = preg_replace('/%([A-Za-z_-]+)/', '!\1', $message);
      variable_set('user_mail_'. $id, $fixed);
    }
  }
  return array();
}

/**
 * Change break tag back (was removed from head).
 */
function system_update_1020() {
  $ret = array();
  if (!variable_get('update_1020_ok', FALSE)) {
    $ret[] = update_sql("UPDATE {node_revisions} SET body = REPLACE(body, '<break>', '<!--break-->')");
  }
  variable_del('update_1020_ok');
  return $ret;
}

/**
 * Update two more variables that were missing from system_update_1019.
 */
function system_update_1021() {
  $message_ids = array('admin_body', 'admin_subject');
  foreach ($message_ids as $id) {
    // Replace all %vars with !vars
    if ($message = variable_get('user_mail_'. $id, NULL)) {
      $fixed = preg_replace('/%([A-Za-z_-]+)/', '!\1', $message);
      variable_set('user_mail_'. $id, $fixed);
    }
  }
  return array();
}

/**
 * @} End of "defgroup updates-4.7-to-5.0"
 */


/**
 * @defgroup updates-5.x-extra Extra system updates for 5.x
 * @{
 */

/**
 * Add index on users created column.
 */
function system_update_1022() {
  $ret = array();
  switch ($GLOBALS['db_type']) {
    case 'mysql':
    case 'mysqli':
      $ret[] = update_sql('ALTER TABLE {users} ADD KEY created (created)');
      break;

    case 'pgsql':
      $ret[] = update_sql("CREATE INDEX {users}_created_idx ON {users} (created)");
      break;
  }
  // Also appears as system_update_6004(). Ensure we don't update twice.
  variable_set('system_update_1022', TRUE);
  return $ret;
}

/**
 * @} End of "defgroup updates-5.x-extra"
 */

/**
 * @defgroup updates-5.x-to-6.x System updates from 5.x to 6.x
 * @{
 */

/**
 * Remove auto_increment from {boxes} to allow adding custom blocks with
 * visibility settings.
 */
function system_update_6000() {
  $ret = array();
  switch ($GLOBALS['db_type']) {
    case 'mysql':
    case 'mysqli':
      $max = (int)db_result(db_query('SELECT MAX(bid) FROM {boxes}'));
      $ret[] = update_sql('ALTER TABLE {boxes} CHANGE COLUMN bid bid int NOT NULL');
      $ret[] = update_sql("REPLACE INTO {sequences} VALUES ('{boxes}_bid', $max)");
      break;
  }
  return $ret;
}

/**
 * Add version id column to {term_node} to allow taxonomy module to use revisions.
 */
function system_update_6001() {
  $ret = array();

  // Add vid to term-node relation.  The schema says it is unsigned.
  db_add_field($ret, 'term_node', 'vid', array('type' => 'int', 'unsigned' => TRUE, 'not null' => TRUE, 'default' => 0));
  db_drop_primary_key($ret, 'term_node');
  db_add_primary_key($ret, 'term_node', array('vid', 'tid', 'nid'));
  db_add_index($ret, 'term_node', 'vid', array('vid'));

  // Update all entries with the current revision number.
  $nodes = db_query('SELECT nid, vid FROM {node}');
  while ($node = db_fetch_object($nodes)) {
    db_query('UPDATE {term_node} SET vid = %d WHERE nid = %d', $node->vid, $node->nid);
  }
  return $ret;
}

/**
 * Increase the maximum length of variable names from 48 to 128.
 */
function system_update_6002() {
  $ret = array();
  db_drop_primary_key($ret, 'variable');
  db_change_field($ret, 'variable', 'name', 'name', array('type' => 'varchar', 'length' => 128, 'not null' => TRUE, 'default' => ''));
  db_add_primary_key($ret, 'variable', array('name'));
  return $ret;
}

/**
 * Add index on comments status column.
 */
function system_update_6003() {
  $ret = array();
  switch ($GLOBALS['db_type']) {
    case 'mysql':
    case 'mysqli':
      $ret[] = update_sql('ALTER TABLE {comments} ADD KEY status (status)');
      break;

    case 'pgsql':
      $ret[] = update_sql("CREATE INDEX {comments}_status_idx ON {comments} (status)");
      break;
  }
  return $ret;
}

/**
 * This update used to add an index on users created column (#127941).
 * However, system_update_1022() does the same thing.  This update
 * tried to detect if 1022 had already run but failed to do so,
 * resulting in an "index already exists" error.
 *
 * Adding the index here is never necessary.  Sites installed before
 * 1022 will run 1022, getting the update.  Sites installed on/after 1022
 * got the index when the table was first created.  Therefore, this
 * function is now a no-op.
 */
function system_update_6004() {
  return array();
}

/**
 * Add language to url_alias table and modify indexes.
 */
function system_update_6005() {
  $ret = array();
  switch ($GLOBALS['db_type']) {
    case 'pgsql':
      db_add_column($ret, 'url_alias', 'language', 'varchar(12)', array('default' => "''", 'not null' => TRUE));

      // As of system.install:1.85 (before the new language
      // subsystem), new installs got a unique key named
      // url_alias_dst_key on url_alias.dst.  Unfortunately,
      // system_update_162 created a unique key inconsistently named
      // url_alias_dst_idx on url_alias.dst (keys should have the _key
      // suffix, indexes the _idx suffix).  Therefore, sites installed
      // before system_update_162 have a unique key with a different
      // name than sites installed after system_update_162().  Now, we
      // want to drop the unique key on dst which may have either one
      // of two names and create a new unique key on (dst, language).
      // There is no way to know which key name exists so we have to
      // drop both, causing an SQL error.  Thus, we just hide the
      // error and only report the update_sql results that work.
      $err = error_reporting(0);
      $ret1 = update_sql('DROP INDEX {url_alias}_dst_idx');
      if ($ret1['success']) {
  $ret[] = $ret1;
      }
      $ret1 = array();
      db_drop_unique_key($ret, 'url_alias', 'dst');
      foreach ($ret1 as $r) {
  if ($r['success']) {
    $ret[] = $r;
  }
      }
      error_reporting($err);

      $ret[] = update_sql('CREATE UNIQUE INDEX {url_alias}_dst_language_idx ON {url_alias}(dst, language)');
      break;
    case 'mysql':
    case 'mysqli':
      $ret[] = update_sql("ALTER TABLE {url_alias} ADD language varchar(12) NOT NULL default ''");
      $ret[] = update_sql("ALTER TABLE {url_alias} DROP INDEX dst");
      $ret[] = update_sql("ALTER TABLE {url_alias} ADD UNIQUE dst_language (dst, language)");
      break;
  }
  return $ret;
}

/**
 * Drop useless indices on node_counter table.
 */
function system_update_6006() {
  $ret = array();
  switch ($GLOBALS['db_type']) {
    case 'pgsql':
      $ret[] = update_sql('DROP INDEX {node_counter}_daycount_idx');
      $ret[] = update_sql('DROP INDEX {node_counter}_totalcount_idx');
      $ret[] = update_sql('DROP INDEX {node_counter}_timestamp_idx');
      break;
    case 'mysql':
    case 'mysqli':
      $ret[] = update_sql("ALTER TABLE {node_counter} DROP INDEX daycount");
      $ret[] = update_sql("ALTER TABLE {node_counter} DROP INDEX totalcount");
      $ret[] = update_sql("ALTER TABLE {node_counter} DROP INDEX timestamp");
      break;
  }
  return $ret;
}

/**
 * Change the severity column in the watchdog table to the new values.
 */
function system_update_6007() {
  $ret = array();
  $ret[] = update_sql("UPDATE {watchdog} SET severity = ". WATCHDOG_NOTICE ." WHERE severity = 0");
  $ret[] = update_sql("UPDATE {watchdog} SET severity = ". WATCHDOG_WARNING ." WHERE severity = 1");
  $ret[] = update_sql("UPDATE {watchdog} SET severity = ". WATCHDOG_ERROR ." WHERE severity = 2");
  return $ret;
}

/**
 * Add info files to themes.  The info and owner columns are added by
 * update_fix_d6_requirements() in update.php to avoid a large number
 * of error messages from update.php.  All we need to do here is copy
 * description to owner and then drop description.
 */
function system_update_6008() {
  $ret = array();
  $ret[] = update_sql('UPDATE {system} SET owner = description');
  db_drop_field($ret, 'system', 'description');

  // Rebuild system table contents.
  module_rebuild_cache();
  system_theme_data();

  return $ret;
}

/**
 * The PHP filter is now a separate module.
 */
function system_update_6009() {
  $ret = array();

  // Delete existing PHP filter and input format.
  $ret[] = update_sql("DELETE FROM {filter_formats} WHERE format = 2");
  $ret[] = update_sql("DELETE FROM {filters} WHERE format = 2");

  // Enable the PHP filter module.
  $ret[] = update_sql("UPDATE {system} SET status = 1 WHERE name = 'php' AND type = 'module'");

  // Add the PHP Code input format.
  $ret[] = update_sql("INSERT INTO {filter_formats} (name, roles, cache) VALUES ('PHP code', '', 0)");
  $format = db_result(db_query("SELECT MAX(format) FROM {filter_formats}"));

  // Enable the PHP evaluator filter.
  db_query("INSERT INTO {filters} (format, module, delta, weight) VALUES (%d, 'php', 0, 0)", $format);

  // If any other input formats use the PHP evaluator, update them accordingly.
  $ret[] = update_sql("UPDATE {filters} SET delta = 0, module = 'php' WHERE module = 'filter' AND delta = 1");

  // With the removal of the PHP evaluator filter, the deltas of the line break
  // and URL filter have changed.
  $ret[] = update_sql("UPDATE {filters} SET delta = 1 WHERE module = 'filter' AND delta = 2");
  $ret[] = update_sql("UPDATE {filters} SET delta = 2 WHERE module = 'filter' AND delta = 3");

  // Update any nodes associated with the PHP input format.
  db_query("UPDATE {node_revisions} SET format = %d WHERE format = 2", $format);

  return $ret;
}

/**
 * Add variable replacement for watchdog messages.
 *
 * The variables field is NOT NULL and does not have a default value.
 * Existing log messages should not be translated in the new system,
 * so we insert 'N;' (serialize(NULL)) as the temporary default but
 * then remove the default value to match the schema.
 */
function system_update_6010() {
  $ret = array();
  db_add_field($ret, 'watchdog', 'variables', array('type' => 'text', 'size' => 'big', 'not null' => TRUE, 'initial' => 'N;'));
  return $ret;
}

/**
 * Add language support to nodes
 */
function system_update_6011() {
  $ret = array();
  switch ($GLOBALS['db_type']) {
    case 'pgsql':
      db_add_column($ret, 'node', 'language', 'varchar(12)', array('default' => "''", 'not null' => TRUE));
      break;
    case 'mysql':
    case 'mysqli':
      $ret[] = update_sql("ALTER TABLE {node} ADD language varchar(12) NOT NULL default ''");
      break;
  }
  return $ret;
}

/**
 * Add serialized field to cache tables.  This is now handled directly
 * by update.php, so this function is a no-op.
 */
function system_update_6012() {
  return array();
}

/**
 * Rebuild cache data for theme system changes
 */
function system_update_6013() {
  // Rebuild system table contents.
  module_rebuild_cache();
  system_theme_data();

  return array();
}

/**
 * Record that the installer is done, so it is not
 * possible to run the installer on upgraded sites.
 */
function system_update_6014() {
  variable_set('install_task', 'done');

  return array();
}

/**
 * Add the form cache table.
 */
function system_update_6015() {
  $ret = array();

  switch ($GLOBALS['db_type']) {
    case 'pgsql':
      $ret[] = update_sql("CREATE TABLE {cache_form} (
        cid varchar(255) NOT NULL default '',
        data bytea,
        expire int NOT NULL default '0',
        created int NOT NULL default '0',
        headers text,
        serialized smallint NOT NULL default '0',
        PRIMARY KEY (cid)
    )");
      $ret[] = update_sql("CREATE INDEX {cache_form}_expire_idx ON {cache_form} (expire)");
      break;
    case 'mysql':
    case 'mysqli':
      $ret[] = update_sql("CREATE TABLE {cache_form} (
        cid varchar(255) NOT NULL default '',
        data longblob,
        expire int NOT NULL default '0',
        created int NOT NULL default '0',
        headers text,
        serialized int(1) NOT NULL default '0',
        PRIMARY KEY (cid),
        INDEX expire (expire)
      ) /*!40100 DEFAULT CHARACTER SET UTF8 */ ");
      break;
  }

  return $ret;
}

/**
 * Make {node}'s primary key be nid, change nid,vid to a unique key.
 * Add primary keys to block, filters, flood, permission, and term_relation.
 */
function system_update_6016() {
  $ret = array();

  switch ($GLOBALS['db_type']) {
    case 'pgsql':
      $ret[] = update_sql("ALTER TABLE {node} ADD CONSTRAINT {node}_nid_vid_key UNIQUE (nid, vid)");
      db_add_column($ret, 'blocks', 'bid', 'serial');
      $ret[] = update_sql("ALTER TABLE {blocks} ADD PRIMARY KEY (bid)");
      db_add_column($ret, 'filters', 'fid', 'serial');
      $ret[] = update_sql("ALTER TABLE {filters} ADD PRIMARY KEY (fid)");
      db_add_column($ret, 'flood', 'fid', 'serial');
      $ret[] = update_sql("ALTER TABLE {flood} ADD PRIMARY KEY (fid)");
      db_add_column($ret, 'permission', 'pid', 'serial');
      $ret[] = update_sql("ALTER TABLE {permission} ADD PRIMARY KEY (pid)");
      db_add_column($ret, 'term_relation', 'trid', 'serial');
      $ret[] = update_sql("ALTER TABLE {term_relation} ADD PRIMARY KEY (trid)");
      db_add_column($ret, 'term_synonym', 'tsid', 'serial');
      $ret[] = update_sql("ALTER TABLE {term_synonym} ADD PRIMARY KEY (tsid)");
      break;
    case 'mysql':
    case 'mysqli':
      $ret[] = update_sql('ALTER TABLE {node} ADD UNIQUE KEY nid_vid (nid, vid)');
      $ret[] = update_sql("ALTER TABLE {blocks} ADD bid int NOT NULL AUTO_INCREMENT PRIMARY KEY");
      $ret[] = update_sql("ALTER TABLE {filters} ADD fid int NOT NULL AUTO_INCREMENT PRIMARY KEY");
      $ret[] = update_sql("ALTER TABLE {flood} ADD fid int NOT NULL AUTO_INCREMENT PRIMARY KEY");
      $ret[] = update_sql("ALTER TABLE {permission} ADD pid int NOT NULL AUTO_INCREMENT PRIMARY KEY");
      $ret[] = update_sql("ALTER TABLE {term_relation} ADD trid int NOT NULL AUTO_INCREMENT PRIMARY KEY");
      $ret[] = update_sql("ALTER TABLE {term_synonym} ADD tsid int NOT NULL AUTO_INCREMENT PRIMARY KEY");
      break;
  }

  return $ret;
}

/**
 * Rename settings related to user.module email notifications.
 */
function system_update_6017() {
  $ret = array();
  // Maps old names to new ones.
  $var_names = array(
    'admin'    => 'register_admin_created',
    'approval' => 'register_pending_approval',
    'welcome'  => 'register_no_approval_required',
    'pass'     => 'password_reset',
  );
  foreach ($var_names as $old => $new) {
    foreach (array('_subject', '_body') as $suffix) {
      $old_name = 'user_mail_'. $old . $suffix;
      $new_name = 'user_mail_'. $new . $suffix;
      if ($old_val = variable_get($old_name, FALSE)) {
        variable_set($new_name, $old_val);
        variable_del($old_name);
        $ret[] = array('success' => TRUE, 'query' => "variable_set($new_name)");
        $ret[] = array('success' => TRUE, 'query' => "variable_del($old_name)");
        if ($old_name == 'user_mail_approval_body') {
          drupal_set_message(t('Saving an old value of the welcome message body for users that are pending administrator approval. However, you should consider modifying this text, since Drupal can now be configured to automatically notify users and send them their login information when their accounts are approved.  See the !admin_user_settings page for details.', array('!admin_user_settings' => l(t('User settings'), 'admin/user/settings'))));
        }
      }
    }
  }
  return $ret;
}

/**
 * Add HTML corrector to HTML formats or replace the old module if it was in use.
 */
function system_update_6018() {
  $ret = array();

  // Disable htmlcorrector.module, if it exists and replace its filter.
  if (module_exists('htmlcorrector')) {
    module_disable(array('htmlcorrector'));
    $ret[] = update_sql("UPDATE {filter_formats} SET module = 'filter', delta = 3 WHERE module = 'htmlcorrector'");
    $ret[] = t('HTML Corrector module was disabled; this functionality has now been added to core.');
    return $ret;
  }

  // Otherwise, find any format with 'HTML' in its name and add the filter at the end.
  $result = db_query("SELECT format FROM {filter_formats} WHERE name LIKE '%HTML%'");
  while ($format = db_fetch_object($result)) {
    $weight = db_result(db_query("SELECT MAX(weight) FROM {filters} WHERE format = %d", $format->format));
    db_query("INSERT INTO {filters} (format, module, delta, weight) VALUES (%d, '%s', %d, %d)", $format->format, 'filter', 3, max(10, $weight + 1));
  }

  return $ret;
}

/**
 * Reconcile small differences in the previous, manually created mysql
 * and pgsql schemas so they are the same and can be represented by a
 * single schema structure.
 *
 * Note that the mysql and pgsql cases make different changes.  This
 * is because each schema needs to be tweaked in different ways to
 * conform to the new schema structure.  Also, since they operate on
 * tables defined by many optional core modules which may not ever
 * have been installed, they must test each table for existence.  If
 * the modules are first installed after this update exists the tables
 * will be created from the schema structure and will start out
 * correct.
 */
function system_update_6019() {
  $ret = array();

  switch ($GLOBALS['db_type']) {
    case 'pgsql':
      // Remove default ''.
      if (db_table_exists('aggregator_feed')) {
        db_field_set_no_default($ret, 'aggregator_feed', 'description');
        db_field_set_no_default($ret, 'aggregator_feed', 'image');
      }
      db_field_set_no_default($ret, 'blocks', 'pages');
      if (db_table_exists('contact')) {
        db_field_set_no_default($ret, 'contact', 'recipients');
        db_field_set_no_default($ret, 'contact', 'reply');
      }
      db_field_set_no_default($ret, 'watchdog', 'location');
      db_field_set_no_default($ret, 'node_revisions', 'body');
      db_field_set_no_default($ret, 'node_revisions', 'teaser');
      db_field_set_no_default($ret, 'node_revisions', 'log');

      // Update from pgsql 'float' (which means 'double precision') to
      // schema 'float' (which in pgsql means 'real').
      if (db_table_exists('search_index')) {
        db_change_field($ret, 'search_index', 'score', 'score', array('type' => 'float'));
      }
      if (db_table_exists('search_total')) {
        db_change_field($ret, 'search_total', 'count', 'count', array('type' => 'float'));
      }

      // Replace unique index dst_language with a unique constraint.  The
      // result is the same but the unique key fits our current schema
      // structure.  Also, the postgres documentation implies that
      // unique constraints are preferable to unique indexes.  See
      // http://www.postgresql.org/docs/8.2/interactive/indexes-unique.html.
      if (db_table_exists('url_alias')) {
        db_drop_index($ret, 'url_alias', 'dst_language');
        db_add_unique_key($ret, 'url_alias', 'dst_language',
          array('dst', 'language'));
      }

      // Fix term_node pkey: mysql and pgsql code had different orders.
      if (db_table_exists('term_node')) {
        db_drop_primary_key($ret, 'term_node');
        db_add_primary_key($ret, 'term_node', array('vid', 'tid', 'nid'));
      }

      // Make boxes.bid unsigned.
      db_drop_primary_key($ret, 'boxes');
      db_change_field($ret, 'boxes', 'bid', 'bid', array('type' => 'serial', 'unsigned' => TRUE, 'not null' => TRUE), array('primary key' => array('bid')));

      // Fix primary key
      db_drop_primary_key($ret, 'node');
      db_add_primary_key($ret, 'node', array('nid'));

      break;

    case 'mysql':
    case 'mysqli':
      // Rename key 'link' to 'url'.
      if (db_table_exists('aggregator_feed')) {
        db_drop_unique_key($ret, 'aggregator_feed', 'link');
        db_add_unique_key($ret, 'aggregator_feed', 'url', array('url'));
      }

      // Change to size => small.
      if (db_table_exists('boxes')) {
        db_change_field($ret, 'boxes', 'format', 'format', array('type' => 'int', 'size' => 'small', 'not null' => TRUE, 'default' => 0));
      }

      // Change to size => small.
      // Rename index 'lid' to 'nid'.
      if (db_table_exists('comments')) {
        db_change_field($ret, 'comments', 'format', 'format', array('type' => 'int', 'size' => 'small', 'not null' => TRUE, 'default' => 0));
        db_drop_index($ret, 'comments', 'lid');
        db_add_index($ret, 'comments', 'nid', array('nid'));
      }

      // Change to size => small.
      db_change_field($ret, 'cache', 'serialized', 'serialized', array('type' => 'int', 'size' => 'small', 'not null' => TRUE, 'default' => 0));
      db_change_field($ret, 'cache_filter', 'serialized', 'serialized', array('type' => 'int', 'size' => 'small', 'not null' => TRUE, 'default' => 0));
      db_change_field($ret, 'cache_page', 'serialized', 'serialized', array('type' => 'int', 'size' => 'small', 'not null' => TRUE, 'default' => 0));
      db_change_field($ret, 'cache_form', 'serialized', 'serialized', array('type' => 'int', 'size' => 'small', 'not null' => TRUE, 'default' => 0));

      // Remove default => 0, set auto increment.
      $new_uid = 1 + db_result(db_query('SELECT MAX(uid) FROM {users}'));
      $ret[] = update_sql('UPDATE {users} SET uid = '. $new_uid . ' WHERE uid = 0');
      db_drop_primary_key($ret, 'users');
      db_change_field($ret, 'users', 'uid', 'uid', array('type' => 'serial', 'unsigned' => TRUE, 'not null' => TRUE), array('primary key' => array('uid')));
      $ret[] = update_sql('UPDATE {users} SET uid = 0 WHERE uid = '. $new_uid);

      // Special field names.
      $map = array('node_revisions' => 'vid');
      // Make sure these tables have proper auto_increment fields.
      foreach (array('boxes', 'files', 'node', 'node_revisions') as $table) {
        $field = isset($map[$table]) ? $map[$table] : $table[0] .'id';
        db_drop_primary_key($ret, $table);
        db_change_field($ret, $table, $field, $field, array('type' => 'serial', 'unsigned' => TRUE, 'not null' => TRUE), array('primary key' => array($field)));
      }

      break;
  }

  return $ret;
}

/**
 * Create the tables for the new menu system.
 */
function system_update_6020() {
  $ret = array();

  $schema['menu_router'] = array(
    'fields' => array(
      'path'             => array('type' => 'varchar', 'length' => 255, 'not null' => TRUE, 'default' => ''),
      'load_functions'   => array('type' => 'varchar', 'length' => 255, 'not null' => TRUE, 'default' => ''),
      'to_arg_functions' => array('type' => 'varchar', 'length' => 255, 'not null' => TRUE, 'default' => ''),
      'access_callback'  => array('type' => 'varchar', 'length' => 255, 'not null' => TRUE, 'default' => ''),
      'access_arguments' => array('type' => 'text', 'not null' => FALSE),
      'page_callback'    => array('type' => 'varchar', 'length' => 255, 'not null' => TRUE, 'default' => ''),
      'page_arguments'   => array('type' => 'text', 'not null' => FALSE),
      'fit'              => array('type' => 'int', 'not null' => TRUE, 'default' => 0),
      'number_parts'     => array('type' => 'int', 'not null' => TRUE, 'default' => 0, 'size' => 'small'),
      'tab_parent'       => array('type' => 'varchar', 'length' => 255, 'not null' => TRUE, 'default' => ''),
      'tab_root'         => array('type' => 'varchar', 'length' => 255, 'not null' => TRUE, 'default' => ''),
      'title'            => array('type' => 'varchar', 'length' => 255, 'not null' => TRUE, 'default' => ''),
      'title_callback'   => array('type' => 'varchar', 'length' => 255, 'not null' => TRUE, 'default' => ''),
      'title_arguments'  => array('type' => 'varchar', 'length' => 255, 'not null' => TRUE, 'default' => ''),
      'type'             => array('type' => 'int', 'not null' => TRUE, 'default' => 0),
      'block_callback'   => array('type' => 'varchar', 'length' => 255, 'not null' => TRUE, 'default' => ''),
      'description'      => array('type' => 'text', 'not null' => TRUE),
      'position'         => array('type' => 'varchar', 'length' => 255, 'not null' => TRUE, 'default' => ''),
      'weight'           => array('type' => 'int', 'not null' => TRUE, 'default' => 0),
      'file'             => array('type' => 'text', 'size' => 'medium')
    ),
    'indexes' => array(
      'fit'        => array('fit'),
      'tab_parent' => array('tab_parent')
    ),
    'primary key' => array('path'),
  );

  $schema['menu_links'] = array(
    'fields' => array(
      'menu_name'    => array('type' => 'varchar', 'length' => 32, 'not null' => TRUE, 'default' => ''),
      'mlid'         => array('type' => 'serial', 'unsigned' => TRUE, 'not null' => TRUE),
      'plid'         => array('type' => 'int', 'unsigned' => TRUE, 'not null' => TRUE, 'default' => 0),
      'link_path'    => array('type' => 'varchar', 'length' => 255, 'not null' => TRUE, 'default' => ''),
      'router_path'  => array('type' => 'varchar', 'length' => 255, 'not null' => TRUE, 'default' => ''),
      'link_title'   => array('type' => 'varchar', 'length' => 255, 'not null' => TRUE, 'default' => ''),
      'options'      => array('type' => 'text', 'not null' => FALSE),
      'module'       => array('type' => 'varchar', 'length' => 255, 'not null' => TRUE, 'default' => 'system'),
      'hidden'       => array('type' => 'int', 'not null' => TRUE, 'default' => 0, 'size' => 'small'),
      'external'     => array('type' => 'int', 'not null' => TRUE, 'default' => 0, 'size' => 'small'),
      'has_children' => array('type' => 'int', 'not null' => TRUE, 'default' => 0, 'size' => 'small'),
      'expanded'     => array('type' => 'int', 'not null' => TRUE, 'default' => 0, 'size' => 'small'),
      'weight'       => array('type' => 'int', 'not null' => TRUE, 'default' => 0),
      'depth'        => array('type' => 'int', 'not null' => TRUE, 'default' => 0, 'size' => 'small'),
      'customized'   => array('type' => 'int', 'not null' => TRUE, 'default' => 0, 'size' => 'small'),
      'p1'           => array('type' => 'int', 'unsigned' => TRUE, 'not null' => TRUE, 'default' => 0),
      'p2'           => array('type' => 'int', 'unsigned' => TRUE, 'not null' => TRUE, 'default' => 0),
      'p3'           => array('type' => 'int', 'unsigned' => TRUE, 'not null' => TRUE, 'default' => 0),
      'p4'           => array('type' => 'int', 'unsigned' => TRUE, 'not null' => TRUE, 'default' => 0),
      'p5'           => array('type' => 'int', 'unsigned' => TRUE, 'not null' => TRUE, 'default' => 0),
      'p6'           => array('type' => 'int', 'unsigned' => TRUE, 'not null' => TRUE, 'default' => 0),
      'p7'           => array('type' => 'int', 'unsigned' => TRUE, 'not null' => TRUE, 'default' => 0),
      'p8'           => array('type' => 'int', 'unsigned' => TRUE, 'not null' => TRUE, 'default' => 0),
      'p9'           => array('type' => 'int', 'unsigned' => TRUE, 'not null' => TRUE, 'default' => 0),
      'updated'      => array('type' => 'int', 'not null' => TRUE, 'default' => 0, 'size' => 'small'),
    ),
    'indexes' => array(
      'path_menu'              => array(array('link_path', 128), 'menu_name'),
      'menu_plid_expand_child' => array('menu_name', 'plid', 'expanded', 'has_children'),
      'menu_parents'           => array('menu_name', 'p1', 'p2', 'p3', 'p4', 'p5', 'p6', 'p7', 'p8', 'p9'),
      'router_path'            => array(array('router_path', 128)),
    ),
    'primary key' => array('mlid'),
  );

  foreach ($schema as $name => $table) {
    db_create_table($ret, $name, $table);
  }
  return $ret;
}

/**
 * Migrate the menu items from the old menu system to the new menu_links table.
 */
function system_update_6021() {
  $ret = array('#finished' => 0);
  // Multi-part update
  if (!isset($_SESSION['system_update_6021'])) {
    db_add_field($ret, 'menu', 'converted', array('type' => 'int', 'unsigned' => TRUE, 'not null' => TRUE, 'default' => 0, 'size' => 'tiny'));
    $_SESSION['system_update_6021_max'] = db_result(db_query('SELECT COUNT(*) FROM {menu}'));
    $_SESSION['menu_menu_map'] = array(1 => 'navigation');
    // 0 => FALSE is for new menus, 1 => FALSE is for the navigation.
    $_SESSION['menu_item_map'] = array(0 => FALSE, 1 => FALSE);
    if ($secondary = variable_get('menu_secondary_menu', 0)) {
      $_SESSION['menu_menu_map'][$secondary] = 'secondary-links';
      $_SESSION['menu_item_map'][$secondary] = FALSE;
    }
    if ($primary = variable_get('menu_primary_menu', 0)) {
      $_SESSION['menu_menu_map'][$primary] = 'primary-links';
      $_SESSION['menu_item_map'][$primary] = FALSE;
      if ($primary == $secondary) {
        variable_set('menu_secondary_links_source', 'primary-links');
      }
    }
    $table = array(
      'fields' => array(
        'menu_name'   => array('type' => 'varchar', 'length' => 32, 'not null' => TRUE, 'default' => ''),
        'title'       => array('type' => 'varchar', 'length' => 255, 'not null' => TRUE, 'default' => ''),
        'description' => array('type' => 'text', 'not null' => FALSE),
      ),
      'primary key' => array('menu_name'),
    );
    db_create_table($ret, 'menu_custom', $table);
    $menus = array(
      'navigation' => array(
        'menu_name' => 'navigation',
        'title' => 'Navigation',
        'description' => 'The navigation menu is provided by Drupal and is the main interactive menu for any site. It is usually the only menu that contains personalized links for authenticated users, and is often not even visible to anonymous users.',
      ),
      'primary-links' => array(
        'menu_name' => 'primary-links',
        'title' => 'Primary links',
        'description' => 'Primary links are often used at the theme layer to show the major sections of a site. A typical representation for primary links would be tabs along the top.',
      ),
      'secondary-links' => array(
        'menu_name' => 'secondary-links',
        'title' => 'Secondary links',
        'description' => 'Secondary links are often used for pages like legal notices, contact details, and other secondary navigation items that play a lesser role than primary links',
      ),
    );
    // Save user-defined titles.
    foreach (array($primary, $secondary) as $mid) {
      if ($item = db_fetch_array(db_query('SELECT * FROM {menu} WHERE mid = %d', $mid))) {
        $menus[$_SESSION['menu_menu_map'][$mid]]['title']  = $item['title'];
      }
    }
    foreach ($menus as $menu) {
      db_query("INSERT INTO {menu_custom} (menu_name, title, description) VALUES ('%s', '%s', '%s')", $menu);
    }
    menu_rebuild();
    $_SESSION['system_update_6021'] = 0;
    // force page reload.
    return $ret;
  }

  $limit = 50;
  while ($limit-- && ($item = db_fetch_array(db_query_range('SELECT * FROM {menu} WHERE converted = 0', 0, 1)))) {
    // If it's not a menu...
    if ($item['pid']) {
      // Let's climb up until we find an item with a converted parent.
      $item_original = $item;
      while ($item && !isset($_SESSION['menu_item_map'][$item['pid']])) {
        $item = db_fetch_array(db_query('SELECT * FROM {menu} WHERE mid = %d', $item['pid']));
      }
      // This can only occur if the menu entry is a leftover in the menu table.
      // These do not appear in Drupal 5 anyways, so we skip them.
      if (!$item) {
        db_query('UPDATE {menu} SET converted = %d WHERE mid  = %d', 1, $item_original['mid']);
        $_SESSION['system_update_6021']++;
        continue;
      }
    }
    // We need to recheck because item might have changed.
    if ($item['pid']) {
      // Fill the new fields.
      $item['link_title'] = $item['title'];
      $item['link_path'] = drupal_get_normal_path($item['path']);
      // We know the parent is already set. If it's not FALSE then it's an item.
      if ($_SESSION['menu_item_map'][$item['pid']]) {
        // The new menu system parent link id.
        $item['plid'] = $_SESSION['menu_item_map'][$item['pid']]['mlid'];
        // The new menu system menu name.
        $item['menu_name'] = $_SESSION['menu_item_map'][$item['pid']]['menu_name'];
      }
      else {
        // This a top level element.
        $item['plid'] = 0;
        // The menu name is stored among the menus.
        $item['menu_name'] = $_SESSION['menu_menu_map'][$item['pid']];
      }
      // Is the element visible in the menu block?
      $item['hidden'] = !($item['type'] & MENU_VISIBLE_IN_TREE);
      // Is it a custom(ized) element?
      if ($item['type'] & (MENU_CREATED_BY_ADMIN | MENU_MODIFIED_BY_ADMIN)) {
        $item['customized'] = TRUE;
      }
      // Items created via the menu module need to be assigned to it.
      if ($item['type'] & MENU_CREATED_BY_ADMIN) {
        $item['module'] = 'menu';
      }
      else {
        $item['module'] = 'system';
      }
      $item['updated'] = TRUE;
      // Save the link.
      if ($existing_item = db_fetch_array(db_query("SELECT mlid, menu_name FROM {menu_links} WHERE link_path = '%s' AND plid = '%s' AND link_title = '%s' AND menu_name = '%s'", $item['link_path'], $item['plid'], $item['link_title'], $item['menu_name']))) {
        $_SESSION['menu_item_map'][$item['mid']] = $existing_item;
      }
      else {
        $item['router_path'] = '';
        menu_link_save($item);
        $_SESSION['menu_item_map'][$item['mid']] = array('mlid' => $item['mlid'], 'menu_name' => $item['menu_name']);
      }

    }
    elseif (!isset($_SESSION['menu_menu_map'][$item['mid']])) {
      $item['menu_name'] = 'menu-'. preg_replace('/[^a-zA-Z0-9]/', '-', strtolower($item['title']));
      $item['menu_name'] = substr($item['menu_name'], 0, 20);
      $original_menu_name = $item['menu_name'];
      $i = 0;
      while (db_result(db_query("SELECT menu_name FROM {menu_custom} WHERE menu_name = '%s'", $item['menu_name']))) {
        $item['menu_name'] = $original_menu_name . ($i++);
      }
      if ($item['path']) {
        // Another bunch of bogus entries. Apparently, these are leftovers
        // from Drupal 4.7 .
        $_SESSION['menu_bogus_menus'][] = $item['menu_name'];
      }
      else {
        // Add this menu to the list of custom menus.
        db_query("INSERT INTO {menu_custom} (menu_name, title, description) VALUES ('%s', '%s', '')", $item['menu_name'], $item['title']);
      }
      $_SESSION['menu_menu_map'][$item['mid']] = $item['menu_name'];
      $_SESSION['menu_item_map'][$item['mid']] = FALSE;
    }
    db_query('UPDATE {menu} SET converted = %d WHERE mid  = %d', 1, $item['mid']);
    $_SESSION['system_update_6021']++;
  }

  if ($_SESSION['system_update_6021'] >= $_SESSION['system_update_6021_max']) {
    $result = db_query('SELECT * FROM {menu_links} WHERE updated = 1 AND has_children = 0 AND customized = 0 ORDER BY depth DESC');
    // Remove all items that are not customized.
    while ($item = db_fetch_array($result)) {
      _menu_delete_item($item, TRUE);
    }
    if (!empty($_SESSION['menu_bogus_menus'])) {
      // Remove entries in bogus menus. This is secure because we deleted
      // every non-alpanumeric character from the menu name.
      $ret[] = update_sql("DELETE FROM {menu_links} WHERE menu_name IN ('". implode("', '", $_SESSION['menu_bogus_menus']) ."')");
    }
    // Update menu OTF preferences.
    $mid = variable_get('menu_parent_items', 0);
    $menu_name = $mid ? $_SESSION['menu_menu_map'][$mid] : 'navigation';
    variable_set('menu_default_node_menu', $menu_name);
    // Skip the navigation menu - it is handled by the user module.
    unset($_SESSION['menu_menu_map'][1]);
    // Update the deltas for all menu module blocks.
    foreach ($_SESSION['menu_menu_map'] as $mid => $menu_name) {
      // This is again secure because we deleted every non-alpanumeric
      // character from the menu name.
      $ret[] = update_sql("UPDATE {blocks} SET delta = '". $menu_name ."' WHERE module  = 'menu' AND delta = '". $mid ."'");
      $ret[] = update_sql("UPDATE {blocks_roles} SET delta = '". $menu_name ."' WHERE module  = 'menu' AND delta = '". $mid ."'");
    }
    $ret[] = array('success' => TRUE, 'query' => t('Relocated @num existing items to the new menu system.', array('@num' => $_SESSION['system_update_6021'])));
    $ret[] = update_sql("DROP TABLE {menu}");
    unset($_SESSION['system_update_6021'], $_SESSION['system_update_6021_max'], $_SESSION['menu_menu_map'], $_SESSION['menu_item_map'], $_SESSION['menu_bogus_menus']);
    // Create the menu overview links - also calls menu_rebuild().
    module_invoke('menu', 'enable');
    $ret['#finished'] = 1;
  }
  else {
    $ret['#finished'] = $_SESSION['system_update_6021'] / $_SESSION['system_update_6021_max'];
  }
  return $ret;
}

/**
 * Update files tables to associate files to a uid by default instead of a nid.
 * Rename file_revisions to upload since it should only be used by the upload
 * module used by upload to link files to nodes.
 */
function system_update_6022() {
  $ret = array();

  // Rename the nid field to vid, add status and timestamp fields, and indexes.
  db_drop_index($ret, 'files', 'nid');
  db_change_field($ret, 'files', 'nid', 'uid', array('type' => 'int', 'unsigned' => TRUE, 'not null' => TRUE, 'default' => 0));
  db_add_field($ret, 'files', 'status', array('type' => 'int', 'not null' => TRUE, 'default' => 0));
  db_add_field($ret, 'files', 'timestamp', array('type' => 'int', 'unsigned' => TRUE, 'not null' => TRUE, 'default' => 0));
  db_add_index($ret, 'files', 'uid', array('uid'));
  db_add_index($ret, 'files', 'status', array('status'));
  db_add_index($ret, 'files', 'timestamp', array('timestamp'));

  // Rename the file_revisions table to upload then add nid column. Since we're
  // changing the table name we need to drop and re-add the vid index so both
  // pgsql ends up with the correct index name.
  db_drop_index($ret, 'file_revisions', 'vid');
  db_rename_table($ret, 'file_revisions', 'upload');
  db_add_field($ret, 'upload', 'nid', array('type' => 'int', 'unsigned' => TRUE, 'not null' => TRUE, 'default' => 0));
  db_add_index($ret, 'upload', 'nid', array('nid'));
  db_add_index($ret, 'upload', 'vid', array('vid'));

  // The nid column was renamed to uid. Use the old nid to find the node's uid.
  switch ($GLOBALS['db_type']) {
    case 'mysql':
    case 'mysqli':
      $ret[] = update_sql('UPDATE {files} f JOIN {node} n ON f.uid = n.nid SET f.uid = n.uid');
      // Use the existing vid to find the nid.
      $ret[] = update_sql('UPDATE {upload} u JOIN {node_revisions} r ON u.vid = r.vid SET u.nid = r.nid');
      break;

    case 'pgsql':
      $ret[] = update_sql('UPDATE {files} AS f SET uid = n.uid FROM {node} n WHERE f.uid=n.nid');
      // Use the existing vid to find the nid.
      $ret[] = update_sql('UPDATE {upload} AS u SET nid = r.nid FROM {node_revisions} r WHERE u.vid = r.vid');
      break;
  }

  // Mark all existing files as FILE_STATUS_PERMANENT.
  $ret[] = update_sql('UPDATE {files} SET status = 1');

  return $ret;
}

function system_update_6023() {
  $ret = array();

  // nid is DEFAULT 0
  db_drop_index($ret, 'node_revisions', 'nid');
  db_change_field($ret, 'node_revisions', 'nid', 'nid', array('type' => 'int', 'unsigned' => TRUE, 'not null' => TRUE, 'default' => 0));
  db_add_index($ret, 'node_revisions', 'nid', array('nid'));
  return $ret;
}

/**
 * Add translation fields to nodes used by translation module.
 */
function system_update_6024() {
  $ret = array();
  db_add_field($ret, 'node', 'tnid', array('type' => 'int', 'unsigned' => TRUE, 'not null' => TRUE, 'default' => 0));
  db_add_field($ret, 'node', 'translate', array('type' => 'int', 'not null' => TRUE, 'default' => 0));
  db_add_index($ret, 'node', 'tnid', array('tnid'));
  db_add_index($ret, 'node', 'translate', array('translate'));
  return $ret;
}

/**
 * Increase the maximum length of node titles from 128 to 255.
 */
function system_update_6025() {
  $ret = array();
  db_drop_index($ret, 'node', 'node_title_type');
  db_change_field($ret, 'node', 'title', 'title', array('type' => 'varchar', 'length' => 255, 'not null' => TRUE, 'default' => ''));
  db_add_index($ret, 'node', 'node_title_type', array('title', array('type', 4)));
  db_change_field($ret, 'node_revisions', 'title', 'title', array('type' => 'varchar', 'length' => 255, 'not null' => TRUE, 'default' => ''));
  return $ret;
}

/**
 * Enable the update.module by default on sites that upgrade.
 *
 * This cannot just rely on update.install to install the schema. If,
 * in the future, someone decides to change the schema for the
 * {cache_update} table, this update would cause uncertainty in the
 * state of the DB, since the effect of running this update would
 * change. For example, if the schema is changed in update #6101, and
 * a site upgrades direct from 5.x to 6.1, update #6026 would create
 * the table with the new schema, and then update #6101 would fail,
 * since it's trying to alter the old schema into the new
 * schema. Therefore, we must hard-code the particular version of the
 * schema we mean during update #6026, and then future upgrades that
 * might attempt to modify the schema of this table will be starting
 * from a known state. See http://drupal.org/node/150220 for more.
 */
function system_update_6026() {
  $ret = array();
  $schema['cache_update'] = array(
    'fields' => array(
      'cid'        => array('type' => 'varchar', 'length' => 255, 'not null' => TRUE, 'default' => ''),
      'data'       => array('type' => 'blob', 'not null' => FALSE, 'size' => 'big'),
      'expire'     => array('type' => 'int', 'not null' => TRUE, 'default' => 0),
      'created'    => array('type' => 'int', 'not null' => TRUE, 'default' => 0),
      'headers'    => array('type' => 'text', 'not null' => FALSE),
      'serialized' => array('type' => 'int', 'size' => 'small', 'not null' => TRUE, 'default' => 0)
    ),
    'indexes' => array('expire' => array('expire')),
    'primary key' => array('cid'),
  );
  db_create_table($ret, 'cache_update', $schema['cache_update']);
  drupal_set_installed_schema_version('update', 0);
  module_enable(array('update'));
  menu_rebuild();
  return $ret;
}


/**
 * Add block cache.
 */
function system_update_6027() {
  $ret = array();

  // Create the blocks.cache column.
  db_add_field($ret, 'blocks', 'cache', array('type' => 'int', 'not null' => TRUE, 'default' => 0, 'size' => 'tiny'));

  // The cache_block table is created in update_fix_d6_requirements() since
  // calls to cache_clear_all() would otherwise cause warnings.

  // Fill in the values for the new 'cache' column,
  // by refreshing the {blocks} table.
  global $theme, $custom_theme;
  $old_theme = $theme;
  $themes = list_themes();

  $result = db_query("SELECT DISTINCT theme FROM {blocks}");
  while ($row = db_fetch_array($result)) {
    if (array_key_exists($row['theme'], $themes)) {
      // Set up global values so that _blocks_rehash()
      // operates on the expected theme.
      $theme = NULL;
      $custom_theme = $row['theme'];
      _block_rehash();
    }
  }

  $theme = $old_theme;

  return $ret;
}

/**
 * Add the node load cache table.
 */
function system_update_6028() {
  // Removed node_load cache to discuss it more for Drupal 7.
  return array();
}

/**
 * Enable the dblog module on sites that upgrade, since otherwise
 * watchdog logging will stop unexpectedly.
 */
function system_update_6029() {
  // The watchdog table is now owned by dblog, which is not yet
  // "installed" according to the system table, but the table already
  // exists.  We set the module as "installed" here to avoid an error
  // later.
  //
  // Although not the case for the initial D6 release, it is likely
  // that dblog.install will have its own update functions eventually.
  // However, dblog did not exist in D5 and this update is part of the
  // initial D6 release, so we know that dblog is not installed yet.
  // It is therefore correct to install it as version 0.  If
  // dblog updates exist, the next run of update.php will get them.
  drupal_set_installed_schema_version('dblog', 0);
  module_enable(array('dblog'));
  menu_rebuild();
  return array();
}

/**
 * Add the tables required by actions.inc.
 */
function system_update_6030() {
  $ret = array();
  $schema['actions'] = array(
    'fields' => array(
      'aid' => array('type' => 'varchar', 'length' => 255, 'not null' => TRUE, 'default' => '0'),
      'type' => array('type' => 'varchar', 'length' => 32, 'not null' => TRUE, 'default' => ''),
      'callback' => array('type' => 'varchar', 'length' => 255, 'not null' => TRUE, 'default' => ''),
      'parameters' => array('type' => 'text', 'not null' => TRUE, 'size' => 'big'),
      'description' => array('type' => 'varchar', 'length' => 255, 'not null' => TRUE, 'default' => '0'),
    ),
    'primary key' => array('aid'),
  );

  $schema['actions_aid'] = array(
    'fields' => array(
      'aid' => array('type' => 'serial', 'unsigned' => TRUE, 'not null' => TRUE),
    ),
    'primary key' => array('aid'),
  );

  db_create_table($ret, 'actions', $schema['actions']);
  db_create_table($ret, 'actions_aid', $schema['actions_aid']);

  return $ret;
}

/**
  * Ensure that installer cannot be run again after updating from Drupal 5.x to 6.x
  */
function system_update_6031() {
  variable_set('install_task', 'done');
  return array();
}

/**
 * profile_fields.name used to be nullable but is part of a unique key
 * and so shouldn't be.
 */
function system_update_6032() {
  $ret = array();
  if (db_table_exists('profile_fields')) {
    db_drop_unique_key($ret, 'profile_fields', 'name');
    db_change_field($ret, 'profile_fields', 'name', 'name', array('type' => 'varchar', 'length' => 128, 'not null' => TRUE, 'default' => ''));
    db_add_unique_key($ret, 'profile_fields', 'name', array('name'));
  }
  return $ret;
}

/**
 * Change node_comment_statistics to be not autoincrement.
 */
function system_update_6033() {
  $ret = array();
  if (db_table_exists('node_comment_statistics')) {
    db_change_field($ret, 'node_comment_statistics', 'nid', 'nid', array('type' => 'int', 'unsigned' => TRUE, 'not null' => TRUE, 'default' => 0));
  }
  return $ret;
}

/**
 * Rename permission "administer access control" to "administer permissions".
 */
function system_update_6034() {
  $ret = array();
  $result = db_query("SELECT rid, perm FROM {permission} ORDER BY rid");
  while ($role = db_fetch_object($result)) {
    $renamed_permission = preg_replace('/administer access control/', 'administer permissions', $role->perm);
    if ($renamed_permission != $role->perm) {
      $ret[] = update_sql("UPDATE {permission} SET perm = '$renamed_permission' WHERE rid = $role->rid");
    }
  }
  return $ret;
}

/**
 * @} End of "defgroup updates-5.x-to-6.x"
 * The next series of updates should start at 7000.
 */
