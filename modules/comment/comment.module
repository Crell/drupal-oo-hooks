<?php
// $Id$

$GLOBALS["cmodes"] = array(1 => t("Flat list - collapsed"), 2 => t("Flat list - expanded"), 3 => t("Threaded list - collapsed"), 4 => t("Threaded list - expanded"));
$GLOBALS["corder"] = array(1 => t("Date - newest first"), 2 => t("Date - oldest first"));

function comment_help($section = "admin/comment/help") {
  $output = "";

  switch ($section) {
    case 'admin/help':
    case 'admin/comment/help':
      $output .= "<p>When enabled, the Drupal comment module creates a discussion board for each Drupal node. Users can post comments to discuss a forum topic, weblog post, collaborative book page, etc.</p>";
      $output .= "<h3>User control of comment display</h3>";
      $output .= "<p>Attached to each comment board is a control panel for customizing the way that comments are displayed. Users can control the chronological ordering of posts (newest or oldest first) and the number of posts to display on each page. Additional settings include:</p>";
      $output .= "<ul>";
      $output .= "<li><b>Threaded</b> -- Displays the posts grouped according to conversations and subconversations, much like the subject view of an email client.</li>";
      $output .= "<li><b>Flat</b> --  Displays the posts in chronological order, in the order in which they are posted.</li>";
      $output .= "<li><b>Expanded</b> -- Displays the title and text for each post.</li>";
      $output .= "<li><b>Collapsed</b> -- Displays only the title for each post.</li>";
      $output .= "</ul>";
      $output .= strtr("<p>When a user chooses <i>save settings</i>, the comments are then redisplayed using the user's new choices. Administrators can set the default settings for the comment control panel, along with other comment defaults, in %comment-config.</p>",array("%comment-config" => l(t("site configuration &raquo; modules &raquo; comment"), "admin/system/modules/comment") ));
      $output .= "<p>NOTE: When comment moderation is enabled, users will have another control panel option to control thresholds (see below).</p>";

      $output .= "<h3>Additional comment configurations</h3>";
      $output .= strtr("<p>Comments behave like other user submissions in Drupal. Filters, smileys and HTML that work in nodes will also work with content. To prevent a single user from spamming the web site with too many comments, administrators can set a comment throttle in %site-config under <i>Submission settings</i>.</p>", array("%site-config" => l(t("site configuration"), "admin/system") ));
      $output .= strtr("<p>Administrators can control access to various comment module functions through %user-permissions. Know that in a new Drupal installation, all comment permissions are disabled by default. The choice of which permissions to grant to which roles (groups of users) is left up to the site administrator.</p>", array("%user-permissions" => l(t("user management &raquo; user permissions"), "admin/user/permission") ));
      $output .= "<p>The following permissions can be enabled for anonymous users, authenticated users, or any other user roles that the administrator chooses to define:</p>";
      $output .= "<ul>";
      $output .= "<li><b>Access comments</b> -- Allows users to view comments.</li>";
      $output .= "<li><b>Administrate comments</b> -- Allows users complete control over configuring, editing and deleting all comments on the site. Best reserved for <b>very</b> trusted users.</li>";
      $output .= "<li><b>Moderate comments</b> -- Allows users to rate comment postings (see more on moderation below).</li>";
      $output .= "<li><b>Post comments</b> -- Allows users to post comments into an administrator moderation queue. Administrators then post the comment to the site.</li>";
      $output .= "<li><b>Post comments without approval</b> -- Allows users to directly post comments. This bypasses the administrator moderation queue.</li>";
      $output .= "</ul>";

      $output .= "<h3>Notification of new comments</h3>";
      $output .= "<p>Drupal provides specific features to inform site members when new comments have been posted:</p>";
      $output .= "<ul>";
      $output .= "<li>On the home page, Drupal displays the total number of comments attached to each node, and tracks comments read by individual site members. Members which have logged in will see a notice accompanying nodes which contain comments that they have not read.</li>";
      $output .= strtr("<li>The <i>tracker</i> module, disabled by default, displays all the site's recent posts. When logged in, members will find a %tracker in their user information block with a link to the %tracker-recent page. This page is a useful way to browse new or updated nodes and comments. Content which the user has not yet read is tagged with a red star (this graphic depends on the current theme). Visit the comment board for any node, and Drupal will display a red <i>new</i> label beside the text of unread comments.</li>",array("%tracker" => l(t("view recent posts"), "tracker"), "%tracker-recent" => l(t("Recent activity"), "tracker") ));
      $output .= strtr("<li>Some administrators may want to %download-notify, install and configure the notify module. Users can then request that Drupal send them an email when new comments are posted (the notify module requires that cron.php be configured properly).</li>", array("%download-notify" => "<a href=\"http://drupal.org/node/view/68\">". t("download") ."</a>" ));
      $output .= "</ul>";

      $output .= "<h3>Comment moderation</h3>";
      $output .= "<p>On sites with active commenting from users, the administrator can turn over comment moderation to the community. </p>";
      $output .= "<p>With comment moderation, each comment is automatically assigned an initial rating. As users read comments, they can apply a vote which affects the comment rating. At the same time, users have an additional option in the control panel which allows them to set a threshold for the comments they wish to view. Those comments with ratings lower than the set threshold will not be shown.</p>";
      $output .= strtr("<p>To enable moderation, the administrator must grant %permission permissions. Then, a number of options in %comment-moderation must be configured.</p>", array("%permission" => l(t("moderate comments"), "admin/user/permissions"), "%comment-moderation" => l(t("comment management &raquo; comment moderation"), "admin/comment/moderation") ));

      $output .= "<h4>Moderation votes</h4>";
      $output .= strtr("<p>The first step is to create moderation labels which allow users to rate a comment.  Go to %comment-votes. In the <i>vote</i> field, enter the textual labels which users will see when casting their votes. Some examples are</p>", array("%comment-votes" => l(t("comment management &raquo; comment moderation &raquo; votes"), "admin/comment/moderation/votes") ));
      $output .= "<ul>";
      $output .= "<li>Excellent +3</li>";
      $output .= "<li>Insightful +2</li>";
      $output .= "<li>Caught My Attention +1</li>";
      $output .= "<li>Useful +1</li>";
      $output .= "<li>Redundant -1</li>";
      $output .= "<li>Flame -3</li>";
      $output .= "</ul>";
      $output .= "<p>So that users know how their votes affect the comment, these examples include the vote value as part of the label, although that is optional.</p>";
      $output .= "<p>Using the weight option, you can control the order in which the votes appear to users. Setting the weight heavier (positive numbers) will make the vote label appear at the bottom of the list. Lighter (a negative number) will push it to the top. To encourage positive voting, a useful order might be higher values, positive votes, at the top, with negative votes at the bottom.</p>";

      $output .= "<h4>Moderator vote/values matrix</h4>";

      $output .= strtr("<p>Next go to %comment-matrix.  Enter the values for the vote labels for each permission role in the vote matrix. The values entered here will be used to create the rating for each comment.</p>", array("%comment-matrix" => l(t("comment management &raquo; comment moderation &raquo; matrix"), "admin/comment/moderation/,atrix") ));
      $output .= "<p>NOTE: Comment ratings are calculated by averaging user votes with the initial rating.</p>";
      $output .= "<h4>Creating comment thresholds</h4>
<p>In <i>comment management &raquo; comment moderation &raquo; thresholds</i>, you'll have to create some comment thresholds to make the comment rating system useful. When comment moderation is enabled and the thresholds are created, users will find another comment control panel option for selecting thresholds. They'll use the thresholds you enter here to filter out comments with low ratings. Consequently, you'll probably want to create more than one threshold to give users some flexibility in filtering comments.</p>
<p>When creating the thresholds, note that the <i>Minimum score</i> is asking you for the lowest rating that a comment can have in order to be displayed.</p>
<p>To see a common example of how thresholds work, you might visit <a href=\"http://slashdot.org/\">Slashdot</a> and view one of their comment boards associated with a story. You can reset the thresholds in their comment control panel.</p>

<h4>Initial comment scores</h4>
<p>Finally, you may want to enter some <i>initial comment scores</i>. In <i>comment management &raquo; initial comment scores </i>you can assign a beginning rating for all comments posted by a particular permission role. If you do not assign any initial scores, Drupal will assign a rating of <b>0</b> as the default.</p>";
    break;
  }
  return t($output);
}

function comment_system($field) {
  $system["description"] = t("Enables user to comment on content (nodes).");
  $system["admin_help"] = t("Comments can be attached to any node. Below are the settings for comments. The display comes in two types, a \"flat list\" where everything is flush to the left side, and comments come in cronological order, and a \"threaded list\" where comments to other comments are placed immediately below the orignal, and slightly indented forming an outline of comments. They also come in two styles: \"expanded\", where you get to see both the title and the contents, and \"collapsed\" where you only see the titles. To set the default threshold you first have to set up thresholds in the <a href=\"%threshold\">comment management &gt;&gt; comment moderation &gt;&gt; thresholds</a> area. Preview comment forces a user to click on a \"Preview\" button so they can see what their comment will look like before they can actually add the comment to the system. If \"New comment form\" is enabled then at the bottom of every comment page there will be a form too add a new comment.", array("%threshold" => url("admin/comment/moderation/filters")));
  return $system[$field];
}

function comment_settings() {
  global $cmodes, $corder;

  $output .= form_select(t("Default display mode"), "comment_default_mode", variable_get("comment_default_mode", 4), $cmodes, t("The default view for comments. Expanded views display the body of the comment. Threaded views keep replies together."));
  $output .= form_select(t("Default display order"), "comment_default_order", variable_get("comment_default_order", 1), $corder, t("The default sorting for new users and anonymous users while viewing comments. These users may change their view using the comment control panel. For registered users, this change is remembered as a persistent user preference."));
  $output .= form_textfield(t("Default comments per page"), "comment_default_per_page", variable_get("comment_default_per_page", "50"), 5, 5, t("Default number of comments for each page; more comments are distributed in several pages."));

  $result = db_query("SELECT fid, filter FROM {moderation_filters} ");
  while ($filter = db_fetch_object($result)) {
    $thresholds[$filter->fid] = ($filter->filter);
  }

  $output .= form_select(t("Default threshold"), "comment_default_threshold", variable_get("comment_default_threshold", 0), $thresholds, t("Thresholds are values below which comments are hidden. These thresholds are useful for busy sites which want to hide poor comments from most users."));

  $output .= form_select(t("Preview comment"), "comment_preview", variable_get("comment_preview", 1), array(t("Optional"), t("Required")), t("Must users preview comments before submitting?"));
  $output .= form_select(t("New comment form"), "comment_new_form", variable_get("comment_new_form", 0), array(t("Disabled"), t("Enabled")), t("New comment form in the node page?"));
  $output .= form_select(t("Comment controls"), "comment_controls", variable_get("comment_controls", 0), array(t("Above comments"), t("Below comments"), t("Above and below")), t("Position of the comment controls box."));

  return $output;
}

function comment_user($type, $edit, &$user) {
  switch ($type) {
    case "view_public":
      if ($user->signature) {
        return form_item(t("Signature"), check_output($user->signature));
      }
      break;
    case "view_private":
      if ($user->signature) {
        return form_item(t("Signature"), check_output($user->signature));
      }
      break;
    case "edit_form":
      // when user tries to edit his own data
      return form_textarea(t("Signature"), "signature", $edit["signature"], 70, 3, t("Your signature will be publicly displayed at the end of your comments.") ."<br />". form_allowed_tags_text());
    case "edit_validate":
      // validate user data editing
      return array("signature" => $edit["signature"]);
  }
}

function comment_access($op, $comment) {
  global $user;

  if ($op == "edit") {

    /*
    ** Authenticated users can edit their comments as long they have
    ** not been replied to.  This, in order to avoid people changing
    ** or revising their statements based on the replies their posts
    ** got. Furthermore, users can't reply to their own comments and
    ** are encouraged to extend their original comment.
    */

    return $user->uid && $user->uid == $comment->uid && comment_num_replies($comment->cid) == 0;
  }

}

function comment_form($edit) {
  global $user;

  $form .= "<a id=\"comment\"></a>\n";

  // name field:
  $form .= form_item(t("Your name"), format_name($user));

  // subject field:
  $form .= form_textfield(t("Subject"), "subject", $edit["subject"], 50, 64);

  // comment field:
  $form .= form_textarea(t("Comment"), "comment", $edit["comment"] ? $edit["comment"] : $user->signature, 70, 10, form_allowed_tags_text());

  // preview button:
  $form .= form_hidden("cid", $edit["cid"]);
  $form .= form_hidden("pid", $edit["pid"]);
  $form .= form_hidden("nid", $edit["nid"]);

  if (!$edit["comment"] && variable_get("comment_preview", 1)) {
    $form .= form_submit(t("Preview comment"));
  }
  else {
    $form .= form_submit(t("Preview comment"));
    $form .= form_submit(t("Post comment"));
  }

  return form($form, "post", url("comment/reply/". $edit["nid"]));
}

function comment_edit($cid) {
  global $user;

  $comment = db_fetch_object(db_query("SELECT c.*, u.uid, u.name, u.data FROM {comments} c LEFT JOIN {users} u ON c.uid = u.uid WHERE c.cid = %d AND c.status != 2", $cid));

  if (comment_access("edit", $comment)) {
    comment_preview(object2array($comment));
  }
}

function comment_reply($pid, $nid) {


  if (user_access("access comments")) {

    /*
    ** Show comment
    */

    if ($pid) {
      $comment = db_fetch_object(db_query("SELECT c.*, u.uid, u.name, u.data FROM {comments} c LEFT JOIN {users} u ON c.uid = u.uid WHERE c.cid = %d AND c.status = 0", $pid));
      comment_view($comment);
    }
    else if (user_access("access content")) {
      node_view(node_load(array("nid" => $nid)));
      $pid = 0;
    }

    /*
    ** If possible, show reply form
    */

    if (node_comment_mode($nid) != 2) {
      theme("box", t("Reply"), t("This discussion is closed: you can't post new comments."));
    }
    else if (user_access("post comments")) {
      theme("box", t("Reply"), comment_form(array("pid" => $pid, "nid" => $nid)));
    }
    else {
      theme("box", t("Reply"), t("You are not authorized to post comments."));
    }
  }
  else {
    theme("box", t("Reply"), t("You are not authorized to view comments."));
  }
}

function comment_preview($edit) {
  global $user;

  foreach ($edit as $key => $value) {
    $comment->$key = $value;
  }

  /*
  ** Attach the user and time information:
  */

  $comment->uid = $user->uid;
  $comment->name = $user->name;
  $comment->timestamp = time();

  /*
  ** Preview the comment:
  */

  comment_view($comment, t("reply to this comment"));

  theme("box", t("Reply"), comment_form($edit));

  if ($edit["pid"]) {
    $comment = db_fetch_object(db_query("SELECT c.*, u.uid, u.name, u.data FROM {comments} c LEFT JOIN {users} u ON c.uid = u.uid WHERE c.cid = %d AND c.status = 0", $edit["pid"]));
    comment_view($comment);
  }
  else {
    node_view(node_load(array("nid" => $edit["nid"])));
    $edit["pid"] = 0;
  }
}

function comment_post($edit) {
  global $user;

  if (user_access("post comments") && node_comment_mode($edit["nid"]) == 2) {

    /*
    ** Validate the comment's subject.  If not specified, extract
    ** one from the comment's body.
    */

    $edit["subject"] = strip_tags($edit["subject"]);

    if ($edit["subject"] == "") {
      $edit["subject"] = substr(strip_tags($edit["comment"]), 0, 29);
    }

    /*
    ** Validate the comment's body.
    */

    if ($edit["comment"] == "") {
      return array(t("Empty comment"), t("The comment you submitted is empty."));
    }

    /*
    ** Check for duplicate comments.  Note that we have to use the
    ** validated/filtered data to perform such check.
    */

    $duplicate = db_result(db_query("SELECT COUNT(cid) FROM {comments} WHERE pid = %d AND nid = %d AND subject = '%s' AND comment = '%s'", $edit["pid"], $edit["nid"], $edit["subject"], $edit["comment"]), 0);

    if ($duplicate != 0) {
      watchdog("warning", "comment: duplicate '". $edit["subject"] ."'");
      return array(t("Duplicate comment"), t("The comment you submitted has already been inserted."));
    }
    else {

      if ($edit["cid"]) {

        /*
        ** Update the comment in the database.  Note that the update
        ** query will fail if the comment isn't owned by the current
        ** user.
        */

        db_query("UPDATE {comments} SET subject = '%s', comment = '%s' WHERE cid = %d AND uid = '$user->uid'", $edit["subject"], $edit["comment"], $edit["cid"]);

        /*
        ** Fire a hook
        */

        module_invoke_all("comment", "update", $edit);

        /*
        ** Add entry to the watchdog log:
        */

        watchdog("special", "comment: updated '". $edit["subject"] ."'", l(t("view comment"), "node/view/". $edit["nid"] ."#". $edit["cid"]));
      }
      else {
        /*
        ** Check the user's comment submission rate.  If exceeded,
        ** throttle() will bail out.
        */

        throttle("post comment", variable_get("max_comment_rate", 60));

        /*
        ** Add the comment to database:
        */

        $status = user_access("post comments without approval") ? 0 : 1;
        $roles = variable_get("comment_roles", array());
        $score = $roles[$user->rid] ? $roles[$user->rid] : 0;
        $users = serialize(array(0 => $score));

        /*
        ** Here we are building the thread field.  See the comment
        ** in comment_render().
        */

        if ($edit["pid"] == 0) {
          /*
          ** This is a comment with no parent comment (depth 0): we start
          ** by retrieving the maximum thread level.
          */

          $max = db_result(db_query("SELECT MAX(thread) FROM {comments} WHERE nid = %d", $edit["nid"]));

          // Strip the "/" from the end of the thread
          $max = rtrim($max, "/");

          /*
          ** Next, we increase this value by one.  Note that we can't
          ** use 1, 2, 3, ... 9, 10, 11 because we order by string and
          ** 10 would be right after 1.  We use 1, 2, 3, ..., 9, 91,
          ** 92, 93, ... instead.  Ugly but fast.
          */

          $decimals = (string)substr($max, 0, strlen($max) - 1);
          $units = substr($max, -1, 1);
          if ($units) {
            $units++;
          }
          else {
            $units = 1;
          }

          if ($units == 10) {
            $units = "90";
          }

          // Finally build the thread field for this new comment
          $thread = "$decimals$units/";
        }
        else {
          /*
          ** This is comment with a parent comment: we increase
          ** the part of the thread value at the proper depth.
          */

          // Get the parent comment:
          $parent = db_fetch_object(db_query("SELECT * FROM {comments} WHERE cid = '%d'", $edit["pid"]));

          // Strip the "/" from the end of the parent thread:
          $parent->thread = (string)rtrim((string)$parent->thread, "/");

          // Get the max value in _this_ thread:
          $max = db_result(db_query("SELECT MAX(thread) FROM {comments} WHERE thread LIKE '%s.%%' AND nid = '%d'", $parent->thread, $edit["nid"]));

          if ($max == "") {
            // First child of this parent
            $thread = "$parent->thread.1/";
          }
          else {
            // Strip the "/" at the end of the thread:
            $max = rtrim($max, "/");

            // We need to get the value at the correct depth:
            $parts = explode(".", $max);
            $parent_depth = count(explode(".",$parent->thread));
            $last = $parts[$parent_depth];

            /*
            ** Next, we increase this value by one.  Note that we can't
            ** use 1, 2, 3, ... 9, 10, 11 because we order by string and
            ** 10 would be right after 1.  We use 1, 2, 3, ..., 9, 91,
            ** 92, 93, ... instead.  Ugly but fast.
            */

            $decimals = (string)substr($last, 0, strlen($last) - 1);
            $units = substr($last, -1, 1);
            $units++;
            if ($units == 10) {
              $units = "90";
            }

            // Finally build the thread field for this new comment:
            $thread = "$parent->thread.".$decimals.$units."/";
          }
        }


        $edit["cid"] = db_next_id("comments_cid");

        db_query("INSERT INTO {comments} (cid, nid, pid, uid, subject, comment, hostname, timestamp, status, score, users, thread) VALUES (%d, %d, %d, %d, '%s', '%s', '%s', %d, %d, %d, '%s', '%s')", $edit["cid"], $edit["nid"], $edit["pid"], $user->uid, $edit["subject"], $edit["comment"], getenv("REMOTE_ADDR"), time(), $status, $score, $users, $thread);

        /*
        ** Tell the other modules a new comment has been submitted:
        */

        module_invoke_all("comment", "insert", $edit);

        /*
        ** Add entry to the watchdog log:
        */

        watchdog("special", "comment: added '". $edit["subject"] ."'", l(t("view comment"), "node/view/". $edit["nid"] ."#". $edit["cid"]));
      }

      /*
      ** Clear the cache so an anonymous user can see his comment being
      ** added.
      */

      cache_clear_all();
    }
  }
  else {
    watchdog("error", "comment: unauthorized comment submitted or comment submitted to a closed node '". $edit["subject"] ."'");
    return array(t("Error"), t("You are not authorized to post comments, or this node doesn't accept new comments."));
  }

  /*
  ** Redirect the user the node he commented on, or explain queue
  */

  if ($status == 1) {
    return array(t("Comment queued"), t("Your comment has been queued for moderation by site administrators and will be published after approval."));
  }
}

function comment_links($comment, $return = 1) {
  global $user;

  $links = array();

  /*
  ** If we are viewing just this comment, we link back to the node
  */

  if ($return) {
    $links[] = l(t("parent"), "node/view/$comment->nid#$comment->cid");
  }

  /*
  ** Admin link
  */

  if (user_access("administer comments") && user_access("access administration pages")) {
    $links[] = l(t("administer"), "admin/comment/edit/$comment->cid");
  }

  /*
  ** Possibly show edit and reply links
  */

  if (node_comment_mode($comment->nid) == 2) {
    if (user_access("post comments")) {
      if (comment_access("edit", $comment)) {
        $links[] = l(t("edit your comment"), "comment/edit/$comment->cid", array("title" => t("Make changes to your comment.")));
      }
      $links[] = l(t("reply to this comment"), "comment/reply/$comment->nid/$comment->cid");
    }
    else {
      $links[] = theme("comment_post_forbidden");
    }
  }

  if ($moderation = comment_moderation_form($comment)) {
    $links[] = $moderation;
  }

  return theme("links", $links);
}

function comment_view($comment, $links = "", $visible = 1) {

  /*
  ** Switch to folded/unfolded view of the comment
  */

  if (node_is_new($comment->nid, $comment->timestamp)) {
    $comment->new = 1;
    print "<a id=\"new\"></a>\n";
  }

  print "<a id=\"$comment->cid\"></a>\n";

  if ($visible) {
    $comment->comment = check_output($comment->comment);
    theme("comment", $comment, $links);
  }
  else {
    theme("comment_folded", $comment);
  }
}

function comment_render($node, $cid = 0) {
  global $user;

  $mode = $_GET["mode"];
  $order = $_GET["order"];
  $threshold = $_GET["threshold"];
  $comments_per_page = $_GET["comments_per_page"];
  $comment_page = $_GET["comment_page"];

  if (user_access("access comments")) {

    /*
    ** Pre-process variables:
    */

    $nid = $node->nid;
    if (empty($nid)) {
      $nid = 0;
    }

    if (empty($mode)) {
      $mode = $user->mode ? $user->mode : variable_get("comment_default_mode", 4);
    }

    if (empty($order)) {
      $order = $user->sort ? $user->sort : variable_get("comment_default_order", 1);
    }

    if (empty($threshold)) {
      $threshold = $user->uid ? $user->threshold : variable_get("comment_default_threshold", 0);
    }
    $threshold_min = db_result(db_query("SELECT minimum FROM {moderation_filters} WHERE fid = %d", $threshold));

    if (empty($comments_per_page)) {
      $comments_per_page = $user->comments_per_page ? $user->comments_per_page : variable_get("comment_default_per_page", "50");
    }

    print "<a id=\"comment\"></a>\n";


    if ($cid) {

      /*
      ** Single comment view
      */

      print "<form method=\"post\" action=\"". url("comment") ."\"><div>\n";
      print form_hidden("nid", $nid);

      $result = db_query("SELECT c.cid, c.pid, c.nid, c.subject, c.comment, c.timestamp, u.uid, u.name, u.data, c.score, c.users FROM {comments} c LEFT JOIN {users} u ON c.uid = u.uid WHERE c.cid = %d AND c.status = 0 GROUP BY c.cid, c.pid, c.nid, c.subject, c.comment, c.timestamp, u.uid, u.name, u.data, c.score, c.users", $cid);

      if ($comment = db_fetch_object($result)) {
        comment_view($comment, comment_links($comment));
      }

      if ((comment_user_can_moderate($node)) && $user->uid != $comment->uid && !(comment_already_moderated($user->uid, $comment->users))) {
        print "<div style=\"text-align: center;\">". form_submit(t("Moderate comment")) ."</div><br />";
      }
      print "</div></form>";
    }
    else {

      /*
      ** Multiple comments view
      */

      $query .= "SELECT c.cid as cid, c.pid, c.nid, c.subject, c.comment, c.timestamp, u.uid, u.name, u.data, c.score, c.users, c.thread FROM {comments} c LEFT JOIN {users} u ON c.uid = u.uid WHERE c.nid = '". check_query($nid) ."' AND c.status = 0";

      $query .= " GROUP BY c.cid, c.pid, c.nid, c.subject, c.comment, c.timestamp, u.uid, u.name, u.data, c.score, c.users, c.thread";

      /*
      ** We want to use the standard pager, but threads would need every
      ** comment to build the thread structure, so we need to store some
      ** extra info.
      **
      ** We use a "thread" field to store this extra info. The basic idea
      ** is to store a value and to order by that value. The "thread" field
      ** keeps this data in a way which is easy to update and convenient
      ** to use.
      **
      ** A "thread" value starts at "1". If we add a child (A) to this
      ** comment, we assign it a "thread" = "1.1". A child of (A) will have
      ** "1.1.1". Next brother of (A) will get "1.2". Next brother of the
      ** parent of (A) will get "2" and so on.
      **
      ** First of all note that the thread field stores the depth of the
      ** comment: depth 0 will be "X", depth 1 "X.X", depth 2 "X.X.X", etc.
      **
      ** Now to get the ordering right, consider this example:
      **
      ** 1
      ** 1.1
      ** 1.1.1
      ** 1.2
      ** 2
      **
      ** If we "ORDER BY thread ASC" we get the above result, and this is
      ** the natural order sorted by time.  However, if we "ORDER BY thread
      ** DESC" we get:
      **
      ** 2
      ** 1.2
      ** 1.1.1
      ** 1.1
      ** 1
      **
      ** Clearly, this is not a natural way to see a thread, and users
      ** will get confused. The natural order to show a thread by time
      ** desc would be:
      **
      ** 2
      ** 1
      ** 1.2
      ** 1.1
      ** 1.1.1
      **
      ** which is what we already did before the standard pager patch. To
      ** achieve this we simply add a "/" at the end of each "thread" value.
      ** This way out thread fields will look like depicted below:
      **
      ** 1/
      ** 1.1/
      ** 1.1.1/
      ** 1.2/
      ** 2/
      **
      ** we add "/" since this char is, in ASCII, higher than every number,
      ** so if now we "ORDER BY thread DESC" we get the correct order.  Try
      ** it, it works ;).  However this would spoil the "ORDER BY thread ASC"
      ** Here, we do not need to consider the trailing "/" so we use a
      ** substring only.
      */

      if ($order == 1) {
        if ($mode == 1 || $mode == 2) {
          $query .= " ORDER BY c.timestamp DESC";
        }
        else {
          $query .= " ORDER BY c.thread DESC";
        }
      }
      else if ($order == 2) {
        if ($mode == 1 || $mode == 2) {
          $query .= " ORDER BY c.timestamp";
        }
        else {

          /*
          ** See comment above.  Analysis learns that this doesn't cost
          ** too much.  It scales much much better than having the whole
          ** comment structure.
          */

          $query .= " ORDER BY SUBSTRING(c.thread, 1, (LENGTH(c.thread) - 1))";
        }
      }

      /*
      ** Start a form, to use with comment control and moderation.
      */

      $result = pager_query($query, $comments_per_page, 0, "SELECT COUNT(*) FROM {comments} WHERE nid = '".check_query($nid)."'");

      if ((variable_get("comment_controls", 0) == 0) || (variable_get("comment_controls", 0) == 2)) {
        print "<form method=\"post\" action=\"". url("comment") ."\"><div>\n";
        theme("box", "", theme("comment_controls", $threshold, $mode, $order, $comments_per_page));
        print form_hidden("nid", $nid);
        print "</div></form>";
      }

      print "<form method=\"post\" action=\"". url("comment") ."\"><div>\n";
      print form_hidden("nid", $nid);

      while ($comment = db_fetch_object($result)) {
        $comment->depth = count(explode(".", $comment->thread)) - 1;

        if ($mode == 1) {
          theme("comment_flat_collapsed", $comment, $threshold_min);
        }
        else if ($mode == 2) {
          theme("comment_flat_expanded", $comment, $threshold_min);
        }
        else if ($mode == 3) {
          theme("comment_thread_min", $comment, $threshold_min);
        }
        else if ($mode == 4) {
          theme("comment_thread_max", $comment, $threshold_min);
        }
      }

      /*
      ** Use the standard pager, $pager_total is the number of returned rows,
      ** is global and defined in pager.inc
      */
      if ($pager = pager_display(NULL, $comments_per_page, 0, "default", array("comments_per_page" => $comments_per_page))) {
        print $pager;
      }

      if (comment_user_can_moderate($node)) {
        print "<div align=\"center\">". form_submit(t("Moderate comments")) ."</div><br />";
      }

      print "</div></form>";

      if ((variable_get("comment_controls", 0) == 1) || (variable_get("comment_controls", 0) == 2)) {
        print "<form method=\"post\" action=\"". url("comment") ."\"><div>\n";
        theme("box", "", theme("comment_controls", $threshold, $mode, $order, $comments_per_page));
        print form_hidden("nid", $nid);
        print "</div></form>";
      }
    }

    /*
    ** If enabled, show new comment form
    */

    if (user_access("post comments") && node_comment_mode($nid) == 2 && variable_get("comment_new_form", 0)) {
      theme("box", t("Post new comment"), comment_form(array("nid" => $nid)));
    }

  }
}

function comment_perm() {
  return array("access comments", "post comments", "administer comments", "moderate comments", "post comments without approval", "administer moderation");
}

function comment_link($type, $node = 0, $main = 0) {

  if ($type == "node" && $node->comment) {

    if ($main) {

      /*
      ** Main page: display the number of comments that have been posted.
      */

      if (user_access("access comments")) {
        $all = comment_num_all($node->nid);
        $new = comment_num_new($node->nid);

        if ($all) {
          $links[] = l(format_plural($all, "1 comment", "%count comments"), "node/view/$node->nid#comment", array("title" => t("Jump to the first comment of this posting.")));

          if ($new) {
            $links[] = l(format_plural($new, "1 new comment", "%count new comments"), "node/view/$node->nid#new", array("title" => t("Jump to the first new comment of this posting.")));
          }
        }
        else {
          if (user_access("post comments")) {
            $links[] = l(t("add new comment"), "comment/reply/$node->nid", array("title" => t("Add a new comment to this page.")));
          }
          else {
            $links[] = theme("comment_post_forbidden");
          }
        }
      }
    }
    else {
      /*
      ** Node page: add a "post comment" link if the user is allowed to
      ** post comments and if this node is not read-only
      */

      if ($node->comment == 2) {
        if (user_access("post comments")) {
          $links[] = l(t("add new comment"), "comment/reply/$node->nid#comment", array("title" => t("Share your thoughts and opinions related to this posting.")));
        }
        else {
          $links[] = theme("comment_post_forbidden");
        }
      }
      else {
        $links[] = t("Closed discussion: you can't post new comments.");
      }
    }
  }

  if ($type == "admin" && user_access("administer comments")) {

    menu("admin/comment", "comment management", "comment_admin", comment_help("admin/comment"), 2);
    menu("admin/comment/comments", "comment overview",NULL, comment_help("admin/comment/comments"), 2);
    menu("admin/comment/comments/0", "new or updated comments", "comment_admin", comment_help("admin/comment/comments/0"), 1);
    menu("admin/comment/comments/1", "comment approval queue", "comment_admin", comment_help("admin/comment/comments/1"), 2);
    menu("admin/comment/search", "search comments", "comment_admin", comment_help("admin/comment/search"), 8);
    menu("admin/comment/help", "help", "comment_help", NULL, 9);
    menu("admin/comment/edit", "edit comment", "comment_admin", NULL, 0, 1);

    // comment settings:
    if (user_access("administer moderation")) {
      menu("admin/comment/moderation", "comment moderation", NULL, comment_help("admin/comment/moderation"), 3);
      menu("admin/comment/moderation/votes", "votes", "comment_admin", comment_help("admin/comment/moderation/votes"));
      menu("admin/comment/moderation/matrix", "matrix", "comment_admin", comment_help("admin/comment/moderation/matrix"));
      menu("admin/comment/moderation/filters", "thresholds", "comment_admin", comment_help("admin/comment/moderation/filters"));
      menu("admin/comment/moderation/roles", "initial comment scores", "comment_admin", comment_help("admin/comment/roles"), 6);
    }
  }

  return $links ? $links : array();
}

function comment_page() {
  $op = $_POST["op"];
  $edit = $_POST["edit"];

  if (empty($op)) {
    $op = arg(1);
  }

  switch ($op) {
    case "edit":
      theme("header");
      comment_edit(check_query(arg(2)));
      theme("footer");
      break;
    case t("Moderate comments"):
    case t("Moderate comment"):
      comment_moderate($edit);
      drupal_goto(url("node/view/". $edit["nid"]));
      break;
    case "reply":
      theme("header");
      comment_reply(check_query(arg(3)), check_query(arg(2)));
      theme("footer");
      break;
    case t("Preview comment"):
      theme("header");
      comment_preview($edit);
      theme("footer");
      break;
    case t("Post comment"):
      list($error_title, $error_body) = comment_post($edit);
      if ($error_body) {
        theme("header");
        theme("box", $error_title, $error_body);
        theme("footer");
      }
      else {
        drupal_goto(url("node/view/". $edit["nid"]));
      }
      break;
    case t("Save settings"):
      $mode = $_POST["mode"];
      $order = $_POST["order"];
      $threshold = $_POST["threshold"];
      $comments_per_page = $_POST["comments_per_page"];

      comment_save_settings(check_query($mode), check_query($order), check_query($threshold), check_query($comments_per_page));
      drupal_goto(url("node/view/". $edit["nid"], "mode=$mode&order=$order&threshold=$threshold&comments_per_page=$comments_per_page"));
      break;
  }
}

/**
*** admin functions
**/

function comment_node_link($node) {

  if (user_access("administer comments")) {

    /*
    ** Edit comments:
    */

    $result = db_query("SELECT c.cid, c.subject, u.uid, u.name FROM {comments} c LEFT JOIN {users} u ON u.uid = c.uid WHERE nid = %d AND c.status = 0 ORDER BY c.timestamp", $node->nid);


    $header = array(t("title"), t("author"), array("data" => t("operations"), "colspan" => 3));

    while ($comment = db_fetch_object($result)) {
      $rows[] = array(l($comment->subject, "node/view/$node->nid#$comment->cid"), format_name($comment), l(t("view comment"), "node/view/$node->nid#$comment->cid"), l(t("edit comment"), "admin/comment/edit/$comment->cid"), l(t("delete comment"), "admin/comment/delete/$comment->cid"));
    }

    if ($rows) {
      $output  = "<h3>". t("Edit comments") ."</h3>";
      $output .= table($header, $rows);
    }

    return $output;
  }
}

function comment_admin_edit($id) {

  $result = db_query("SELECT c.*, u.name, u.uid FROM {comments} c LEFT JOIN {users} u ON c.uid = u.uid WHERE c.cid = %d AND c.status != 2", $id);
  $comment = db_fetch_object($result);

  // if a comment is "deleted", it's deleted
  if ($comment) {
    $form .= form_item(t("Author"), format_name($comment));
    $form .= form_textfield(t("Subject"), "subject", $comment->subject, 70, 128);
    $form .= form_textarea(t("Comment"), "comment", $comment->comment, 70, 15);
    $form .= form_select(t("Status"), "status", $comment->status, array("published", "not published"));
    $form .= form_hidden("cid", $id);
    $form .= form_submit(t("Submit"));
    $form .= form_submit(t("Delete"));

    return form($form);
  }
}

function comment_delete($edit) {

  if ($edit["confirm"]) {
    db_query("UPDATE {comments} SET status = 2 WHERE cid = %d", $edit["cid"]);
    watchdog("special", "comment: deleted comment #". $edit["cid"]);
    $output = "deleted comment.";
  }
  else {
    $output .= form_item(t("Confirm deletion"), "");
    $output .= form_hidden("cid", $edit["cid"]);
    $output .= form_hidden("confirm", 1);
    $output .= form_submit(t("Delete"));
    $output = form($output);
  }

  return $output;
}

function comment_save($id, $edit) {
  db_query("UPDATE {comments} SET subject = '%s', comment = '%s', status = %d WHERE cid = %d", $edit["subject"], $edit["comment"], $edit["status"], $id);
  watchdog("special", "comment: modified '". $edit["subject"] ."'");
  return "updated comment.";
}

function comment_admin_overview($status = 0) {

  $header = array(
    array("data" => t("Subject"), "field" => "subject"),
    array("data" => t("Author"), "field" => "u.name"),
    array("data" => t("Status"), "field" => "status"),
    array("data" => t("Time"), "field" => "timestamp", "sort" => "desc"),
    array("data" => t("operations"), "colspan" => 2)
  );

  $sql = "SELECT c.*, u.name, u.uid FROM {comments} c LEFT JOIN {users} u ON u.uid = c.uid WHERE c.status = ". check_query($status);
  $sql .= tablesort_sql($header);
  $result = pager_query($sql,  50);

  while ($comment = db_fetch_object($result)) {
    $rows[] = array(l($comment->subject, "node/view/$comment->nid/$comment->cid#$comment->cid", array("title" => htmlspecialchars(substr($comment->comment, 0, 128)))) ." ". (node_is_new($comment->nid, $comment->timestamp) ? theme_mark() : ""), format_name($comment), ($comment->status == 0 ? t("published") : t("not published")) ."</td><td>". format_date($comment->timestamp, "small"). "</td><td>". l(t("edit comment"), "admin/comment/edit/$comment->cid"), l(t("delete comment"), "admin/comment/delete/$comment->cid"));
  }

  if ($pager = pager_display(NULL, 50, 0, "admin", tablesort_pager())) {
    $rows[] = array(array("data" => $pager, "colspan" => 6));
  }

  return table($header, $rows);
}

function comment_mod_matrix($edit) {

  $output .= "<h3>Moderation vote/value matrix</h3>";

  if ($edit) {
    db_query("DELETE FROM {moderation_roles} ");
    foreach ($edit as $role_id => $votes) {
      foreach ($votes as $mid => $value) {
        $sql[] = "('$mid', '$role_id', '". ($value ? $value : 0 ) ."')";
      }
    }
    db_query("INSERT INTO {moderation_roles} (mid, rid, value) VALUES ". implode(", ", $sql));
    $output = status("Vote values saved");
  }

  $result = db_query("SELECT r.rid, r.name FROM {role} r, {permission} p WHERE r.rid = p.rid AND p.perm LIKE '%moderate comments%'");
  $role_names = array();
  while ($role = db_fetch_object($result)) {
    $role_names[$role->rid] = $role->name;
  }

  $result = db_query("SELECT rid, mid, value FROM {moderation_roles} ");
  while ($role = db_fetch_object($result)) {
    $mod_roles[$role->rid][$role->mid] = $role->value;
  }

  $header = array_merge(array(t("votes")), array_values($role_names));

  $result = db_query("SELECT mid, vote FROM {moderation_votes} ORDER BY weight");
  while ($vote = db_fetch_object($result)) {
    $row = array($vote->vote);
    foreach (array_keys($role_names) as $rid) {
      $row[] = array("data" => form_textfield(NULL, "$rid][$vote->mid", $mod_roles[$rid][$vote->mid], 4, 3), "align" => "center");
    }
    $rows[] = $row;
  }
  $output .= table($header, $rows);
  $output .= "<br />". form_submit(t("Submit votes"));

  return form($output);
}

function comment_mod_roles($edit) {

  $output .= "<h3>Initial comment scores</h3>";

  if ($edit) {
    variable_set("comment_roles", $edit);
    $output = status("Comment scores saved");
  }

  $start_values = variable_get("comment_roles", array());

  $result = db_query("SELECT r.rid, r.name FROM {role} r, {permission} p WHERE r.rid = p.rid AND p.perm LIKE '%post comments%'");

  $header = array(t("user role"), t("initial score"));

  while ($role = db_fetch_object($result)) {
    $rows[] = array($role->name, array("data" => form_textfield(NULL, $role->rid, $start_values[$role->rid], 4, 3), "align" => "center"));
  }

  $output .= table($header, $rows);
  $output .= "<br />". form_submit(t("Save scores"));

  return form($output);
}

function comment_mod_votes($edit) {
  $op = $_POST["op"];

  $mid = arg(4);

  if ($op == t("Save vote")) {
    db_query("UPDATE {moderation_votes} SET vote = '%s', weight = %d WHERE mid = %d", $edit["vote"], $edit["weight"], $mid);
    $mid = 0;
    $output = status("Vote saved");
  }
  else if ($op == t("Delete vote")) {
    db_query("DELETE FROM {moderation_votes} WHERE mid = %d", $mid);
    db_query("DELETE FROM {moderation_roles} WHERE mid = %d", $mid);
    $mid = 0;
    $output = status("Vote deleted");
  }
  else if ($op == t("Add new vote")) {
    db_query("INSERT INTO {moderation_votes} (vote, weight) VALUES ('%s', %d)", $edit["vote"], $edit["weight"]);
    $mid = 0;
    $output = status("Vote added");
  }

  $output .= "<h3>" . t("Moderation votes overview") . "</h3>";
  $header = array(t("votes"), t("weight"), t("operations"));

  $result = db_query("SELECT mid, vote, weight FROM {moderation_votes} ORDER BY weight");
  while ($vote = db_fetch_object($result)) {
    $rows[] = array($vote->vote, array("data" => $vote->weight, "align" => "center"), array("data" => l(t("edit"), "admin/comment/moderation/votes/$vote->mid"), "align" => "center"));
  }
  $output .= table($header, $rows);

  if ($mid) {
    $vote = db_fetch_object(db_query("SELECT vote, weight FROM {moderation_votes} WHERE mid = %d", $mid));
  }

  $output .= "<br /><h3>". (isset($mid) ? "Edit" : "Add new") ." moderation option</h3>";
  $form .= form_textfield(t("Vote"), "vote", $vote->vote, 32, 64, t("The name of this vote.  Example: 'off topic', 'excellent', 'sucky'."));
  $form .= form_textfield(t("Weight"), "weight", $vote->weight, 32, 64, t("Used to order votes in the comment control box; heavier sink."));
  if ($mid) {
    $form .= form_submit(t("Save vote"));
    $form .= form_submit(t("Delete vote"));
  }
  else {
    $form .= form_submit(t("Add new vote"));
  }

  $output .= form($form);

  return $output;
}

function comment_mod_filters($edit) {
  $op = $_POST["op"];

  $fid = arg(4);

  if ($op == t("Save threshold")) {
    db_query("UPDATE {moderation_filters} SET filter = '%s', minimum = %d WHERE fid = %d", $edit["filter"], $edit["minimum"], $fid);
    $fid = 0;
    $output = status("Saved threshold");
  }
  else if ($op == t("Delete threshold")) {
    db_query("DELETE FROM {moderation_filters} WHERE fid = %d", $fid);
    $fid = 0;
    $output = status("Deleted threshold");
  }
  else if ($op == t("Add new threshold")) {
    db_query("INSERT INTO {moderation_filters} (filter, minimum) VALUES ('%s', %d)", $edit["filter"], $edit["minimum"]);
    $fid = 0;
    $output = status("Added threshold");
  }

  $output .= "<h3>Comment threshold overview</h3>";

  $header = array(t("name"), t("minimum score"), t("operations"));

  $result = db_query("SELECT fid, filter, minimum FROM {moderation_filters} ORDER BY minimum");
  while ($filter = db_fetch_object($result)) {
    $rows[] = array($filter->filter, array("data" => $filter->minimum, "align" => "center"), array("data" => l(t("edit"), "admin/comment/moderation/filters/$filter->fid"), "align" => "center"));
  }
  $output .= table($header, $rows);

  if ($fid) {
    $filter = db_fetch_object(db_query("SELECT filter, fid, minimum FROM {moderation_filters} WHERE fid = %d", $fid));
  }

  $output .= "<br /><h3>". (isset($fid) ? "Edit" : "Add new") ." threshold</h3>";
  $form .= form_textfield(t("Threshhold name"), "filter", $filter->filter, 32, 64, t("The name of this threshold.  Example: 'good comments', '+1 comments', 'everything'."));
  $form .= form_textfield(t("Minimum score"), "minimum", $filter->minimum, 32, 64, t("Show all comments whose score is larger or equal to the provided minimal score. Range: -127 +128"));
  if ($fid) {
    $form .= form_submit(t("Save threshold"));
    $form .= form_submit(t("Delete threshold"));
  }
  else {
    $form .= form_submit(t("Add new threshold"));
  }

  $output .= form($form);

  return $output;
}


function comment_admin() {
  $op = $_POST["op"];
  $edit = $_POST["edit"];

  if (empty($op)) {
    $op = arg(2);
  }

  if ($op == t("moderation")) {
    $op = arg(3);
  }

  if (user_access("administer comments")) {
    switch ($op) {
     case "edit":
        print comment_admin_edit(arg(3));
        break;
      case "search":
        print search_type("comment", url("admin/comment/search"), $_POST["keys"]);
        break;
      case "votes":
      case t("Add new vote"):
      case t("Delete vote"):
      case t("Save vote"):
        if (user_access("administer moderation")) {
          print comment_mod_votes($edit);
        }
        break;
      case "roles":
      case t("Save scores"):
        if (user_access("administer moderation")) {
          print comment_mod_roles($edit);
        }
        break;
      case "matrix":
      case t("Submit votes"):
        if (user_access("administer moderation")) {
          print comment_mod_matrix($edit);
        }
        break;
      case "filters":
      case t("Add new threshold"):
      case t("Delete threshold"):
      case t("Save threshold"):
        if (user_access("administer moderation")) {
          print comment_mod_filters($edit);
        }
        break;
      case "delete":
        print comment_delete(array("cid" => arg(3)));
        break;
      case t("Delete"):
        print status(comment_delete($edit));
        print comment_admin_overview(0);
        break;
      case t("Submit"):
        print status(comment_save(check_query(arg(3)), $edit));
        print comment_admin_overview(0);
        break;
      default:
        if (arg(3) == 1) {
          print comment_admin_overview(1);
        }
        else {
          print comment_admin_overview(0);
        }
    }
  }
  else {
    print message_access();
  }
}

/*
** Renderer or visualization functions this can be optionally
** overridden by themes.
*/

function comment_mode_form($mode) {
  global $cmodes;

  foreach ($cmodes as $key => $value) {
    $options .= " <option value=\"$key\"". ($mode == $key ? " selected=\"selected\"" : "") .">". t($value) ."</option>\n";
  }

  return "<select name=\"mode\">$options</select>\n";
}

function comment_order_form($order) {
  global $corder;

  foreach ($corder as $key=>$value) {
    $options .= " <option value=\"$key\"". ($order == $key ? " selected=\"selected\"" : "") .">". t($value) ."</option>\n";
  }

  return "<select name=\"order\">$options</select>\n";
}

function comment_per_page_form($comments_per_page) {
  for ($i = 10; $i < 100; $i = $i + 20) {
    $options .= " <option value=\"$i\"". ($comments_per_page == $i ? " selected=\"selected\"" : "") .">". t("%a comments per page", array("%a" => $i)) ."</option>";
  }
  return "<select name=\"comments_per_page\">$options</select>\n";
}

function comment_threshold($threshold) {
  $result = db_query("SELECT fid, filter FROM {moderation_filters} ");
  $options .= " <option value=\"0\">". t("-- threshold --") ."</option>";
  while ($filter = db_fetch_object($result)) {
    $filters .= " <option value=\"$filter->fid\"". ($threshold == $filter->fid ? " selected=\"selected\"" : "") .">". t($filter->filter) ."</option>";
  }
  if ($filters) {
    return "<select name=\"threshold\">$filters</select>\n";
  }
}

function comment_controls($threshold = 1, $mode = 3, $order = 1, $comments_per_page = 50) {
  static $output;

  if (!$output) {
    $output .= comment_mode_form($mode);
    $output .= comment_order_form($order);
    $output .= comment_per_page_form($comments_per_page);
    $output .= comment_threshold($threshold);

    $output .= " ". form_submit(t("Save settings"));

    $output = form_item(t("Comment viewing options"), $output, t("Select your preferred way to display the comments and click 'Save settings' to activate your changes."));
  }

  return $output;
}

function comment_moderation_form($comment) {
  global $comment_votes, $user, $node;
  static $votes;

  $op = $_POST["op"];

  if ($op == "reply") {
    // preview comment:
    $output .= "&nbsp;";
  }
  else if ((comment_user_can_moderate($node)) && $user->uid != $comment->uid && !(comment_already_moderated($user->uid, $comment->users))) {
    // comment hasn't been moderated yet:

    if (!isset($votes)) {
      $result = db_query("SELECT v.mid, v.vote, r.value FROM {moderation_votes} v, {moderation_roles} r WHERE v.mid = r.mid AND r.rid = %d ORDER BY weight", $user->rid);
      $votes = array();
      while ($vote = db_fetch_object($result)) {
        if ($vote->value != 0) {
          $votes[] = $vote;
        }
      }
    }

    $options .= " <option value=\"\">". t("moderate comments") ."</option>\n";
    if ($votes) {
      foreach ($votes as $vote) {
        $options .= " <option value=\"$vote->mid\">$vote->vote</option>\n";
      }
    }

    if (user_access("administer comments")) {
      $options .= " <option value=\"\">". t("---") ."</option>\n";
      $options .= " <option value=\"offline\">". t("unpublish") ."</option>\n";
    }

    $output .= "<select name=\"moderation[$comment->cid]\">$options</select>\n";
  }

  return $output;
}

function comment($comment, $links = 0) {
  $output .= "<div class=\"comment\">";
  $output .= "<div class=\"subject\">$comment->subject". ($comment->new ? " ". theme("theme_mark") : "") ."</div>";
  $output .= "<div class=\"moderation\">". $comment->moderation ."</div>";
  $output .= "<div class=\"credit\">". t("by %a on %b", array("%a" => format_name($comment), "%b" => format_date($comment->timestamp))) ."</div>";
  $output .= "<div class=\"body\">". check_output($comment->comment) ."</div>";
  $output .= "<div class=\"links\">$links</div>";
  $output .= "</div>";
  print $output;
}

function comment_folded($comment) {
  print "<div class=\"comment-folded\"><span class=\"subject\">". l($comment->subject, "node/view/$comment->nid/$comment->cid#$comment->cid") ."</span> <span class=\"credit\">". t("by") . " " . format_name($comment) ."</span></div>";
}

function comment_flat_collapsed($comment, $threshold) {
  if (comment_visible($comment, $threshold)) {
    print comment_view($comment, "", 0);
  }
}

function comment_flat_expanded($comment, $threshold) {
  comment_view($comment, comment_links($comment, 0), comment_visible($comment, $threshold));
}

function comment_thread_min($comment, $threshold, $pid = 0) {
  if (comment_visible($comment, $threshold)) {
    print "<table border=\"0\" cellpadding=\"0\" cellspacing=\"0\" width=\"100%\"><tr><td width=\"". ($comment->depth * 25) ."\"><br /></td><td>\n";
    print comment_view($comment, "", 0);

    print "</td></tr></table>\n";
  }
}

function comment_thread_max($comment, $threshold, $level = 0) {
  /*
  ** We had quite a few browser specific issues: expanded comments below
  ** the top level got truncated on the right hand side.  A range of
  ** solutions have been proposed and tried but either the right margins of
  ** the comments didn't line up well, or the heavily nested tables made
  ** for slow rendering and cluttered HTML.  This is the best work-around
  ** in terms of speed and size.
  */

  if ($comment->depth) {
    print "<table border=\"0\" cellpadding=\"0\" cellspacing=\"0\" width=\"100%\"><tr><td width=\"". ($comment->depth * 25) ."\">&nbsp;</td><td>\n";
  }

  comment_view($comment, comment_links($comment, 0), comment_visible($comment, $threshold));

  if ($comment->depth) {
    print "</td></tr></table>\n";
  }
}

function comment_post_forbidden() {
  global $user;
  if ($user->uid) {
    return t("You can't post comments.");
  }
  else {
    return t("%login or %register to post comments", array("%login" => l(t("login"), "user/login"), "%register" => l(t("register"), "user/register")));
  }
}

/**
*** misc functions: helpers, privates, history, search
**/


function comment_visible($comment, $threshold = 0) {
  if ($comment->score >= $threshold) {
    return 1;
  }
  else {
    return 0;
  }
}

function comment_moderate() {
  global $user;

  $moderation = $_POST["moderation"];

  if ($moderation) {
    $result = db_query("SELECT mid, value FROM {moderation_roles} WHERE rid = %d", $user->rid);
    while ($mod = db_fetch_object($result)) {
      $votes[$mod->mid] = $mod->value;
    }

    $node = node_load(array("nid" => db_result(db_query("SELECT nid FROM {comments} WHERE cid = %d", key($moderation)))));

    if (user_access("administer comments") || comment_user_can_moderate($node)) {
      foreach ($moderation as $cid => $vote) {
        if ($vote) {
          $comment = db_fetch_object(db_query("SELECT * FROM {comments} WHERE cid = %d", $cid));
          $users = unserialize($comment->users);
          if ($user->uid != $comment->uid && !(comment_already_moderated($user->uid, $comment->users))) {
            $users[$user->uid] = $vote;
            $tot_score = 0;
            foreach ($users as $uid => $vote) {
              if ($uid) {
                $tot_score = $tot_score + $votes[$vote];
              }
              else {
                // vote 0 is the start value
                $tot_score = $tot_score + $vote;
              }
            }
            $new_score = round($tot_score / count($users));
            db_query("UPDATE {comments} SET score = '$new_score', users = '%s' WHERE cid = %d", serialize($users), $cid);

            /*
            ** Fire a hook
            */

            module_invoke_all("comment", "moderate", $cid, $vote);
          }
        }
      }
    }
  }
}

function comment_save_settings($mode, $order, $threshold, $comments_per_page) {
  global $user;

  if ($user->uid) {
    $user = user_save($user, array("mode" => $mode, "sort" => $order, "threshold" => $threshold, "comments_per_page" => $comments_per_page));
  }
}

function comment_num_all($nid) {
  static $cache;

  if (!isset($cache[$nid])) {
    $comment = db_fetch_object(db_query("SELECT COUNT(c.nid) AS number FROM {node} n INNER JOIN {comments} c ON n.nid = c.nid WHERE n.nid = %d AND c.status = 0 GROUP BY n.nid", $nid));
    $cache[$nid] = $comment->number ? $comment->number : 0;
  }
  return $cache[$nid];
}

function comment_num_replies($id) {
  static $cache;

  if (!isset($cache[$id])) {
    $result = db_query("SELECT COUNT(cid) FROM {comments} WHERE pid = %d AND status = 0", $id);
    $cache[$id] = $result ? db_result($result, 0) : 0;
  }

  return $cache[$id];
}

/**
 * get number of new comments for current user and specified node
 *
 * @param $nid       node-id to count comments for
 * @param $timestamp time to count from (defaults to time of last user access to node)
 */
function comment_num_new($nid, $timestamp = 0) {
  global $user;

  if ($user->uid) {
    /*
    ** Retrieve the timestamp at which the current user last viewed the
    ** specified node.
    */

    if (!$timestamp) {
      $timestamp = node_last_viewed($nid);
    }

    /*
    ** Use the timestamp to retrieve the number of new comments
    */

    $result = db_result(db_query("SELECT COUNT(c.cid) FROM {node} n INNER JOIN {comments} c ON n.nid = c.nid WHERE n.nid = %d AND timestamp > %d AND c.status = 0", $nid, $timestamp));

    return $result;
  }
  else {
    return 0;
  }

}

function comment_user_can_moderate($node) {
  global $user;
  return (user_access("moderate comments"));
  // TODO: || (($user->uid == $node->uid) && user_access("moderate comments in owned node")));
}

function comment_already_moderated($uid, $users) {
  $comment_users = unserialize($users);
  if (!$comment_users) {
    $comment_users = array();
  }
  return in_array($uid, array_keys($comment_users));
}

function comment_search($keys) {

  /*
  ** Return the results of performing a search using the indexed search
  ** for this particular type of node.
  **
  ** Pass an array to the "do_search" function which dictates what it
  ** will search through, and what it will search for
  **
  ** "keys"'s value is the keywords entered by the user
  **
  ** "type"'s value is used to identify the node type in the search
  ** index.
  **
  ** "select"'s value is used to relate the data from the specific nodes
  ** table to the data that the search_index table has in it, and the the
  ** do_search functino will rank it.
  **
  ** The select must always provide the following fields - lno, title,
  ** created, uid, name, count
  **
  ** The select statement may optionally provide "nid", which is a secondary
  ** identifier which is currently used byt the comment module.
  */

  $find = do_search(array("keys" => $keys, "type" => "comment", "select" => "select s.lno as lno, c.nid as nid, c.subject as title, c.timestamp as created, u.uid as uid, u.name as name, s.count as count FROM {search_index} s, {comments} c LEFT JOIN {users} u ON c.uid = u.uid WHERE s.lno = c.cid AND s.type = 'comment' AND c.status = 0 AND s.word like '%'"));

  return $find;
}

function comment_update_index() {

  /*
  ** Return an array of values to dictate how to update the search index
  ** for this particular type of node.
  **
  ** "last_update"'s value is used with variable_set to set the
  ** last time this node type (comment) had an index update run.
  **
  ** "node_type"'s value is used to identify the node type in the search
  ** index (commentt in this case).
  **
  ** "select"'s value is used to select the node id and text fields from
  ** the table we are indexing. In this case, we also check against the
  ** last run date for the comments update.
  */

  return array("last_update" => "comment_cron_last", "node_type" => "comment", "select" => "SELECT c.cid as lno, c.subject as text1, c.comment as text2 FROM {comments} c WHERE c.status = 0 AND timestamp > ". variable_get("comment_cron_last", 1));
}

function comment_nodeapi(&$node, $op, $arg = 0) {
  switch ($op) {
    case "settings":
      $output[t("comment")] = form_select("", "comment_$node->type", variable_get("comment_$node->type", 2), array("Disabled", "Read only", "Read/Write"));
      return $output;
    case "fields":
      return array("comment");
    case "form admin":
      if (user_access("administer comments")) {
        $selected = isset($node->comment) ? $node->comment : variable_get("comment_$node->type", 2);
        $output = form_radio(t("Disabled"), "comment", 0, ($selected == 0));
        $output .= form_radio(t("Read only"), "comment", 1, ($selected == 1));
        $output .= form_radio(t("Read/write"), "comment", 2, ($selected == 2));
        return form_item(t("Allow user comments"), $output);
      }
      break;
    case "validate":
      if (!user_access("administer nodes")) {
        // Force default for normal users:
        $node->comment = variable_get("comment_$node->type", 2);
      }
      break;
    case "delete":
      db_query("DELETE FROM {comments} WHERE nid = '$node->nid'");
      break;
  }
}

?>
