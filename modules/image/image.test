<?php
// $Id$

/**
 * @file
 * Image module tests.
 */


/**
 * TODO: Test the following functions.
 *
 * image.effects.inc:
 *   image_style_generate()
 *   image_style_create_derivative()
 *
 * image.module:
 *   image_style_load()
 *   image_style_save()
 *   image_style_delete()
 *   image_style_options()
 *   image_style_flush()
 *   image_effect_definition_load()
 *   image_effect_load()
 *   image_effect_save()
 *   image_effect_delete()
 *   image_filter_keyword()
 */

/**
 * Tests the functions for generating paths and URLs for image styles.
 */
class ImageStylesPathAndUrlUnitTest extends DrupalWebTestCase {
  protected $style_name;
  protected $image_info;
  protected $image_filepath;

  public static function getInfo() {
    return array(
      'name' => 'Image styles path and URL functions',
      'description' => 'Tests functions for generating paths and URLs to image styles.',
      'group' => 'Image',
    );
  }

  function setUp() {
    parent::setUp();

    $this->style_name = 'style_foo';
    image_style_save(array('name' => $this->style_name));

    // Create the directories for the styles.
    $status = file_check_directory($d = file_directory_path() . '/styles/' . $this->style_name, FILE_CREATE_DIRECTORY);
    $this->assertNotIdentical(FALSE, $status, t('Created the directory for the generated images for the test style.' ));

    // Create a working copy of the file.
    $file = reset($this->drupalGetTestFiles('image'));
    $this->image_info = image_get_info($file->filepath);
    $this->image_filepath = file_unmanaged_copy($file->filepath, NULL, FILE_EXISTS_RENAME);
    $this->assertNotIdentical(FALSE, $this->image_filepath, t('Created the without generated image file.'));
  }

  /**
   * Test image_style_path().
   */
  function testImageStylePath() {
    $actual = image_style_path($this->style_name, $this->image_filepath);
    $expected = file_directory_path() . '/styles/' . $this->style_name . '/' . basename($this->image_filepath);
    $this->assertEqual($actual, $expected, t('Got the path for a file.'));
  }

  /**
   * Test image_style_url().
   */
  function testImageStyleUrl() {
    // Get the URL of a file that has not been generated yet and try to access
    // it before image_style_url has been called.
    $generated_path = file_directory_path() . '/styles/' . $this->style_name . '/' . basename($this->image_filepath);
    $this->assertFalse(file_exists($generated_path), t('Generated file does not exist.'));
    $expected_generate_url = url('image/generate/' . $this->style_name . '/' . $this->image_filepath, array('absolute' => TRUE));
    $this->drupalGet($expected_generate_url);
    $this->assertResponse(403, t('Access to generate URL was denied.'));

    // Check that a generate URL is returned.
    $actual_generate_url = image_style_url($this->style_name, $this->image_filepath);
    $this->assertEqual($actual_generate_url, $expected_generate_url, t('Got the generate URL for a non-existent file.'));

    // Fetch the URL that generates the file while another process appears to
    // be generating the same file (this is signaled using cache_image).
    $cid = 'generate:' . $this->style_name . ':' . md5($this->image_filepath);
    cache_set($cid, $generated_path, 'cache_image');
    $this->drupalGet($expected_generate_url);
    $this->assertResponse(503, t('Service Unavailable response received.'));
    $this->assertTrue($this->drupalGetHeader('Retry-After'), t('Retry-After header received.'));
    cache_clear_all($cid, 'cache_image');

    // Fetch the URL that generates the file.
    $this->drupalGet($expected_generate_url);
    $this->assertTrue(file_exists($generated_path), t('Generated file was created.'));
    $this->assertRaw(file_get_contents($generated_path), t('URL returns expected file.'));
    $generated_image_info = image_get_info($generated_path);
    $this->assertEqual($this->drupalGetHeader('Content-Type'), $generated_image_info['mime_type'], t('Expected Content-Type was reported.'));
    $this->assertEqual($this->drupalGetHeader('Content-Length'), $generated_image_info['file_size'], t('Expected Content-Length was reported.'));

    // Check that the URL points directly to the generated file.
    $expected_generated_url = file_create_url($generated_path);
    $actual_generated_url = image_style_url($this->style_name, $this->image_filepath);
    $this->drupalGet($expected_generated_url);
    $this->assertEqual($actual_generated_url, $expected_generated_url, t('Got the download URL for an existing file.'));
    $this->assertRaw(file_get_contents($generated_path), t('URL returns expected file.'));
    $this->assertEqual($this->drupalGetHeader('Content-Type'), $this->image_info['mime_type'], t('Expected Content-Type was reported.'));
    $this->assertEqual($this->drupalGetHeader('Content-Length'), $this->image_info['file_size'], t('Expected Content-Length was reported.'));
  }
}

/**
 * Use the image_test.module's mock toolkit to ensure that the effects are
 * properly passing parameters to the image toolkit.
 */
class ImageEffectsUnitTest extends ImageToolkitTestCase {
  public static function getInfo() {
    return array(
      'name' => 'Image effects',
      'description' => 'Test that the image effects pass parameters to the toolkit correctly.',
      'group' => 'Image',
    );
  }

  function setUp() {
    parent::setUp('image_test');
    module_load_include('inc', 'image', 'image.effects');
  }

  /**
   * Test the image_effects() and image_effect_definitions() functions.
   */
  function testEffects() {
    $effects = image_effects();
    $this->assertEqual(count($effects), 1, t("Found core's effect."));

    $effect_definitions = image_effect_definitions();
    $this->assertEqual(count($effect_definitions), 6, t("Found core's effects."));
  }

  /**
   * Test the image_resize_effect() function.
   */
  function testResizeEffect() {
    $this->assertTrue(image_resize_effect($this->image, array('width' => 1, 'height' => 2)), t('Function returned the expected value.'));
    $this->assertToolkitOperationsCalled(array('resize'));

    // Check the parameters.
    $calls = image_test_get_all_calls();
    $this->assertEqual($calls['resize'][0][1], 1, t('Width was passed correctly'));
    $this->assertEqual($calls['resize'][0][2], 2, t('Height was passed correctly'));
  }

  /**
   * Test the image_scale_effect() function.
   */
  function testScaleEffect() {
    // @todo: need to test upscaling.
    $this->assertTrue(image_scale_effect($this->image, array('width' => 10, 'height' => 10)), t('Function returned the expected value.'));
    $this->assertToolkitOperationsCalled(array('resize'));

    // Check the parameters.
    $calls = image_test_get_all_calls();
    $this->assertEqual($calls['resize'][0][1], 10, t('Width was passed correctly'));
    $this->assertEqual($calls['resize'][0][2], 5, t('Height was based off aspect ratio and passed correctly'));
  }

  /**
   * Test the image_crop_effect() function.
   */
  function testCropEffect() {
    // @todo should test the keyword offsets.
    $this->assertTrue(image_crop_effect($this->image, array('anchor' => 'top-1', 'width' => 3, 'height' => 4)), t('Function returned the expected value.'));
    $this->assertToolkitOperationsCalled(array('crop'));

    // Check the parameters.
    $calls = image_test_get_all_calls();
    $this->assertEqual($calls['crop'][0][1], 0, t('X was passed correctly'));
    $this->assertEqual($calls['crop'][0][2], 1, t('Y was passed correctly'));
    $this->assertEqual($calls['crop'][0][3], 3, t('Width was passed correctly'));
    $this->assertEqual($calls['crop'][0][4], 4, t('Height was passed correctly'));
  }

  /**
   * Test the image_scale_and_crop_effect() function.
   */
  function testScaleAndCropEffect() {
    $this->assertTrue(image_scale_and_crop_effect($this->image, array('width' => 5, 'height' => 10)), t('Function returned the expected value.'));
    $this->assertToolkitOperationsCalled(array('resize', 'crop'));

    // Check the parameters.
    $calls = image_test_get_all_calls();
    $this->assertEqual($calls['crop'][0][1], 7.5, t('X was computed and passed correctly'));
    $this->assertEqual($calls['crop'][0][2], 0, t('Y was computed and passed correctly'));
    $this->assertEqual($calls['crop'][0][3], 5, t('Width was computed and passed correctly'));
    $this->assertEqual($calls['crop'][0][4], 10, t('Height was computed and passed correctly'));
  }

  /**
   * Test the image_desaturate_effect() function.
   */
  function testDesaturateEffect() {
    $this->assertTrue(image_desaturate_effect($this->image, array()), t('Function returned the expected value.'));
    $this->assertToolkitOperationsCalled(array('desaturate'));

    // Check the parameters.
    $calls = image_test_get_all_calls();
    $this->assertEqual(count($calls['desaturate'][0]), 1, t('Only the image was passed.'));
  }

  /**
   * Test the image_rotate_effect() function.
   */
  function testRotateEffect() {
    // @todo: need to test with 'random' => TRUE
    $this->assertTrue(image_rotate_effect($this->image, array('degrees' => 90, 'bgcolor' => '#fff')), t('Function returned the expected value.'));
    $this->assertToolkitOperationsCalled(array('rotate'));

    // Check the parameters.
    $calls = image_test_get_all_calls();
    $this->assertEqual($calls['rotate'][0][1], 90, t('Degrees were passed correctly'));
    $this->assertEqual($calls['rotate'][0][2], 0xffffff, t('Background color was passed correctly'));
  }
}
