<?php
// $Id$

function node_help() {
  global $mod;

  $output .= "<h3>Nodes</h3>The core of the Drupal system is the node. All of the contents of the system are placed in nodes, or extensions of nodes. ";
  $output .= "A base node contains:<dl>";
  $output .= "<dt>A Title</dt><dd>Up to 128 characters of text that titles the node.</dd>";
  $output .= "<dt>A Teaser</dt><dd>A small block of text that is meant to get you interested in the rest of node. Drupal automatically pulls a small amount of the body of the node to make the teaser (To configure how long the teaser will be ". l("click here","admin/system/modules/node") ."). The teaser can be changed if you don't like what Drupal grabs.</dd>";
  $output .= "<dt>The Body</dt><dd>The main text that comprises your content.</dd>";
  $output .= "<dt>A Type</dt><dd>What kind of node is this? Blog, book, forum, comment, unextended, etc.</dd>";
  $output .= "<dt>An Author</dt><dd>The author's name. It will either be \"anonymous\" or a valid user. You <i>cannot</i> set it to an arbitrary value.</dd>";
  $output .= "<dt>Authored on</dt><dd>The date it was written on.</dd>";
  $output .= "<dt>Changed</dt><dd>The last time this node was changed.</dd>";
  $output .= "<dt>Static on front page</dt><dd>The front page is configured to show the teasers from only a few of the total nodes you have on your site (To configure how many teasers ". l("click here","admin/system/modules/node") ."), but if you think a node is important enough that you want it to stay on the front page enable this.</dd>";
  $output .= "<dt>Allow user comments</dt><dd>A node can have comments, which are other nodes. These comments can be written by other users (Read-write), or only by admins (Read-only).</dd>";
  $output .= "<dt>Attributes</dt><dd>A way to sort nodes.</dd><dt>Revisions</dt><dd>Drupal has a revision system so that you can \"roll back\" to an older version of a node if the new version is not what you want.</dd>";
  $output .= "<dt>Promote to front page</dt><dd>To get people to look at the new stuff on your site you can choose to move it to the front page.</dd>";
  $output .= "<dt>In moderation queue</dt><dd>Drupal has a moderation system. If it is active, a node is in one of three states: approved and published, approved and unpublished, and awaiting approval. If you are moderating a node it should be in the moderation queue.</dd>";
  $output .= "<dt>Votes</dt><dd>If you are moderating a node this counts how many votes the node has gotten. Once a node gets a certain number of vote if will either be Approved, or Dropped (To setup the number of votes needed and the promote and dump scores ". l("click here","admin/system/modules/queue") .".)</a>.</dd>";
  $output .= "<dt>Score</dt><dd>The score of the node is gotten by the votes it is given.</dd>";
  $output .= "<dt>Users</dt><dd>The list of users who have voted on a moderated node.</dd>";
  $output .= "<dt>Published</dt><dd>When using Drupal's moderation system a node remains unpublished -- unavaliable to non-moderators -- until it is marked Published.</dd></dl>";
  $output .= "<p>Now that you know what is in a node, here are some of the types of nodes available.</p>";

  if ($mod == "admin") {
    foreach (module_list() as $name) {
      if (module_hook($name, "node") && $name != "node") {
        $output .= "<h3>". t("Node type: %module", array("%module" => module_invoke($name, "node", "name"))). "</h3>";
        $output .= module_invoke($name, "help");

      }
    }
  }
  return t($output);
}

function node_system($field){
  $system["description"] = t("The core that allows content to be submitted to the site.");
  $system["admin_help"] = t("Settings for the core of Drupal. Almost everything is a node so these settings will affect most of the site.");
  return $system[$field];
}

/*
** Accepts a DB result object which can be used to fetch node objects.
** Returns an HTML list suitable as content for a block.
*/
function node_title_list($result, $title = NULL) {
  while ($node = db_fetch_object($result)) {
    $number = module_invoke("comment", "num_all", $node->nid);
    $items[] = l($node->title, "node/view/$node->nid", array("title" => format_plural($number, "%count comment", "%count comments")));
  }

  return theme("theme_node_list", $items, $title);
}

function theme_node_list($items, $title = NULL) {
  return theme("theme_item_list", $items, $title);
}

// Update the 'last viewed' timestamp of the specified node for current user.
function node_tag_new($nid) {
  global $user;

  if ($user->uid) {
    $result = db_query("SELECT timestamp FROM history WHERE uid = %d AND nid = %d", $user->uid, $nid);
    if (db_fetch_object($result)) {
      db_query("UPDATE history SET timestamp = %d WHERE uid = %d AND nid = %d", time(), $user->uid, $nid);
    }
    else {
      db_query("INSERT INTO history (uid, nid, timestamp) VALUES (%d, %d, %d)", $user->uid, $nid, time());
    }
  }
}

/*
** Retrieves the timestamp at which the current user last viewed the
** specified node.
*/
function node_last_viewed($nid) {
  global $user;

  $history = db_fetch_object(db_query("SELECT timestamp FROM history WHERE uid = '$user->uid' AND nid = %d", $nid));
  return ($history->timestamp ? $history->timestamp : 0);
}

/**
 * Determines whether the supplied timestamp is newer than the user's last view of a given node
 *
 * @param $nid       node-id twhose history supplies the 'last viewed' timestamp
 * @param $timestamp time which is compared against node's 'last veiwed' timestamp
*/
function node_is_new($nid, $timestamp) {
  global $user;
  static $cache;

  if (!isset($cache[$nid])) {
    if ($user->uid) {
      $history = db_fetch_object(db_query("SELECT timestamp FROM history WHERE uid = %d AND nid = %d", $user->uid, $nid));
      $cache[$nid] = $history->timestamp ? $history->timestamp : 0;
    }
    else {
      $cache[$nid] = time();
    }
  }

  if ($timestamp > $cache[$nid]) {
    return 1;
  }
  else {
    return 0;
  }
}

function node_teaser($body) {

  $size = variable_get("teaser_length", 600);

  /*
  ** If the size is zero, teasers are disabled so we
  ** return the entire body.
  */

  if ($size == 0) {
    return $body;
  }

  /*
  ** If we have a short body, return the entire body:
  */

  if (strlen($body) < $size) {
    return $body;
  }

  /*
  ** If a valid delimiter has been specified, use it to
  ** chop of the teaser.  The delimiter can be outside
  ** the allowed range but no more than a factor two.
  */

  $delimiter = strpos($body, "<!--break-->");
  if ($delimiter > 0) {
    return substr($body, 0, $delimiter);
  }

  /*
  ** In some cases no delimiter has been specified (eg.
  ** when posting using the Blogger API) in which case
  ** we try to split at paragraph boundaries.
  */

  if ($length = strpos($body, "<br />", $size)) {
    return substr($body, 0, $length);
  }

  if ($length = strpos($body, "<br>", $size)) {
    return substr($body, 0, $length);
  }

  if ($length = strpos($body, "</p>", $size)) {
    return substr($body, 0, $length);
  }

  if ($length = strpos($body, "\n", $size)) {
    return substr($body, 0, $length);
  }

  /*
  ** When even the first paragraph is too long, try to
  ** split at the end of the next sentence.
  */

  if ($length = strpos($body, ". ", $size)) {
    return substr($body, 0, $length + 1);
  }

  if ($length = strpos($body, "! ", $size)) {
    return substr($body, 0, $length + 1);
  }

  if ($length = strpos($body, "? ", $size)) {
    return substr($body, 0, $length + 1);
  }

  /*
  ** Nevermind, we split it the hard way ...
  */

  return substr($body, 0, $size);
}

function node_invoke(&$node, $hook, $arg = 0) {
  if (is_array($node)) {
    $function = $node["type"] ."_$hook";
  }
  else if (is_object($node)) {
    $function = $node->type ."_$hook";
  }
  else if (is_string($node)) {
    $function = $node ."_$hook";
  }

  if (function_exists($function)) {
    return ($arg ? $function($node, $arg) : $function($node));
  }
}

function node_invoke_all(&$node, $hook, $op, $arg = 0) {
  $return = array();
  foreach (module_list() as $name) {
    if ((module_hook($name, "node") || module_hook($name, "nodeapi")) && module_hook($name, $hook)) {
      $function = $name ."_". $hook;
      $result = $function($node, $op, $arg);
      if (isset($result)) {
        $return = array_merge($return, $result);
      }
    }
  }
  return $return;
}

function node_load($conditions, $revision = -1) {

  /*
  ** Turn the conditions into a query:
  */

  foreach ($conditions as $key => $value) {
    $cond[] = "n.". check_query($key) ." = '". check_query($value) ."'";
  }

  /*
  ** Retrieve the node:
  */

  $node = db_fetch_object(db_query("SELECT n.*, u.uid, u.name FROM node n LEFT JOIN users u ON u.uid = n.uid WHERE ". implode(" AND ", $cond)));

  /*
  ** Unserialize the revisions field:
  */

  if ($node->revisions) {
    $node->revisions = unserialize($node->revisions);
  }

  /*
  ** Call the node specific callback (if any) and piggy-back the
  ** results to the node or overwrite some values:
  */

  if ($extra = module_invoke($node->type, "load", $node)) {
    foreach ($extra as $key => $value) {
      $node->$key = $value;
    }
  }

  /*
  ** Return the desired revision
  */
  if ($revision != -1 && isset($node->revisions[$revision])) {
    $node = $node->revisions[$revision]["node"];
  }

  return $node;
}

function node_save($node) {

  /*
  ** Fetch fields to save to node table:
  */
  $fields = node_invoke_all($node, "nodeapi", "fields");

  /*
  ** Serialize the revisions field:
  */

  if ($node->revisions) {
    $node->revisions = serialize($node->revisions);
  }

  /*
  ** Apply filters to some default node fields:
  */

  if (empty($node->nid)) {

    /*
    ** Insert a new node:
    */

    // Set some required fields:
    if (!$node->created) {
      $node->created = time();
    }
    $node->changed = time();
    $node->nid = db_next_id("node_nid");

    // Prepare the query:
    foreach ($node as $key => $value) {
      if (in_array($key, $fields)) {
        $k[] = check_query($key);
        $v[] = "'". check_query($value) ."'";
      }
    }

    // Insert the node into the database:
    db_query("INSERT INTO node (". implode(", ", $k) .") VALUES (". implode(", ", $v) .")");

    // Call the node specific callback (if any):
    node_invoke($node, "insert");
    node_invoke_all($node, "nodeapi", "insert");
  }
  else {

    /*
    ** Update an existing node:
    */

    // Set some required fields:
    $node->changed = time();

    // Prepare the query:
    foreach ($node as $key => $value) {
      if (in_array($key, $fields)) {
        $q[] = check_query($key) ." = '". check_query($value) ."'";
      }
    }

    // Update the node in the database:
    db_query("UPDATE node SET ". implode(", ", $q) ." WHERE nid = '$node->nid'");

    // Call the node specific callback (if any):
    node_invoke($node, "update");
    node_invoke_all($node, "nodeapi", "update");
  }

  /*
  ** Clear the cache so an anonymous poster can see the node being
  ** added or updated.
  */

  cache_clear_all();

  /*
  ** Return the node ID:
  */

  return $node->nid;

}

function node_view($node, $main = 0) {


  $node = array2object($node);

  /*
  ** Remove the delimiter (if any) that seperates the teaser from the
  ** body. TODO: this strips legitimate uses of '<!--break-->' also.
  */

  $node->body = str_replace("<!--break-->", "", $node->body);

  /*
  ** The "view" hook can be implemented to overwrite the default function
  ** to display nodes.
  */

  if (module_hook($node->type, "view")) {
    node_invoke($node, "view", $main);
  }
  else {

    /*
    ** Default behavior:
    */

    $node->teaser = check_output($node->teaser);
    $node->body = check_output($node->body);

    theme("node", $node, $main);
  }
}

function node_show($node, $cid) {

  if (node_access("view", $node)) {

    node_view($node);

    if (function_exists("comment_render") && $node->comment) {
      comment_render($node, $cid);
    }

    /*
    ** Update the history table, stating that this user viewed this node.
    */

    node_tag_new($node->nid);
  }
}

function node_access($op, $node = 0) {

  if (user_access("administer nodes")) {
    return 1;
  }

  /*
  ** Convert the node to an object if necessary:
  */

  $node = array2object($node);

  /*
  ** Construct a function:
  */

  if ($node->type) {
    $type = $node->type;
  }
  else {
    $type = $node;
  }

  $function = $type ."_access";

  if (function_exists($function)) {
    return $function($op, $node);
  }
  else {
    return 0;
  }
}

function node_perm() {
  return array("administer nodes", "access content");
}

function node_search($keys) {

  // Return the results of performing a search using the indexed search
  // for this particular type of node.
  //
  // Pass an array to the "do_search" function which dictates what it
  // will search through, and what it will search for
  //
  // "keys"'s value is the keywords entered by the user
  //
  // "type"'s value is used to identify the node type in the search
  // index.
  //
  // "select"'s value is used to relate the data from the specific nodes
  // table to the data that the search_index table has in it, and the the
  // do_search functino will rank it.
  //
  // The select must always provide the following fields - lno, title,
  // created, uid, name, count
  //
  $find = do_search(array("keys" => $keys, "type" => "node", "select" => "select s.lno as lno, n.title as title, n.created as created, u.uid as uid, u.name as name, s.count as count FROM search_index s, node n LEFT JOIN users u ON n.uid = u.uid WHERE s.lno = n.nid AND s.type = 'node' AND s.word like '%' AND n.status = 1"));

  return $find;
}

function node_settings() {
  $output .= form_select(t("Number of posts on main page"), "default_nodes_main", variable_get("default_nodes_main", 10), array(1 => 1, 2 => 2, 3 => 3, 4 => 4, 5 =>  5, 6 => 6, 7 => 7, 8 => 8, 9 => 9, 10 => 10, 15 => 15, 20 => 20, 25 => 25, 30 => 30), t("The default maximum number of posts to display per page on overview pages such as the main page."));
  $output .= form_select(t("Length of trimmed posts"), "teaser_length", variable_get("teaser_length", 600), array(0 => t("Unlimited"), 200 => t("200 characters"), 400 => t("400 characters"), 600 => t("600 characters"), 800 => t("800 characters"), 1000 => t("1000 characters"), 1200 => t("1200 characters"), 1400 => t("1400 characters"), 1600 => t("1600 characters"), 1800 => t("1800 characters"), 2000 => t("2000 characters")), t("The maximum number of characters used in the trimmed version of a post.  Drupal will use this setting to determine at which offset long posts should be trimmed.  The trimmed version of a post is typically used as a teaser when displaying the post on the main page, in XML feeds, etc.  To disable teasers, set to 'Unlimited'."));
  $output .= form_select(t("Preview post"), "node_preview", variable_get("node_preview", 0), array(t("Optional"), t("Required")), t("Must users preview posts before submitting?"));
  return $output;
}

function node_conf_filters() {
  $output .= form_select(t("Filter HTML tags"), "filter_html", variable_get("filter_html", 0), array(t("Disabled"), t("Enabled")), t("Filter HTML and PHP tags in user-contributed content."));
  $output .= form_textfield(t("Allowed HTML tags"), "allowed_html", variable_get("allowed_html", "<a> <b> <dd> <dl> <dt> <i> <li> <ol> <u> <ul>"), 64, 255, t("If enabled, optionally specify tags which should not be stripped.  'STYLE' attributes, 'ON*' attributes and unclosed tags are always stripped."));
  $output .= form_select(t("Rewrite old URLs"), "rewrite_old_urls", variable_get("rewrite_old_urls", 0), array(t("Disabled"), t("Enabled")), t("The introduction of 'clean URLs' in Drupal 4.2.0 breaks internal URLs that date back from Drupal 4.1.0 and before.  If enabled, this filter will attempt to rewrite the old style URLs to avoid broken links.  If <code>mod_rewrite</code> is available on your system, use the rewrite rules in Drupal's <code>.htaccess</code> file instead as these will also correct external referrers."));
  $output .= "<hr />";
  return $output;
}

function node_filter_html($text) {
  $text = strip_tags($text, variable_get("allowed_html", ""));
  return $text;
}

function node_filter_link($text) {
  $pat = '\[{2}([^\|]+)(\|([^\|]+)?)?\]{2}';                   // [link|description]
  return ereg_replace($pat, $dst, $text);
}

function node_comment_mode($nid) {
  static $comment_mode;
  if (!isset($comment_mode[$nid])) {
    $comment_mode[$nid] = db_result(db_query("SELECT comment FROM node WHERE nid = %d", $nid));
  }
  return $comment_mode[$nid];
}

function node_filter($text) {
  if (variable_get("filter_html", 0)) {
    $text = node_filter_html($text);
  }

  if (variable_get("rewrite_old_urls", 0)) {
    $text = rewrite_old_urls($text);
  }

  return trim($text);
}

function node_link($type, $node = 0, $main = 0) {

  $links = array();

  if ($type == "page") {
    $links[] = l(t("submit"), "node/add", array("title" => t("Submit or suggest new content.")));
  }

  if ($type == "node") {
    if ($node->links) {
      $links = $node->links;
    }

    if ($main == 1 && $node->teaser && $node->teaser != $node->body) {
      $links[] = l(t("read more"), "node/view/$node->nid", array("title" => t("Read the rest of this posting.")));
    }

    if (user_access("administer nodes")) {
       $links[] = l(t("administer"), "admin/node/edit/$node->nid", array("title" => t("Administer this node.")));
    }
  }

  if ($type == "admin" && user_access("administer nodes")) {
    $help["overview"] = t("Below is a list of all of the nodes in your site. Other forms of content are listed elsewhere (e.g. ". l("comments", "admin/comment") .").<br />Clicking a title views that node, while clicking an author's name edits their user information.<br />Other node-related tasks are available from the menu on the left.");
    $help["post-overview"] = t("Click on <a href=\"%nup\">new or updated posts</a> to see your latest nodes, or <a href=\"%queue\">approval queue</a> to approve new messages.", array("%nup" => url("admin/node/nodes/0"), "%queue" => url("admin/node/nodes/1")));
    $help["new-update"] = t("Below is a list of the latest nodes in your site. Clicking a title views that node, while clicking an author's name edits their user information.");
    $help["queue"] = t("Below is a list of the node in your site that await approval. To approve a node click on <b>edit node</b> and then change its moderation status to <b>approved</b>.<br />Clicking a title views that node, while clicking an author's name edits their user information.");
    $help["search"] = t("Enter a simple pattern to search for a post. This can include the wildcard character *.<br />For example, a search for \"br*\" might return \"bread bakers\", \"our daily bread\" and \"brenda\".");
    $help["setting"] = t("This pages lets you set the defaults used during creation of nodes for all the different node types.<br /><b>comment:</b> Read/write setting for comments.<br /><b>publish:</b> Is this node publicly viewable, has it been published?<br /><b>promote:</b> Is this node to be promoted to the front page?<br /><b>moderate:</b> Does this node need approval before it can be viewed?<br /><b>static:</b> Is this node always visible on the front page?<br /><b>revision:</b> Will this node go into the revision system allowing multiple versions to be saved?");

    menu("admin/node", "content management", "node_admin", $help["overview"]);
    menu("admin/node/nodes", "post overview", NULL, $help["post-overview"]);
    menu("admin/node/nodes/0", "new or updated posts", "node_admin", $help["new-update"], 0);
    menu("admin/node/nodes/1", "approval queue", "node_admin", $help["queue"], 1);
    menu("admin/node/search", "search posts", "node_admin", $help["search"], 8);
    menu("admin/node/help", "help", "node_help", NULL, 9);
    menu("admin/node/edit", "edit node", "node_admin", NULL, 0, 1);
    menu("admin/node/settings", "content settings", "node_admin", $help["setting"], 8);
  }

  return $links;
}

function node_admin_edit($node) {

  if (is_numeric($node)) {
    $node = node_load(array("nid" => $node));
  }

  /*
  ** Edit node:
  */

  $output .= "<h3>". t("Edit %module", array("%module" => module_invoke($node->type, "node", "name"))) ."</h3>";

  $output .= node_form($node);

  /*
  ** Edit revisions:
  */

  if ($node->revisions) {
    $output .= "<h3>". t("Edit revisions") ."</h3>";
    $output .= "<table border=\"1\" cellpadding=\"2\" cellspacing=\"2\">";
    $output .= " <tr><th>". t("older revisions") ."</th><th colspan=\"3\">". t("operations") ."</th></tr>";
    foreach ($node->revisions as $key => $revision) {
      $output .= " <tr><td>". t("revision #%r revised by %u on %d", array("%r" => $key, "%u" => format_name(user_load(array("uid" => $revision["uid"]))), "%d" => format_date($revision["timestamp"], "small"))) . ($revision["history"] ? "<br /><small>". $revision["history"] ."</small>" : "") ."</td><td>". l(t("view revision"), "node/view/$node->nid", array(), "revision=$key") ."</td><td>". l(t("rollback revision"), "admin/node/rollback+revision/$node->nid/$key") ."</td><td>". l(t("delete revision"), "admin/node/delete+revision/$node->nid/$key") ."</td></tr>";
    }
    $output .= "</table>";
  }

  /*
  ** Display the node form extensions:
  */

  foreach (module_list() as $name) {
    $output .= module_invoke($name, "node_link", $node);
  }

  return $output;

}

function node_admin_nodes() {

  $query = arg(3);
  $queries = array("ORDER BY n.changed DESC", "WHERE n.status = 0 OR n.moderate = 1 ORDER BY n.changed DESC");

  $result = pager_query("SELECT n.*, u.name, u.uid FROM node n LEFT JOIN users u ON n.uid = u.uid ". $queries[$query ? $query : 0], 50);

  $header = array(t("title"), t("type"), t("author"), t("status"), array("data" => t("operations"), "colspan" => 2));

  while ($node = db_fetch_object($result)) {
    $rows[] = array(l($node->title, "node/view/$node->nid") ." ". (node_is_new($node->nid, $node->changed) ? theme_mark() : ""), module_invoke($node->type, "node", "name"), format_name($node), ($node->status ? t("published") : t("not published")), l(t("edit node"), "admin/node/edit/$node->nid"), l(t("delete node"), "admin/node/delete/$node->nid"));
  }

  if ($pager = pager_display(NULL, 50, 0, "admin")) {
    $rows[] = array(array("data" => $pager, "colspan" => 6));
  }

  return table($header, $rows);
}

/*
**
*/

function node_admin_settings($edit) {
  $op = $_POST["op"];

  if ($op == t("Save configuration")) {
    /*
    ** Save the configuration options:
    */

    foreach ($edit as $name => $value) {
      variable_set($name, $value);
    }
    $output = status(t("the content settings have been saved."));
  }

  if ($op == t("Reset to defaults")) {
    /*
    ** Reset the configuration options to their default value:
    */

    foreach ($edit as $name => $value) {
      variable_del($name);
    }
    $output = status(t("the content settings have been reset to their default values."));
  }

  $header = array_merge(array(t("type")), array_keys(node_invoke_all($node, "nodeapi", "settings")));
  foreach (module_list() as $name) {
    if (module_hook($name, "node")) {
      $node->type = $name;
      $cols = array();
      foreach (node_invoke_all($node, "nodeapi", "settings") as $setting) {
        $cols[] = array("data" => $setting, "align" => "center", "width" => 55);
      }
      $rows[] = array_merge(array(module_invoke($name, "node", "name")), $cols);
    }
  }

  $output .= table($header, $rows);

  /* This is an idea for the future.
  foreach (module_list() as $name) {
    if (module_hook($name, "node")) {
      $node->type = $name;

      // Create table() data:
      $header = array_keys(node_invoke_all($node, "nodeapi", "settings"));
      $cols = array();
      foreach (node_invoke_all($node, "nodeapi", "settings") as $setting) {
        $cols[] = array("data" => $setting, "align" => "center", "width" => 75);
      }

      $output .= "<h2>". module_invoke($name, "node", "name") ."</h2>";
      $output .= table($header, array($cols));
      $output .= "<br /><br />";
    }
  }
  */

  $output .= form_submit(t("Save configuration"));
  $output .= form_submit(t("Reset to defaults"));

  print form($output);

}

/*
** Return the revision with the specified revision number.
*/

function node_revision_load($node, $revision) {
  return $node->revisions[$revision]["node"];
}

/*
** Create and return a new revision of the given node.
*/

function node_revision_create($node) {
  global $user;

  /*
  ** 'revision' is the name of the field used to indicicate that we
  ** have to create a new revision of a node.
  */

  if ($node->nid && $node->revision) {
    $prev = node_load(array("nid" => $node->nid));
    $node->revisions = $prev->revisions;
    unset($prev->revisions);
    $node->revisions[] = array("uid" => $user->uid, "timestamp" => time(), "node" => $prev, "history" => $node->history);
  }

  return $node;
}

/*
** Roll-back to the revision with the specified revision number.
*/

function node_revision_rollback($node, $revision) {
  global $user;

  /*
  ** Extract the specified revision:
  */

  $rev = $node->revisions[$revision]["node"];

  /*
  ** Inherit all the past revisions:
  */

  $rev->revisions = $node->revisions;

  /*
  ** Save the original/current node:
  */

  $rev->revisions[] = array("uid" => $user->uid, "timestamp" => time(), "node" => $node);

  /*
  ** Remove the specified revision:
  */

  unset($rev->revisions[$revision]);

  /*
  ** Save the node:
  */

  foreach ($node as $key => $value) {
    $filter[] = $key;
  }

  node_save($rev, $filter);

  watchdog("special", "$node->type: rollbacked to revision #$revision of '$node->title'");
}

/*
** Delete the revision with specified revision number.
*/

function node_revision_delete($node, $revision) {

  unset($node->revisions[$revision]);

  node_save($node, array("nid", "revisions"));

  watchdog("special", "$node->type: removed revision #$revision of '$node->title'");
}

/*
** Return a list of all the existing revision numbers.
*/

function node_revision_list($node) {
  if (is_array($node->revisions)) {
    return array_keys($node->revisions);
  }
  else {
    return array();
  }
}

function node_admin() {
  $op = $_POST["op"];
  $edit = $_POST["edit"];

  if (user_access("administer nodes")) {

    if (empty($op)) {
      $op = arg(2);
    }

    /*
    ** Compile a list of the administrative links:
    */
    switch ($op) {
      case "search":
        print search_type("node", url("admin/node/search"), $_POST["keys"]);
        break;
      case "edit":
        print node_admin_edit(arg(3));
        break;
      case "delete":
        print node_delete(array("nid" => arg(3)));
        break;
      case "rollback revision":
        print node_revision_rollback(node_load(array("nid" => arg(3))), arg(4));
        print node_admin_edit(arg(3));
        break;
      case "delete revision":
        print node_revision_delete(node_load(array("nid" => arg(3))), arg(4));
        print node_admin_edit(arg(3));
        break;
      case t("Preview"):
        $edit = node_validate($edit, $error);
        print node_preview($edit, $error);
        break;
      case t("Submit"):
        print node_submit($edit);
        break;
      case t("Delete"):
        print node_delete($edit);
        break;
      case t("Save configuration"):
      case t("Reset to defaults"):
      case "settings":
        print node_admin_settings($edit);
        break;
      default:
        print node_admin_nodes();
    }
  }
  else {
    print message_access();
  }
}

function node_block($op = "list", $delta = 0) {

  if ($op == "list") {
    $blocks[0]["info"] = t("Syndicate");
    return $blocks;
  }
  else {
    $block["subject"] = t("Syndicate");
    $block["content"] = "<div style=\"text-align: center;\">". l("<img src=\"". theme("image", "xml.gif") ."\" width=\"36\" height=\"14\" style=\"border: 0px;\" alt=\"XML\" title=\"XML\" />", "node/feed", array("title" => t("Read the XML version of this page."))) ."</div>";

    return $block;
  }
}

function node_feed($nodes = 0, $channel = array()) {
  global $base_url, $languages;

  /*
  ** A generic function for generating RSS feeds from a set of nodes.
  **   - $nodes should be an object as returned by db_query() which contains
  **     the nid field.
  **   - $channel is an associative array containing title, link, and
  **     description keys.
  */

  if (!$nodes) {
    $nodes = db_query_range("SELECT nid FROM node WHERE promote = '1' AND status = '1' ORDER BY created DESC", 0, 15);
  }

  while ($node = db_fetch_object($nodes)) {
    $item = node_load(array("nid" => $node->nid));
    $link = url("node/view/$item->nid");
    $items .= format_rss_item($item->title, $link, ($item->teaser ? $item->teaser : $item->body));
  }

  $output .= "<?xml version=\"1.0\" encoding=\"utf-8\"?>\n";
  $output .= "<!DOCTYPE rss [<!ENTITY % HTMLlat1 PUBLIC \"-//W3C//ENTITIES Latin 1 for XHTML//EN\" \"http://www.w3.org/TR/xhtml1/DTD/xhtml-lat1.ent\">]>\n";
  if (!$channel["version"]) $channel["version"] = "0.91";
  if (!$channel["title"]) $channel["title"] = variable_get("site_name", "drupal") ." - ". variable_get("site_slogan", "");
  if (!$channel["link"]) $channel["link"] = $base_url;
  if (!$channel["description"]) $channel["description"] = variable_get("site_mission", "");
  foreach ($languages as $key => $value) break;
  if (!$channel["language"]) $channel["language"] = $key ? $key : "en";
  $output .= "<rss version=\"". $channel["version"] . "\">\n";
  $output .= format_rss_channel($channel["title"], $channel["link"], $channel["description"], $items, $channel["language"]);
  $output .= "</rss>\n";

  header("Content-Type: text/xml");
  print $output;
}

function node_validate($node, &$error) {
  global $user;
  $error = array();

  /*
  ** Convert the node to an object if necessary:
  */

  $node = array2object($node);

  /*
  ** Validate the title field:
  */

  if (isset($node->title)) {
    $node->title = strip_tags($node->title);
    if (!$node->title) {
      $error["title"] = theme("theme_error", t("You have to specify a valid title."));
    }
  }

  /*
  ** Common default values:
  */

  $node->teaser = node_teaser($node->body);

  /*
  ** Create a new revision when required:
  */

  $node = node_revision_create($node);

  if (user_access("administer nodes")) {

    /*
    ** Setup default values if required:
    */

    if (!$node->created) {
      $node->created = time();
    }

    if (!$node->date) {
      $node->date = date("M j, Y g:i a", $node->created);
    }

    if (!is_numeric($node->status)) {
      $node->status = 1;
    }

    /*
    ** Validate the "authored by"-field:
    */

    if (empty($node->name)) {
      /*
      ** The use of empty() is mandatory in the context of usernames
      ** as the empty string denotes the anonymous user.  In case we
      ** are dealing with an anomymous user we set the user ID to 0.
      */
      $node->uid = 0;
    }
    else if ($account = user_load(array("name" => $node->name))) {
      $node->uid = $account->uid;
    }
    else {
      $error["name"] = theme("theme_error", t("The name '%u' does not exist.", array ("%u" => $node->name)));
    }

    /*
    ** Validate the "authored on"-field:
    */

    if (strtotime($node->date) > 1000) {
      $node->created = strtotime($node->date);
    }
    else {
      $error["date"] = theme("theme_error", t("You have to specifiy a valid date."));
    }
  }
  else {
    // Validate for normal users:
    $node->uid = $user->uid ? $user->uid : 0;
    // Force defaults in case people modify the form:
    $node->status = variable_get("node_status_$node->type", 1);
    $node->promote = variable_get("node_promote_$node->type", 1);
    $node->moderate = variable_get("node_moderate_$node->type", 0);
    $node->static = variable_get("node_static_$node->type", 0);
    $node->revision = variable_get("node_revision_$node->type", 0);
    unset($node->created);
  }

  /*
  ** Do node type specific validation checks.
  */

  $result = node_invoke($node, "validate");
  $error = $error + (is_array($result) ? $result : array()) + node_invoke_all($node, "nodeapi", "validate");

  return $node;
}


function node_form($edit, $error = NULL) {

  /*
  ** Save the referer.  We record where the user came from such that we
  ** can redirect him after having completed the node forms.
  */

  referer_save();

  /*
  ** Validate the node:
  */

  if (!$error) {
    /* Only validate if we don't already know the errors. */
    $edit = node_validate($edit, $error);
  }

  // Prepend extra node form:
  $form = implode("", node_invoke_all($edit, "nodeapi", "form pre", $error));

  /*
  ** Get the node specific bits:
  */

  $function = $edit->type ."_form";
  if (function_exists($function)) {
    $form .= $function($edit, $help, $error, $param);
  }

  // Append extra node form:
  $form .= implode("", node_invoke_all($edit, "nodeapi", "form post", $error));

  /*
  ** Add the help text:
  */

  if ($help) {
    $output .= "<p>$help</p>";
  }

  $output .= "<div class=\"node-form\">";

  /*
  ** Add the admin specific parts:
  */

  if (user_access("administer nodes")) {
    $output .= "<div class=\"admin\">";
    $output .= "<div class=\"authored\">";
    $output .= form_textfield(t("Authored by"), "name", $edit->name, 20, 60, $error["name"]);
    $output .= form_textfield(t("Authored on"), "date", $edit->date, 20, 25, $error["date"]);
    $output .= "</div>";

    $options .= form_checkbox(t("Published"), "status", 1, isset($edit->status) ? $edit->status : variable_get("node_status_$edit->type", 1));
    $options .= form_checkbox(t("In moderation queue"), "moderate", 1, isset($edit->moderate) ? $edit->moderate : variable_get("node_moderate_$edit->type", 0));
    $options .= form_checkbox(t("Promoted to front page"), "promote", 1, isset($edit->promote) ? $edit->promote : variable_get("node_promote_$edit->type", 1));
    $options .= form_checkbox(t("Static on front page"), "static", 1, isset($edit->static) ? $edit->static : variable_get("node_static_$edit->type", 0));
    $options .= form_checkbox(t("Create new revision"), "revision", 1, isset($edit->revision) ? $edit->revision : variable_get("node_revision_$edit->type", 0));

    $output .= "<div class=\"options\">";
    $output .= form_item(t("Options"), $options);
    $output .= "</div>";

    $extras .= implode("</div><div class=\"extra\">", node_invoke_all($edit, "nodeapi", "form admin"));
    $output .= $extras ? "<div class=\"extra\">$extras</div></div>" : "</div>";
  }

  /*
  ** Add the default fields:
  */
  $output .= "<div class=\"standard\">";
  $output .= form_textfield(t("Title"), "title", $edit->title, 60, 64, $error["title"]);

  /*
  ** Add the node specific fields:
  */

  $output .= $form;

  /*
  ** Add the hidden fields:
  */

  if ($edit->nid) {
    $output .= form_hidden("nid", $edit->nid);
  }

  if (isset($edit->uid)) {
      /*
      ** The use of isset() is mandatory in the context of user IDs as uid
      ** 0 denotes the anonymous user.
      */
    $output .= form_hidden("uid", $edit->uid);
  }

  if ($edit->created) {
    $output .= form_hidden("created", $edit->created);
  }

  $output .= form_hidden("type", $edit->type);

  /*
  ** Add the buttons:
  */

  $output .= form_submit(t("Preview"));

  if ($edit->title && $edit->type && !$error) {
    $output .= form_submit(t("Submit"));
  }
  elseif (!variable_get("node_preview", 0)) {
    $output .= form_submit(t("Submit"));
  }

  if ($edit->nid && node_access("delete", $edit)) {
    $output .= form_submit(t("Delete"));
  }

  $output .= "</div></div>";

  return form($output, ($param["method"] ? $param["method"] : "post"), $param["action"], $param["options"]);
}

function node_add($type) {
  global $user;

  $edit = $_POST["edit"];

  /*
  ** If a node type has been specified, validate it existence.  If no
  ** (valid) node type has been provied, display a node type overview.
  */

  if ($type && node_access("create", $type)) {
    // Initialize settings:
    $node = array("uid" => $user->uid, "name" => $user->name, "type" => $type);

    /*
    ** Allow the following fields to be initialized via $_GET (eg. for use
    ** with a "blog it" bookmarklet):
    */
    foreach (array("title", "teaser", "body") as $field) {
      if ($_GET["edit"][$field]) {
        $node[$field] = $_GET["edit"][$field];
      }
    }
    $output = node_form($node);
  }
  else {

    /*
    ** Compile a list with the different node types and their explanation:
    */

    foreach (module_list() as $name) {
      if (module_hook($name, "node") && node_access("create", $name)) {
        $output .= "<li>";
        $output .= " ". l(module_invoke($name, "node", "name"), "node/add/$name", array("title" => t("Add a new %s.", array("%s" => module_invoke($name, "node", "name")))));
        $output .= " <div style=\"margin-left: 20px;\">". module_invoke($name, "node", "description") ."</div>";
        $output .= "</li>";
      }
    }

    $output = t("Choose the appropriate item from the list:") ."<ul>$output</ul>";

  }

  return $output;
}

function node_edit($id) {
  global $user;

  $node = node_load(array("nid" => $id));

  if (node_access("update", $node)) {
    $output = node_form($node);
  }
  else {
    $output = message_access();
  }

  return $output;
}

function node_preview($node, $error = NULL) {

  /*
  ** Convert the array to an object:
  */

  $node = array2object($node);

  if (node_access("create", $node) || node_access("update", $node)) {

    /*
    ** Load the user's name when needed:
    */

    if (isset($node->name)) {
      /*
      ** The use of isset() is mandatory in the context of user IDs as uid
      ** 0 denotes the anonymous user.
      */

      if ($user = user_load(array("name" => $node->name))) {
        $node->uid = $user->uid;
      }
      else {
        $node->uid = 0; // anonymous user
      }
    }
    else if ($node->uid) {
      $user = user_load(array("uid" => $node->uid));
      $node->name = $user->name;
    }

    /*
    ** Set the created time when needed:
    */

    if (empty($node->created)) {
      $node->created = time();
    }

    /*
    ** Extract a teaser:
    */

    $node->teaser = node_teaser($node->body);

    /*
    ** Apply the required filters:
    */

    if ($node->nid) {
      $view = array2object(array_merge(object2array($node), module_invoke($node->type, "save", "update", $node)));
    }
    else {
      $view = array2object(array_merge(object2array($node), module_invoke($node->type, "save", "create", $node)));
    }

    /*
    ** Display a preview of the node:
    */

    if ($view->teaser && $view->teaser != $view->body) {
      print "<h3>". t("Preview trimmed version") ."</h3>";
      node_view($view, 1);
      print "<p><i>". t("The trimmed version of your post shows how your post looks like when promoted to the main page or when exported for syndication.  You can insert a delimiter '&lt;!--break--&gt' (without the quotes) to fine-tune where your post gets split.") ."</i></p>";
      print "<h3>". t("Preview full version") ."</h3>";
      node_view($view, 0);
    }
    else {
      node_view($view, 0);
    }

    return node_form($node, $error);
  }
}

function node_submit($node) {
  global $user;

  /*
  ** Fixup the node when required:
  */

  $node = node_validate($node, $error);

  /*
  ** If something went wrong, go back to the preview form:
  */

  if ($error) {
    return node_preview($node, $error);
  }

  /*
  ** Prepare the node's body:
  */

  if ($node->nid) {

    /*
    ** Check whether the current user has the proper access rights to
    ** perform this operation:
    */

    if (node_access("update", $node)) {
      $nid = node_save($node);
      watchdog("special", "$node->type: updated '$node->title'", l("view post", "node/view/$node->nid"));
      $output = t("The %name has been updated.", array ("%name" => module_invoke($node->type, "node", "name")));
    }
  }
  else {

    /*
    ** Check whether the current user has the proper access rights to
    ** perform this operation:
    */

    if (node_access("create", $node)) {

      /*
      ** Verify a user's submission rate and avoid duplicate nodes being
      ** inserted:
      */

      throttle("node", variable_get("max_node_rate", 900));

      $nid = node_save($node);
      watchdog("special", "$node->type: added '$node->title'", l("view post", "node/view/$nid"));
      $output = t("Thanks for your submission.");
    }
  }

  /*
  ** Reload the node from the database:
  */

  $node = node_load(array("nid" => $nid));

  /*
  ** For usability's sake, make sure to present the user with some
  ** useful links as where to go next.
  */

  if ($referer = referer_load()) {
    $links[] = "<a href=\"$referer\">". t("return") ."</a>";
  }

  if ($nid && node_access("view", $node)) {
    $links[] = l(t("view"), "node/view/$nid");
  }

  if ($nid && node_access("update", $node)) {
    $links[] = l(t("edit"), "node/edit/$nid");
  }

  $output .= "<p>". theme("links", $links) ."</p>";

  return $output;
}

function node_delete($edit) {

  $node = node_load(array("nid" => $edit["nid"]));

  if (node_access("delete", $node)) {

    if ($edit["confirm"]) {

      /*
      ** Delete the specified node:
      */

      db_query("DELETE FROM node WHERE nid = '$node->nid'");

      /*
      ** Call the node specific callback (if any):
      */

      node_invoke($node, "delete");
      node_invoke_all($node, "nodeapi", "delete");

      /*
      ** Clear the cache so an anonymous poster can see the node being
      ** deleted.
      */

      cache_clear_all();

      watchdog("special", "$node->type: deleted '$node->title'");
      $output = t("The node has been deleted.");
    }
    else {
      $output .= form_item(t("Confirm deletion"), $node->title);
      $output .= form_hidden("nid", $node->nid);
      $output .= form_hidden("confirm", 1);
      $output .= form_submit(t("Delete"));
      $output = form($output);
    }
  }

  return $output;
}

function node_page() {
  global $id, $user, $or, $and;

  $op = $_POST["op"];
  $edit = $_POST["edit"];

  if (user_access("access content")) {
    if (empty($op)) {
      $op = arg(1);
    }

    if ($op == "feed") {
      node_feed();
      return;
    }

    if ($op == "view") {
      $node = node_load(array("nid" => arg(2), "status" => 1), $_GET["revision"]);
    }

    theme("header", $node->title);

    $name = module_invoke(arg(2), "node", "name");

    switch ($op) {
      case "add":
        theme("box", t("Create new $name"), node_add(arg(2)));
        break;
      case "edit":
        theme("box", t("Edit $name"), node_edit(arg(2)));
        break;
      case "view":
        print node_show($node, arg(3));
        break;
      case t("Preview"):
        $edit = node_validate($edit, $error);
        theme("box", t("Preview $name"), node_preview($edit, $error));
        break;
      case t("Submit"):
        theme("box", t("Submit $name"), node_submit($edit));
        break;
      case t("Delete"):
        theme("box", t("Delete $name"), node_delete($edit));
        break;
      default:
        $result = pager_query("SELECT nid, type FROM node WHERE promote = '1' AND status = '1' ORDER BY static DESC, created DESC", variable_get("default_nodes_main", 10));

        while ($node = db_fetch_object($result)) {
          node_view(node_load(array("nid" => $node->nid, "type" => $node->type)), 1);
        }
        print pager_display(NULL, variable_get("default_nodes_main", 10));
    }

    theme("footer");
  }
  else {
    theme("header");
    theme("box", t("Access denied"), message_access());
    theme("footer");
  }

}

function node_update_index() {

  // Return an array of values to dictate how to update the search index
  // for this particular type of node.
  //
  // "last_update"'s value is used with variable_set to set the
  // last time this node type had an index update run.
  //
  // "node_type"'s value is used to identify the node type in the search
  // index.
  //
  // "select"'s value is used to select the node id and text fields from
  // the table we are indexing. In this case, we also check against the
  // last run date for the nodes update.
  return array("last_update" => "node_cron_last",
         "node_type" => "node",
         "select" => "SELECT n.nid as lno, n.title as text1, n.body as text2 FROM node n WHERE n.status = 1 AND moderate = 0 and (created > " . variable_get("node_cron_last", 1) . " or changed > " . variable_get("node_cron_last", 1) . ")");
}

function node_nodeapi(&$node, $op, $arg = 0) {
  switch ($op) {
    case "settings":
      $output[t("publish")] = form_checkbox("", "node_status_$node->type", 1, variable_get("node_status_$node->type", 1));
      $output[t("promote")] = form_checkbox("", "node_promote_$node->type", 1, variable_get("node_promote_$node->type", 1));
      $output[t("moderate")] = form_checkbox("", "node_moderate_$node->type", 1, variable_get("node_moderate_$node->type", 0));
      $output[t("static")] = form_checkbox("", "node_static_$node->type", 1, variable_get("node_static_$node->type", 0));
      $output[t("revision")] = form_checkbox("", "node_revision_$node->type", 1, variable_get("node_revision_$node->type", 0));
      return $output;
    case "fields":
      return array("nid", "uid", "type", "title", "teaser", "body", "revisions", "status", "promote", "moderate", "static", "created", "changed");
  }
}

?>
