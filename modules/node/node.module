<?php
// $Id$

function node_help() {
  global $mod;

  if ($mod == "node") {
    foreach (module_list() as $name) {
      if (module_hook($name, "node") && $name != "node") {
        print "<h3>". t("%module type", array("%module" => ucfirst(module_invoke($name, "node", "name")))). "</h3>";
        print module_invoke($name, "help");
      }
    }
  }
}

function node_system($field){
  $system["description"] = t("The core that allows content to be submitted to the site.");
  return $system[$field];
}

/*
** Accepts a DB result object which can be used to fetch node objects.
** Returns an HTML list suitable as content for a block.
*/
function node_title_list($result, $title = NULL) {
  // no queries if site is in distress
  if (module_exist("statistics") && throttle_status() > 3) {
    return;
  }

  while ($node = db_fetch_object($result)) {
    $number = module_invoke("comment", "num_all", $node->nid);
    $items[] = l($node->title, "node/view/$node->nid", array("title" => t("Comments: %number", array("%number" => $number))));
  }

  return theme("theme_node_list", $items, $title);
}

function theme_node_list($items, $title = NULL) {
  return theme("theme_item_list", $items, $title);
}

// Update the 'last viewed' timestamp of the specified node for current user.
function node_tag_new($nid) {
  global $user;

  if ($user->uid) {
    $nid = check_query($nid);

    $result = db_query("SELECT timestamp FROM history WHERE uid = %d AND nid = %d", $user->uid, $nid);
    if (db_fetch_object($result)) {
      db_query("UPDATE history SET timestamp = %d WHERE uid = %d AND nid = %d", time(), $user->uid, $nid);
    }
    else {
      db_query("INSERT INTO history (uid, nid, timestamp) VALUES (%d, %d, %d)", $user->uid, $nid, time());
    }
  }
}

/*
** Retrieves the timestamp at which the current user last viewed the
** specified node.
*/
function node_last_viewed($nid) {
  global $user;

  $history = db_fetch_object(db_query("SELECT timestamp FROM history WHERE uid = '$user->uid' AND nid = %d", $nid));
  return ($history->timestamp ? $history->timestamp : 0);
}

/**
 * Determines whether the supplied timestamp is newer than the user's last view of a given node
 *
 * @param $nid       node-id twhose history supplies the 'last viewed' timestamp
 * @param $timestamp time which is compared against node's 'last veiwed' timestamp
*/
function node_is_new($nid, $timestamp) {
  global $user;
  static $cache;

  if (!isset($cache[$nid])) {
    if ($user->uid) {
      $history = db_fetch_object(db_query("SELECT timestamp FROM history WHERE uid = %d AND nid = %d", $user->uid, $nid));
      $cache[$nid] = $history->timestamp ? $history->timestamp : 0;
    }
    else {
      $cache[$nid] = time();
    }
  }

  if ($timestamp > $cache[$nid]) {
    return 1;
  }
  else {
    return 0;
  }
}

function node_teaser($body) {

  $size = variable_get("teaser_length", 600);

  /*
  ** If the size is zero, teasers are disabled so we
  ** return the entire body.
  */

  if ($size == 0) {
    return $body;
  }

  /*
  ** If we have a short body, return the entire body:
  */

  if (strlen($body) < $size) {
    return $body;
  }

  /*
  ** If a valid delimiter has been specified, use it to
  ** chop of the teaser.  The delimiter can be outside
  ** the allowed range but no more than a factor two.
  */

  $delimiter = strpos($body, "<!--break-->");
  if ($delimiter > 0 && $delimiter < $size * 2) {
    return substr($body, 0, $delimiter);
  }

  /*
  ** In some cases no delimiter has been specified (eg.
  ** when posting using the Blogger API) in which case
  ** we try to split at paragraph boundaries.
  */

  if ($length = strpos($body, "<br />", $size)) {
    return substr($body, 0, $length);
  }

  if ($length = strpos($body, "<br>", $size)) {
    return substr($body, 0, $length);
  }

  if ($length = strpos($body, "</p>", $size)) {
    return substr($body, 0, $length);
  }

  if ($length = strpos($body, "\n", $size)) {
    return substr($body, 0, $length);
  }

  /*
  ** When even the first paragraph is too long, try to
  ** split at the end of the next sentence.
  */

  if ($length = strpos($body, ". ", $size)) {
    return substr($body, 0, $length + 1);
  }

  if ($length = strpos($body, "! ", $size)) {
    return substr($body, 0, $length + 1);
  }

  if ($length = strpos($body, "? ", $size)) {
    return substr($body, 0, $length + 1);
  }

  /*
  ** Nevermind, we split it the hard way ...
  */

  return substr($body, 0, $size);
}

function node_invoke(&$node, $hook, $arg = 0) {
  if (is_array($node)) {
    $function = $node["type"] ."_$hook";
  }
  else if (is_object($node)) {
    $function = $node->type ."_$hook";
  }
  else if (is_string($node)) {
    $function = $node ."_$hook";
  }

  if (function_exists($function)) {
    return ($arg ? $function($node, $arg) : $function($node));
  }
}

function node_invoke_all(&$node, $hook, $op, $arg = 0) {
  $return = array();
  foreach (module_list() as $name) {
    if ((module_hook($name, "node") || module_hook($name, "nodeapi")) && module_hook($name, $hook)) {
      $function = $name ."_". $hook;
      $result = $function($node, $op, $arg);
      if (isset($result)) {
        $return = array_merge($return, $result);
      }
    }
  }
  return $return;
}

function node_load($conditions) {

  /*
  ** Turn the conditions into a query:
  */

  foreach ($conditions as $key => $value) {
    $cond[] = "n.". check_query($key) ." = '". check_query($value) ."'";
  }

  /*
  ** Retrieve the node:
  */

  $node = db_fetch_object(db_query("SELECT n.*, u.uid, u.name FROM node n LEFT JOIN users u ON u.uid = n.uid WHERE ". implode(" AND ", $cond)));

  /*
  ** Unserialize the revisions field:
  */

  if ($node->revisions) {
    $node->revisions = unserialize($node->revisions);
  }

  /*
  ** Call the node specific callback (if any) and piggy-back the
  ** results to the node or overwrite some values:
  */

  if ($extra = module_invoke($node->type, "load", $node)) {
    foreach ($extra as $key => $value) {
      $node->$key = $value;
    }
  }

  return $node;
}

function node_save($node) {

  /*
  ** Fetch fields to save to node table:
  */
  $fields = node_invoke_all($node, "nodeapi", "fields");

  /*
  ** Serialize the revisions field:
  */

  if ($node->revisions) {
    $node->revisions = serialize($node->revisions);
  }

  /*
  ** Apply filters to some default node fields:
  */

  if (empty($node->nid)) {

    /*
    ** Insert a new node:
    */

    // Set some required fields:
    if (!$node->created) {
      $node->created = time();
    }
    $node->changed = time();
    $node->nid = db_next_id("node_nid");

    // Prepare the query:
    foreach ($node as $key => $value) {
      if (in_array($key, $fields)) {
        $k[] = check_query($key);
        $v[] = "'". check_query($value) ."'";
      }
    }

    // Insert the node into the database:
    db_query("INSERT INTO node (". implode(", ", $k) .") VALUES (". implode(", ", $v) .")");

    // Call the node specific callback (if any):
    node_invoke($node, "insert");
    node_invoke_all($node, "nodeapi", "insert");
  }
  else {

    /*
    ** Update an existing node:
    */

    // Set some required fields:
    $node->changed = time();

    // Prepare the query:
    foreach ($node as $key => $value) {
      if (in_array($key, $fields)) {
        $q[] = check_query($key) ." = '". check_query($value) ."'";
      }
    }

    // Update the node in the database:
    db_query("UPDATE node SET ". implode(", ", $q) ." WHERE nid = '$node->nid'");

    // Call the node specific callback (if any):
    node_invoke($node, "update");
    node_invoke_all($node, "nodeapi", "update");
  }

  /*
  ** Clear the cache so an anonymous poster can see the node being
  ** added or updated.
  */

  cache_clear_all();

  /*
  ** Return the node ID:
  */

  return $node->nid;

}

function node_view($node, $main = 0) {


  $node = array2object($node);

  /*
  ** Remove the delimiter (if any) that seperates the teaser from the
  ** body. TODO: this strips legitimate uses of '<!--break-->' also.
  */

  $node->body = str_replace("<!--break-->", "", $node->body);

  /*
  ** The "view" hook can be implemented to overwrite the default function
  ** to display nodes.
  */

  if (module_hook($node->type, "view")) {
    node_invoke($node, "view", $main);
  }
  else {

    /*
    ** Default behavior:
    */

    theme("node", $node, $main);
  }
}


function node_show($nid, $cid) {
  global $revision;

  $node = node_load(array("status" => 1, "nid" => $nid));

  if (node_access("view", $node)) {
    if (isset($revision)) {
      $node = $node->revisions[$revision]["node"];
    }

    node_view($node);

    if (function_exists("comment_render") && $node->comment) {
      comment_render($node, $cid);
    }

    /*
    ** Update the history table, stating that this user viewed this node.
    */

    node_tag_new($node->nid);
  }
}

function node_access($op, $node = 0) {

  if (user_access("administer nodes")) {
    return 1;
  }

  /*
  ** Convert the node to an object if necessary:
  */

  $node = array2object($node);

  /*
  ** Construct a function:
  */

  if ($node->type) {
    $type = $node->type;
  }
  else {
    $type = $node;
  }

  $function = $type ."_access";

  if (function_exists($function)) {
    return $function($op, $node);
  }
  else {
    return 0;
  }
}

function node_perm() {
  return array("administer nodes", "access content");
}

function node_search($keys) {
  global $PHP_SELF;

  // Return the results of performing a search using the indexed search
  // for this particular type of node.
  //
  // Pass an array to the "do_search" function which dictates what it
  // will search through, and what it will search for
  //
  // "keys"'s value is the keywords entered by the user
  //
  // "type"'s value is used to identify the node type in the search
  // index.
  //
  // "select"'s value is used to relate the data from the specific nodes
  // table to the data that the search_index table has in it, and the the
  // do_search functino will rank it.
  //
  // The select must always provide the following fields - lno, title,
  // created, uid, name, count
  //
  $find = do_search(array("keys" => $keys, "type" => "node", "select" => "select s.lno as lno, n.title as title, n.created as created, u.uid as uid, u.name as name, s.count as count FROM search_index s, node n LEFT JOIN users u ON n.uid = u.uid WHERE s.lno = n.nid AND s.type = 'node' AND s.word like '%' AND n.status = 1"));

  return $find;
}

function node_settings() {
  $output .= form_select(t("Number of posts on main page"), "default_nodes_main", variable_get("default_nodes_main", 10), array(1 => 1, 2 => 2, 3 => 3, 4 => 4, 5 =>  5, 6 => 6, 7 => 7, 8 => 8, 9 => 9, 10 => 10, 15 => 15, 20 => 20, 25 => 25, 30 => 30), t("The default maximum number of posts to display on overview pages such as the main page."));
  $output .= form_select(t("Length of trimmed posts"), "teaser_length", variable_get("teaser_length", 600), array(0 => t("Unlimited"), 200 => t("200 characters"), 400 => t("400 characters"), 600 => t("600 characters"), 800 => t("800 characters"), 1000 => t("1000 characters"), 1200 => t("1200 characters"), 1400 => t("1400 characters"), 1600 => t("1600 characters"), 1800 => t("1800 characters"), 2000 => t("2000 characters")), t("The maximum number of characters used in the trimmed version of a post.  Drupal will use this setting to determine at which offset long posts should be trimmed.  The trimmed version of a post is typically used as a teaser when displaying the post on the main page, in XML feeds, etc.  To disable teasers, set to 'Unlimited'."));
  return $output;
}

function node_conf_filters() {
  $output .= form_select(t("Filter HTML tags"), "filter_html", variable_get("filter_html", 0), array(t("Disabled"), t("Enabled")), t("Filter HTML and PHP tags in user-contributed content."));
  $output .= form_textfield(t("Allowed HTML tags"), "allowed_html", variable_get("allowed_html", "<a> <b> <dd> <dl> <dt> <i> <li> <ol> <u> <ul>"), 64, 255, t("If enabled, optionally specify tags which should not be stripped.  'STYLE' attributes, 'ON' attributes and unclosed tags are always stripped."));
  $output .= "<hr />";
  // $output .= form_select(t("Enable link tags"), "filter_link", variable_get("filter_link", 0), array(t("Disabled"), t("Enabled")), t("Substitute special [[nodesubject|text]] tags. Your browser will display 'text', and when you click on it your browser will open the node with the subject 'nodesubject'. Please be aware that you'll need to copy the subject of the target node exactly in order to use this feature."));
  // $output .= "<hr />";
  return $output;
}

function node_filter_html($text) {
  $text = strip_tags($text, variable_get("allowed_html", ""));
  return $text;
}

function node_filter_link($text) {
  $pat = '\[{2}([^\|]+)(\|([^\|]+)?)?\]{2}';                   // [link|description]
//  $dst = str_replace('%5C1', '\\1', format_tag('\\1', '\\3')); // [link|description]
  return ereg_replace($pat, $dst, $text);
}

function node_comment_mode($nid) {
  static $comment_mode;
  if (!isset($comment_mode[$nid])) {
    $comment_mode[$nid] = db_result(db_query("SELECT comment FROM node WHERE nid = %d", $nid));
  }
  return $comment_mode[$nid];
}

function node_filter($text) {
  $text = preg_replace("/\Wstyle\s*=[^>]+?>/i", ">", $text);
  $text = preg_replace("/\Won[a-z]+\s*=[^>]+?>/i", ">", $text);
  $text = preg_replace("/\Wsrc\s*=[\s'\"]*javascript[^>]+?>/i", ">", $text);
  $text = preg_replace("/\Whref\s*=[\s'\"]*javascript:[^>]+?>/i", ">", $text);

  if (variable_get("filter_html", 0)) $text = node_filter_html($text);
  // if (variable_get("filter_link", 0)) $text = node_filter_link($text);

  return trim($text);
}

function node_link($type, $node = 0, $main = 0) {

  $links = array();

  if ($type == "page") {
    $links[] = l(t("submit"), "node/add", array("title" => t("Submit or suggest new content.")));
  }

  if ($type == "node") {
    if ($node->links) {
      $links = $node->links;
    }

    if ($main == 1 && $node->teaser && $node->teaser != $node->body) {
      $links[] = l(t("read more"), "node/view/$node->nid", array("title" => t("Read the rest of this posting.")));
    }

    if (user_access("administer nodes")) {
       $links[] = l(t("administer"), "admin/node/edit/$node->nid", array("title" => t("Administer this node.")));
    }
  }

  if ($type == "admin" && user_access("administer nodes")) {
    $help["search"] = "On this page you can search for a post.  For example, one may search for 'br' and Drupal might return 'bread brakers', 'our daily bread' and 'brenda'.";

    menu("admin/node", "content management", "node_admin");
    menu("admin/node/nodes", "post overview");
    menu("admin/node/nodes/0", "new or updated posts", "node_admin", NULL, 0);
    menu("admin/node/nodes/1", "approval queue", "node_admin", NULL, 1);
    menu("admin/node/search", "search posts", "node_admin", $help["search"], 8);
    menu("admin/node/help", "help", "node_help", NULL, 9);
    menu("admin/node/edit", "edit node", "node_admin", NULL, 0, 1);
    menu("admin/node/settings", "content settings", "node_admin", NULL, 8);
  }

  return $links;
}

function node_admin_edit($node) {

  if (is_numeric($node)) {
    $node = node_load(array("nid" => $node));
  }

  /*
  ** Edit node:
  */

  $output .= "<h3>". t("Edit %module", array("%module" => module_invoke($node->type, "node", "name"))) ."</h3>";

  $output .= node_form($node);

  /*
  ** Edit revisions:
  */

  if ($node->revisions) {
    $output .= "<h3>". t("Edit revisions") ."</h3>";
    $output .= "<table border=\"1\" cellpadding=\"2\" cellspacing=\"2\">";
    $output .= " <tr><th>". t("older revisions") ."</th><th colspan=\"3\">". t("operations") ."</th></tr>";
    foreach ($node->revisions as $key => $revision) {
      $output .= " <tr><td>". t("revision #%r revised by %u on %d", array("%r" => $key, "%u" => format_name(user_load(array("uid" => $revision["uid"]))), "%d" => format_date($revision["timestamp"], "small"))) . ($revision["history"] ? "<br /><small>". $revision["history"] ."</small>" : "") ."</td><td>". l(t("view revision"), "node/view/$node->nid", array(), "revision=$key") ."</td><td>". l(t("rollback revision"), "admin/node/rollback+revision/$node->nid/$key") ."</td><td>". l(t("delete revision"), "admin/node/delete+revision/$node->nid/$key") ."</td></tr>";
    }
    $output .= "</table>";
  }

  /*
  ** Display the node form extensions:
  */

  foreach (module_list() as $name) {
    $output .= module_invoke($name, "node_link", $node);
  }

  return $output;

}

function node_admin_nodes() {

  $query = arg(3);
  $queries = array("ORDER BY n.changed DESC", "WHERE n.status = 0 OR n.moderate = 1 ORDER BY n.changed DESC");

  $result = pager_query("SELECT n.*, u.name, u.uid FROM node n LEFT JOIN users u ON n.uid = u.uid ". $queries[$query ? $query : 0], 50);

  $header = array(t("title"), t("type"), t("author"), t("status"), array("data" => t("operations"), "colspan" => 2));

  while ($node = db_fetch_object($result)) {
    $rows[] = array(l($node->title, "node/view/$node->nid") ." ". (node_is_new($node->nid, $node->changed) ? theme_mark() : ""), module_invoke($node->type, "node", "name"), format_name($node), ($node->status ? t("published") : t("not published")), l(t("edit node"), "admin/node/edit/$node->nid"), l(t("delete node"), "admin/node/delete/$node->nid"));
  }

  if ($pager = pager_display(NULL, 50, 0, "admin")) {
    $rows[] = array(array("data" => $pager, "colspan" => 6));
  }

  return table($header, $rows);
}

/*
**
*/

function node_admin_settings($edit) {
  global $op;

  if ($op == t("Save configuration")) {
    /*
    ** Save the configuration options:
    */

    foreach ($edit as $name => $value) {
      variable_set($name, $value);
    }
    $output = status(t("the content settings have been saved."));
  }

  if ($op == t("Reset to defaults")) {
    /*
    ** Reset the configuration options to their default value:
    */

    foreach ($edit as $name => $value) {
      variable_del($name);
    }
    $output = status(t("the content settings have been reset to their default values."));
  }

  $header = array_merge(array(t("content type")), array_keys(node_invoke_all($node, "nodeapi", "settings")));
  foreach (module_list() as $name) {
    if (module_hook($name, "node")) {
      $node->type = $name;
      $cols = array();
      foreach (node_invoke_all($node, "nodeapi", "settings") as $setting) {
        $cols[] = array("data" => $setting, "align" => "center", "width" => 55);
      }
      $rows[] = array_merge(array(module_invoke($name, "node", "name")), $cols);
    }
  }

  $output .= table($header, $rows);

  /* This is an idea for the future.
  foreach (module_list() as $name) {
    if (module_hook($name, "node")) {
      $node->type = $name;

      // Create table() data:
      $header = array_keys(node_invoke_all($node, "nodeapi", "settings"));
      $cols = array();
      foreach (node_invoke_all($node, "nodeapi", "settings") as $setting) {
        $cols[] = array("data" => $setting, "align" => "center", "width" => 75);
      }

      $output .= "<h2>". module_invoke($name, "node", "name") ."</h2>";
      $output .= table($header, array($cols));
      $output .= "<br /><br />";
    }
  }
  */

  $output .= form_submit(t("Save configuration"));
  $output .= form_submit(t("Reset to defaults"));

  print form($output);

}

/*
** Return the revision with the specified revision number.
*/

function node_revision_load($node, $revision) {
  return $node->revisions[$revision]["node"];
}

/*
** Create and return a new revision of the given node.
*/

function node_revision_create($node) {
  global $user;

  /*
  ** 'revision' is the name of the field used to indicicate that we
  ** have to create a new revision of a node.
  */

  if ($node->nid && $node->revision) {
    $prev = node_load(array("nid" => $node->nid));
    $node->revisions = $prev->revisions;
    unset($prev->revisions);
    $node->revisions[] = array("uid" => $user->uid, "timestamp" => time(), "node" => $prev, "history" => $node->history);
  }

  return $node;
}

/*
** Roll-back to the revision with the specified revision number.
*/

function node_revision_rollback($node, $revision) {
  global $user;

  /*
  ** Extract the specified revision:
  */

  $rev = $node->revisions[$revision]["node"];

  /*
  ** Inherit all the past revisions:
  */

  $rev->revisions = $node->revisions;

  /*
  ** Save the original/current node:
  */

  $rev->revisions[] = array("uid" => $user->uid, "timestamp" => time(), "node" => $node);

  /*
  ** Remove the specified revision:
  */

  unset($rev->revisions[$revision]);

  /*
  ** Save the node:
  */

  foreach ($node as $key => $value) {
    $filter[] = $key;
  }

  node_save($rev, $filter);

  watchdog("special", "$node->type: rollbacked to revision #$revision of '$node->title'");
}

/*
** Delete the revision with specified revision number.
*/

function node_revision_delete($node, $revision) {

  unset($node->revisions[$revision]);

  node_save($node, array("nid", "revisions"));

  watchdog("special", "$node->type: removed revision #$revision of '$node->title'");
}

/*
** Return a list of all the existing revision numbers.
*/

function node_revision_list($node) {
  if (is_array($node->revisions)) {
    return array_keys($node->revisions);
  }
  else {
    return array();
  }
}

function node_admin() {
  global $op, $edit;

  if (user_access("administer nodes")) {

    if (empty($op)) {
      $op = arg(2);
    }

    /*
    ** Compile a list of the administrative links:
    */

    switch ($op) {
      case "search":
        print search_type("node", url("admin/node/search"));
        break;
      case "edit":
        print node_admin_edit(arg(3));
        break;
      case "delete":
        print node_delete(array("nid" => arg(3)));
        break;
      case "rollback+revision":
        print node_revision_rollback(node_load(array("nid" => arg(3))), arg(5));
        print node_admin_edit(arg(4));
        break;
      case "delete+revision":
        print node_revision_delete(node_load(array("nid" => arg(3))), arg(5));
        print node_admin_edit(arg(4));
        break;
      case t("Preview"):
        $edit = node_validate($edit, $error);
        print node_preview($edit);
        break;
      case t("Submit"):
        print node_submit($edit);
        break;
      case t("Delete"):
        print node_delete($edit);
        break;
      case t("Save configuration"):
      case t("Reset to defaults"):
      case "settings":
        print node_admin_settings($edit);
        break;
      default:
        print node_admin_nodes();
    }
  }
  else {
    print message_access();
  }
}

function node_block($op = "list", $delta = 0) {

  if ($op == "list") {
    $blocks[0]["info"] = t("Syndicate");
    return $blocks;
  }
  else {
    $block["subject"] = t("Syndicate");
    $block["content"] = "<div align=\"center\">". l("<img src=\"". theme("image", "xml.gif") ."\" width=\"36\" height=\"14\" border=\"0\" alt=\"XML\" />", "node/feed", array("title" => t("Read the XML version of this page."))) ."</div>";

    return $block;
  }
}

function node_feed($nodes = 0, $channel = array()) {
  global $base_url;

  /*
  ** A generic function for generating RSS feeds from a set of nodes.
  **   - $nodes should be an object as returned by db_query() which contains
  **     the nid field.
  **   - $channel is an associative array containing title, link, and
  **     description keys.
  */

  if (!$nodes) {
    $nodes = db_query_range("SELECT nid FROM node WHERE promote = '1' AND status = '1' ORDER BY created DESC", 0, 15);
  }

  while ($node = db_fetch_object($nodes)) {
    $item = node_load(array("nid" => $node->nid));
    $link = url("node/view/$item->nid");
    $items .= format_rss_item($item->title, $link, $item->teaser);
  }

  $output .= "<?xml version=\"1.0\" ". t("encoding=\"ISO-8859-1\""). "?>\n";
  $output .= "<!DOCTYPE rss [<!ENTITY % HTMLlat1 PUBLIC \"-//W3C//ENTITIES Latin 1 for XHTML//EN\" \"http://www.w3.org/TR/xhtml1/DTD/xhtml-lat1.ent\">]>\n";
    // NOTE: &eacute; - for example - is the correct ISO-8859-1 translation of  (e acute) but apparently XML parsers don't (have to) understand it.  To solve this problem, we use a DTD that defines commonly used entity such as &eacute;.
  if (!$channel["version"]) $channel["version"] = "0.91";
  if (!$channel["title"]) $channel["title"] = variable_get("site_name", "drupal") ." - ". variable_get("site_slogan", "");
  if (!$channel["link"]) $channel["link"] = $base_url;
  if (!$channel["description"]) $channel["description"] = variable_get("site_mission", "");
  if (!$channel["language"]) $channel["language"] = "en";
  $output .= "<rss version=\"". $channel["version"] . "\">\n";
  $output .= format_rss_channel($channel["title"], $channel["link"], $channel["description"], $items, $channel["language"]);
  $output .= "</rss>\n";

  header("Content-Type: text/xml");
  print $output;
}

function node_validate($node, &$error) {
  global $user;
  $error = array();

  /*
  ** Convert the node to an object if necessary:
  */

  $node = array2object($node);

  /*
  ** Validate the title field:
  */

  if (isset($node->title) && !$node->title) {
    $error["title"] = theme("theme_error", t("You have to specify a valid title."));
  }

  /*
  ** Common default values:
  */

  $node->teaser = node_teaser($node->body);

  /*
  ** Create a new revision when required:
  */

  $node = node_revision_create($node);

  if (user_access("administer nodes")) {

    /*
    ** Setup default values if required:
    */

    if (!$node->created) {
      $node->created = time();
    }

    if (!$node->date) {
      $node->date = date("M j, Y g:i a", $node->created);
    }

    if (!is_numeric($node->status)) {
      $node->status = 1;
    }

    /*
    ** Validate the "authored by"-field:
    */

    if (empty($node->name)) {
      /*
      ** The use of empty() is mandatory in the context of usernames
      ** as the empty string denotes the anonymous user.  In case we
      ** are dealing with an anomymous user we set the user ID to 0.
      */
      $node->uid = 0;
    }
    else if ($account = user_load(array("name" => $node->name))) {
      $node->uid = $account->uid;
    }
    else {
      $error["name"] = theme("theme_error", t("The name '%u' does not exist.", array ("%u" => $node->name)));
    }

    /*
    ** Validate the "authored on"-field:
    */

    if (strtotime($node->date) > 1000) {
      $node->created = strtotime($node->date);
    }
    else {
      $error["date"] = theme("theme_error", t("You have to specifiy a valid date."));
    }
  }
  else {
    // Validate for normal users:
    $node->uid = $user->uid ? $user->uid : 0;
    // Force defaults in case people modify the form:
    $node->status = variable_get("node_status_$node->type", 1);
    $node->promote = variable_get("node_promote_$node->type", 1);
    $node->moderate = variable_get("node_moderate_$node->type", 0);
    $node->static = variable_get("node_static_$node->type", 0);
    $node->revision = variable_get("node_revision_$node->type", 0);
    unset($node->created);
  }

  // Workflow:
  if ($node->moderate == 1) {
    $node->promote = 0;
  }

  /*
  ** Do node type specific validation checks.
  */

  $result = node_invoke($node, "validate");
  $error = $error + (is_array($result) ? $result : array()) + node_invoke_all($node, "nodeapi", "validate");

  return $node;
}


function node_form($edit, $error = NULL) {

  /*
  ** Save the referer.  We record where the user came from such that we
  ** can redirect him after having completed the node forms.
  */

  referer_save();

  /*
  ** Validate the node:
  */

  if (!$error) {
    /* Only validate if we don't already know the errors. */
    $edit = node_validate($edit, $error);
  }

  // Prepend extra node form:
  $form = implode("", node_invoke_all($edit, "nodeapi", "form pre", $error));

  /*
  ** Get the node specific bits:
  */

  $function = $edit->type ."_form";
  if (function_exists($function)) {
    $form .= $function($edit, $help, $error, $param);
  }

  // Append extra node form:
  $form .= implode("", node_invoke_all($edit, "nodeapi", "form post", $error));

  /*
  ** Add the help text:
  */

  if ($help) {
    $output .= "<p>$help</p>";
  }

  $output .= "<table border=\"0\" cellpadding=\"2\" cellspacing=\"2\">";
  $output .= " <tr>";
  $output .= "  <td valign=\"top\">";

  /*
  ** Add the default fields:
  */

  $output .= form_textfield(t("Title"), "title", $edit->title, 60, 64, $error["title"]);

  /*
  ** Add the node specific fields:
  */

  $output .= $form;

  /*
  ** Add the hidden fields:
  */

  if ($edit->nid) {
    $output .= form_hidden("nid", $edit->nid);
  }

  if (isset($edit->uid)) {
      /*
      ** The use of isset() is mandatory in the context of user IDs as uid
      ** 0 denotes the anonymous user.
      */
    $output .= form_hidden("uid", $edit->uid);
  }

  if ($edit->created) {
    $output .= form_hidden("created", $edit->created);
  }

  $output .= form_hidden("type", $edit->type);

  /*
  ** Add the buttons:
  */

  $output .= form_submit(t("Preview"));

  if ($edit->title && $edit->type && !$error) {
    $output .= form_submit(t("Submit"));
  }

  if ($edit->nid && node_access("delete", $edit)) {
    $output .= form_submit(t("Delete"));
  }

  /*
  ** Add the admin specific parts:
  */

  if (user_access("administer nodes")) {
    $output .= "</td><td align=\"left\" valign=\"top\">";
    $output .= form_textfield(t("Authored by"), "name", $edit->name, 20, 60, $error["name"]);
    $output .= form_textfield(t("Authored on"), "date", $edit->date, 20, 25, $error["date"]);
    $output .= "<br />";
    $output .= form_select(t("Set public/published"), "status", isset($edit->status) ? $edit->status : variable_get("node_status_$edit->type", 1), array(t("Disabled"), t("Enabled")));
    $output .= form_select(t("Promote to front page"), "promote", isset($edit->promote) ? $edit->promote : variable_get("node_promote_$edit->type", 1), array(t("Disabled"), t("Enabled")));
    $output .= form_select(t("Moderation status"), "moderate", isset($edit->moderate) ? $edit->moderate : variable_get("node_moderate_$edit->type", 0), array(t("Approved"), t("Awaiting approval")));
    $output .= form_select(t("Static on front page"), "static", isset($edit->static) ? $edit->static : variable_get("node_static_$edit->type", 0), array(t("Disabled"), t("Enabled")));
    $output .= implode("", node_invoke_all($edit, "nodeapi", "form admin"));
    $output .= form_select(t("Create new revision"), "revision", isset($edit->revision) ? $edit->revision : variable_get("node_revision_$edit->type", 0), array(t("Disabled"), t("Enabled")));
  }

  $output .= "  </td>";
  $output .= " </tr>";
  $output .= "</table>";

  return form($output, ($param["method"] ? $param["method"] : "post"), $param["action"], $param["options"]);
}

function node_add($type) {
  global $user, $edit;

  /*
  ** If a node type has been specified, validate it existence.  If no
  ** (valid) node type has been provied, display a node type overview.
  */

  if ($type && node_access("create", $type)) {
    // Initialize settings
    // TODO : clean up this code.
    $node = array("uid" => $user->uid, "name" => $user->name, "type" => $type);
    foreach (array("title", "teaser", "body") as $field) {
      if ($edit[$field]) {
        $node[$field] = check_input($edit[$field]);
      }
    }
    $output = node_form($node);
  }
  else {

    /*
    ** Compile a list with the different node types and their explanation:
    */

    foreach (module_list() as $name) {
      if (module_hook($name, "node") && node_access("create", $name)) {
        $output .= "<li>";
        $output .= " ". l(module_invoke($name, "node", "name"), "node/add/$name", array("title" => t("Add a new %s.", array("%s" => module_invoke($name, "node", "name")))));
        $output .= " <div style=\"margin-left: 20px;\">". module_invoke($name, "node", "description") ."</div>";
        $output .= "</li>";
      }
    }

    $output = t("Choose the appropriate item from the list:") ."<ul>$output</ul>";

  }

  return $output;
}

function node_edit($id) {
  global $user;

  $node = node_load(array("nid" => $id));

  if (node_access("update", $node)) {
    $output = node_form($node);
  }
  else {
    $output = message_access();
  }

  return $output;
}

function node_preview($node, $error = NULL) {

  /*
  ** Convert the array to an object:
  */

  $node = array2object($node);

  if (node_access("create", $node) || node_access("update", $node)) {

    /*
    ** Load the user's name when needed:
    */

    if (isset($node->name)) {
      /*
      ** The use of isset() is mandatory in the context of user IDs as uid
      ** 0 denotes the anonymous user.
      */

      if ($user = user_load(array("name" => $node->name))) {
        $node->uid = $user->uid;
      }
      else {
        $node->uid = 0; // anonymous user
      }
    }
    else if ($node->uid) {
      $user = user_load(array("uid" => $node->uid));
      $node->name = $user->name;
    }

    /*
    ** Set the created time when needed:
    */

    if (empty($node->created)) {
      $node->created = time();
    }

    /*
    ** Extract a teaser:
    */

    $node->teaser = node_teaser($node->body);

    /*
    ** Apply the required filters:
    */

    if ($node->nid) {
      $view = array2object(array_merge(object2array($node), module_invoke($node->type, "save", "update", $node)));
    }
    else {
      $view = array2object(array_merge(object2array($node), module_invoke($node->type, "save", "create", $node)));
    }

    /*
    ** Display a preview of the node:
    */

    if ($view->teaser && $view->teaser != $view->body) {
      print "<h3>". t("Preview trimmed version") ."</h3>";
      node_view($view, 1);
      print "<p><i>". t("The trimmed version of your post shows how your post looks like when promoted to the main page or when exported for syndication.  You can insert a delimiter '&lt;!--break--&gt' (without the quotes) to fine-tune where your post gets split.  However note that delimiter will be ignored when misplaced.") ."</i></p>";
      print "<h3>". t("Preview full version") ."</h3>";
      node_view($view, 0);
    }
    else {
      node_view($view, 0);
    }

    return node_form($node, $error);
  }
}

function node_submit($node) {
  global $user;

  /*
  ** Fixup the node when required:
  */

  $node = node_validate($node, $error);

  /*
  ** If something went wrong, go back to the preview form:
  */

  if ($error) {
    return node_preview($node, $error);
  }

  /*
  ** Prepare the node's body:
  */

  if ($node->nid) {

    /*
    ** Check whether the current user has the proper access rights to
    ** perform this operation:
    */

    if (node_access("update", $node)) {
      $nid = node_save($node);
      watchdog("special", "$node->type: updated '$node->title'", l("view post", "node/view/$node->nid"));
      $output = t("The %name has been updated.", array ("%name" => module_invoke($node->type, "node", "name")));
    }
  }
  else {

    /*
    ** Check whether the current user has the proper access rights to
    ** perform this operation:
    */

    if (node_access("create", $node)) {

      /*
      ** Verify a user's submission rate and avoid duplicate nodes being
      ** inserted:
      */

      throttle("node", variable_get("max_node_rate", 900));

      $nid = node_save($node);
      watchdog("special", "$node->type: added '$node->title'", l("view post", "node/view/$nid"));
      $output = t("Thanks for your submission.");
    }
  }

  /*
  ** Reload the node from the database:
  */

  $node = node_load(array("nid" => $nid));

  /*
  ** For usability's sake, make sure to present the user with some
  ** useful links as where to go next.
  */

  if ($referer = referer_load()) {
    $links[] = "<a href=\"$referer\">". t("return") ."</a>";
  }

  if ($nid && node_access("view", $node)) {
    $links[] = l(t("view"), "node/view/$nid");
  }

  if ($nid && node_access("update", $node)) {
    $links[] = l(t("edit"), "node/edit/$nid");
  }

  $output .= "<p>". theme("links", $links) ."</p>";

  return $output;
}

function node_delete($edit) {

  $node = node_load(array("nid" => $edit["nid"]));

  if (node_access("delete", $node)) {

    if ($edit["confirm"]) {

      /*
      ** Delete the specified node:
      */

      db_query("DELETE FROM node WHERE nid = '$node->nid'");

      /*
      ** Call the node specific callback (if any):
      */

      node_invoke($node, "delete");
      node_invoke_all($node, "nodeapi", "delete");

      /*
      ** Clear the cache so an anonymous poster can see the node being
      ** deleted.
      */

      cache_clear_all();

      watchdog("special", "$node->type: deleted '$node->title'");
      $output = t("The node has been deleted.");
    }
    else {
      $output .= form_item(t("Confirm deletion"), $node->title);
      $output .= form_hidden("nid", $node->nid);
      $output .= form_hidden("confirm", 1);
      $output .= form_submit(t("Delete"));
      $output = form($output);
    }
  }

  return $output;
}

function node_page() {
  global $op, $id, $user, $edit, $or, $and;

  if (user_access("access content")) {
    if (empty($op)) {
      $op = arg(1);
    }

    if ($op == "feed") {
      node_feed();
      return;
    }

    theme("header");
    $name = module_invoke(arg(2), "node", "name");
    switch ($op) {
      case "add":
        theme("box", t("Create new $name"), node_add(arg(2)));
        break;
      case "edit":
        theme("box", t("Edit $name"), node_edit(arg(2)));
        break;
      case "view":
        print node_show(arg(2), arg(3));
        break;
      case t("Preview"):
        $edit = node_validate($edit, $error);
        theme("box", t("Preview $name"), node_preview($edit, $error));
        break;
      case t("Submit"):
        theme("box", t("Submit $name"), node_submit($edit));
        break;
      case t("Delete"):
        theme("box", t("Delete $name"), node_delete($edit));
        break;
      default:
        $result = pager_query("SELECT nid, type FROM node WHERE promote = '1' AND status = '1' ORDER BY static DESC, created DESC", variable_get("default_nodes_main", 10));

        while ($node = db_fetch_object($result)) {
          node_view(node_load(array("nid" => $node->nid, "type" => $node->type)), 1);
        }
        print pager_display(NULL, variable_get("default_nodes_main", 10));
    }
  }
  else {
    theme("box", t("Access denied"), message_access());
  }

  theme("footer");
}

function node_update_index() {

  // Return an array of values to dictate how to update the search index
  // for this particular type of node.
  //
  // "last_update"'s value is used with variable_set to set the
  // last time this node type had an index update run.
  //
  // "node_type"'s value is used to identify the node type in the search
  // index.
  //
  // "select"'s value is used to select the node id and text fields from
  // the table we are indexing. In this case, we also check against the
  // last run date for the nodes update.
  return array("last_update" => "node_cron_last",
         "node_type" => "node",
         "select" => "SELECT n.nid as lno, n.title as text1, n.body as text2 FROM node n WHERE n.status = 1 AND moderate = 0 and (created > " . variable_get("node_cron_last", 1) . " or changed > " . variable_get("node_cron_last", 1) . ")");
}

function node_nodeapi(&$node, $op, $arg = 0) {
  switch ($op) {
    case "settings":
      $output[t("publish")] = form_checkbox("", "node_status_$node->type", 1, variable_get("node_status_$node->type", 1));
      $output[t("promote")] = form_checkbox("", "node_promote_$node->type", 1, variable_get("node_promote_$node->type", 1));
      $output[t("moderate")] = form_checkbox("", "node_moderate_$node->type", 1, variable_get("node_moderate_$node->type", 0));
      $output[t("static")] = form_checkbox("", "node_static_$node->type", 1, variable_get("node_static_$node->type", 0));
      $output[t("revision")] = form_checkbox("", "node_revision_$node->type", 1, variable_get("node_revision_$node->type", 0));
      return $output;
    case "fields":
      return array("nid", "uid", "type", "title", "teaser", "body", "revisions", "status", "promote", "moderate", "static", "created", "changed");
  }
}

?>
