<?php
// $Id$

/**
 * @file
 * Allows users to structure the pages of a site in a hierarchy or outline.
 */

/**
 * Implementation of hook_theme()
 */
function book_theme() {
  return array(
    'book_navigation' => array(
      'arguments' => array('book_link' => NULL),
    ),
    'book_export_html' => array(
      'arguments' => array('title' => NULL, 'content' => NULL),
    ),
    'book_admin_table' => array(
      'arguments' => array('form' => NULL),
    ),
    'book_title_link' => array(
      'arguments' => array('link' => NULL),
    ),
    'book_all_books_block' => array(
      'arguments' => array('book_menus' => array()),
    ),
  );
}

/**
 * Implementation of hook_perm().
 */
function book_perm() {
  return array('add content to books', 'administer book outlines', 'create new books', 'access printer-friendly version');
}

/**
 * Implementation of hook_link().
 */
function book_link($type, $node = NULL, $teaser = FALSE) {
  $links = array();

  if ($type == 'node' && isset($node->book)) {
    if (!$teaser) {
      $child_type = variable_get('book_child_type', 'book');
      if ((user_access('add content to books') || user_access('administer book outlines')) && node_access('create', $child_type) && $node->status == 1 && $node->book['depth'] < MENU_MAX_DEPTH) {
        $links['book_add_child'] = array(
          'title' => t('Add child page'),
          'href' => "node/add/". str_replace('_', '-', $child_type),
          'query' => "parent=". $node->book['mlid'],
        );
      }
      if (user_access('access printer-friendly version')) {
        $links['book_printer'] = array(
          'title' => t('Printer-friendly version'),
          'href' => 'book/export/html/'. $node->nid,
          'attributes' => array('title' => t('Show a printer-friendly version of this book page and its sub-pages.'))
        );
      }
    }
  }
  return $links;
}

/**
 * Implementation of hook_menu().
 */
function book_menu() {
  $items['admin/content/book'] = array(
    'title' => 'Books',
    'description' => "Manage your site's book outlines.",
    'page callback' => 'book_admin_overview',
    'access arguments' => array('administer book outlines'),
  );
  $items['admin/content/book/list'] = array(
    'title' => 'List',
    'type' => MENU_DEFAULT_LOCAL_TASK,
  );
  $items['admin/content/book/settings'] = array(
    'title' => 'Settings',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('book_admin_settings'),
    'access arguments' => array('administer site configuration'),
    'type' => MENU_LOCAL_TASK,
    'weight' => 8,
  );
  $items['admin/content/book/%node'] = array(
    'title' => 'Re-order book pages and change titles',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('book_admin_edit', 3),
    'access callback' => '_book_outline_access',
    'access arguments' => array(3),
    'type' => MENU_CALLBACK,
  );
  $items['book'] = array(
    'title' => 'Books',
    'page callback' => 'book_render',
    'access arguments' => array('access content'),
    'type' => MENU_SUGGESTED_ITEM,
  );
  $items['book/export/%/%'] = array(
    'page callback' => 'book_export',
    'page arguments' => array(2, 3),
    'access arguments' => array('access printer-friendly version'),
    'type' => MENU_CALLBACK,
  );
  $items['node/%node/outline'] = array(
    'title' => 'Outline',
    'page callback' => 'book_outline',
    'page arguments' => array(1),
    'access callback' => '_book_outline_access',
    'access arguments' => array(1),
    'type' => MENU_LOCAL_TASK,
    'weight' => 2,
  );
  $items['node/%node/outline/remove'] = array(
    'title' => 'Remove from outline',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('book_remove_form', 1),
    'access callback' => '_book_outline_remove_access',
    'access arguments' => array(1),
    'type' => MENU_CALLBACK,
  );
  $items['book-form-update/%/%'] = array(
    'page callback' => 'book_form_update',
    'page arguments' => array(1, 2),
    'access arguments' => array('access content'),
    'type' => MENU_CALLBACK,
  );
  return $items;
}

/**
 * Menu item access callback - determine if the outline tab is accessible.
 */
function _book_outline_access($node) {
  return user_access('administer book outlines') && node_access('view', $node);
}

/**
 * Menu item access callback - determine if the user can remove nodes from the outline.
 */
function _book_outline_remove_access($node) {
  return isset($node->book) && ($node->book['bid'] != $node->nid) && _book_outline_access($node);
}

/**
 * Implementation of hook_init(). Add's the book module's CSS.
 */
function book_init() {
  drupal_add_css(drupal_get_path('module', 'book') .'/book.css');
}

/**
 * Implementation of hook_block().
 *
 * Displays the book table of contents in a block when the current page is a
 * single-node view of a book node.
 */
function book_block($op = 'list', $delta = 0, $edit = array()) {
  $block = array();
  switch ($op) {
    case 'list':
      $block[0]['info'] = t('Book navigation');
      return $block;
    case 'view':
      if (arg(0) == 'node' && is_numeric(arg(1))) {
        $node = node_load(arg(1));
      }
      $current_bid = empty($node->book['bid']) ? 0 : $node->book['bid'];
      $mode = variable_get('book_block_mode', 'all pages');
      if ($mode == 'all pages') {
        $block['subject'] = t('Book navigation');
        $book_menus = array();
        $pseudo_tree = array(0 => array('below' => FALSE));
        foreach (book_get_books() as $book) {
          if ($book['bid'] == $current_bid) {
            // If the current page is a node associated with a book, the menu
            // needs to be retrieved.
            $book_menus[] = menu_tree_output(menu_tree_all_data($node->book['menu_name'], $node->book));
          }
          else {
            // Since we know we will only display a link to the top node, there
            // is no reason to run an additional menu tree query for each book.
            $book['in_active_trail'] = FALSE;
            $pseudo_tree[0]['link'] = $book;
            $book_menus[] = menu_tree_output($pseudo_tree);
          }
        }
        $block['content'] = theme('book_all_books_block', $book_menus);
      }
      elseif ($current_bid) {
        // Only display this block when the user is browsing a book.
        $title = db_result(db_query(db_rewrite_sql('SELECT n.title FROM {node} n WHERE n.nid = %d'), $node->book['bid']));
        // Only show the block if the user has view access for the top-level node.
        if ($title) {
          $tree = menu_tree_all_data($node->book['menu_name'], $node->book);
          // There should only be one element at the top level.
          $data = array_shift($tree);
          $block['subject'] = theme('book_title_link', $data['link']);
          $block['content'] = ($data['below']) ? menu_tree_output($data['below']) : '';
        }
      }
      return $block;
    case 'configure':
      $options = array(
        'all pages' => t('Show block on all pages'),
        'book pages' => t('Show block only on book pages'),
      );
      $form['book_block_mode'] = array(
        '#type' => 'radios',
        '#title' => t('Book navigation block display'),
        '#options' => $options,
        '#default_value' => variable_get('book_block_mode', 'all pages'),
        '#description' => t("If <em>Show block on all pages</em> is selected, the block will contain the automatically generated menus for all of the site's books. If <em>Show block only on book pages</em> is selected, the block will contain only the one menu corresponding to the current page's book. In this case, if the current page is not in a book, no block will be displayed.  The <em>Page specific visibility settings</em> or other visibility settings can be used in addition to selectively display this block."),
        );
      return $form;
    case 'save':
      variable_set('book_block_mode', $edit['book_block_mode']);
      break;
  }
}

/**
 * Generate the HTML output for the block showing all book menus.
 *
 * @ingroup themeable
 */
function theme_book_all_books_block($book_menus) {
  $output = '';
  foreach ($book_menus as $menu) {
    $output .= '<div class="book-block-menu">'. $menu ."</div>\n";
  }
  return $output;
}

/**
 * Generate the HTML output for a link to a book title when used as a block title.
 *
 * @ingroup themeable
 */
function theme_book_title_link($link) {
  $link['options']['attributes']['class'] =  'book-title';
  return l($link['title'], $link['href'], $link['options']);
}

/**
 * Returns an array of all books.
 *
 * This list may be used for generating a list of all the books, or for building
 * the options for a form select.
 */
function book_get_books() {
  static $all_books;

  if (!isset($all_books)) {
    $all_books = array();
    $result = db_query("SELECT DISTINCT(bid) FROM {book}");
    $nids = array();
    while ($book = db_fetch_array($result)) {
      $nids[] = $book['bid'];
    }
    if ($nids) {
      $result2 = db_query(db_rewrite_sql("SELECT n.type, n.title, b.*, ml.* FROM {book} b INNER JOIN {node} n on b.nid = n.nid INNER JOIN {menu_links} ml ON b.mlid = ml.mlid WHERE n.nid IN (". implode(',', $nids). ") AND n.status = 1 ORDER BY ml.weight, ml.link_title"));
      while ($link = db_fetch_array($result2)) {
        $link['href'] = $link['link_path'];
        $link['options'] = unserialize($link['options']);
        $all_books[] = $link;
      }
    }
  }
  return $all_books;
}

/**
 * AJAX callback to replace the book parent select options.
 *
 * This function is called when the selected book is changed.  It updates the
 * cached form (either the node form or the book outline form) and returns
 * rendered output to be used to replace the select containing the possible
 * parent pages in the newly selected book.
 *
 * @param $build_id
 *   The form's build_id.
 * @param $bid
 *   A bid from from among those in the form's book select.
 * @return
 *   Prints the replacement HTML in JSON format.
 */
function book_form_update($build_id, $bid) {

  $cid = 'form_'. $build_id;
  $cache = cache_get($cid, 'cache_form');
  if ($cache) {
    $form = $cache->data;

    // Validate the bid.
    if (isset($form['book']['bid']['#options'][$bid])) {
      $book_link = $form['#node']->book;
      $book_link['bid'] = $bid;
      // Get the new options and update the cache.
      $form['book']['plid'] = _book_parent_select($book_link);
      // We set an updated expiration time for the cached form using the same
      // formula as used originally in function drupal_get_form()
      $expire = max(ini_get('session.cookie_lifetime'), 86400);
      cache_set($cid, $form, 'cache_form', $expire);

      // Build and render the new select element, then return it in JSON format.
      $form_state = array();
      $form['#post'] = array();
      $form = form_builder($form['form_id']['#value'] , $form, $form_state);
      $output = drupal_render($form['book']['plid']);
      drupal_json(array('book' => $output));
    }
  }
  exit();
}

/**
 * Implementation of hook_form_alter(). Adds the book fieldset to the node form.
 *
 * @see book_pick_book_submit()
 * @see book_submit()
 */
function book_form_alter(&$form, $form_state, $form_id) {

  if (isset($form['type']) && isset($form['#node']) && $form['type']['#value'] .'_node_form' == $form_id) {
    // Add elements to the node form
    $node = $form['#node'];

    $access = user_access('administer book outlines');
    if (!$access) {
      if (user_access('add content to books') && ((!empty($node->book['mlid']) && !empty($node->nid)) || book_type_is_allowed($node->type))) {
        // Already in the book hierarchy or this node type is allowed
        $access = TRUE;
      }
    }

    if ($access) {
      _book_add_form_elements($form, $node);
      $form['book']['pick-book'] = array(
        '#type' => 'submit',
        '#value' => t('Change book (update list of parents)'),
         // Submit the node form so the parent select options get updated.
         // This is typically only used when JS is disabled.  Since the parent options
         // won't be changed via AJAX, a button is provided in the node form to submit
         // the form and generate options in the parent select corresponding to the
         // selected book.  This is similar to what happens during a node preview.
        '#submit' => array('node_form_submit_build_node'),
        '#weight' => 20,
      );
    }
  }
}

/**
 * Build the parent selection form element for the node form or outline tab
 *
 * This function is also called when generating a new set of options during the
 * AJAX callback, so an array is returned that can be used to replace an existing
 * form element.
 */
function _book_parent_select($book_link) {
  // Offer a message or a drop-down to choose a different parent page.
  $form = array(
    '#type' => 'hidden',
    '#value' => -1,
    '#prefix' => '<div id="edit-book-plid-wrapper">',
    '#suffix' => '</div>',
  );

  if ($book_link['nid'] === $book_link['bid']) {
    // This is a book - at the top level.
    if ($book_link['original_bid'] === $book_link['bid']) {
      $form['#prefix'] .= '<em>'. t('This is the top-level page in this book.') .'</em>';
    }
    else {
      $form['#prefix'] .= '<em>'. t('This will be the top-level page in this book.') .'</em>';
    }
  }
  elseif (!$book_link['bid']) {
    $form['#prefix'] .= '<em>'. t('No book selected.') .'</em>';
  }
  else {
    $form = array(
      '#type' => 'select',
      '#title' => t('Parent item'),
      '#default_value' => $book_link['plid'],
      '#description' => t('The parent page in the book.'),
      '#options' => book_toc($book_link['bid'], array($book_link['mlid'])),
    );
  }
  return $form;
}

/**
 * Build the common elements of the book form for the node and outline forms.
 */
function _book_add_form_elements(&$form, $node) {
  $settings['book']['formCallback'] = url('book-form-update' , array());
  $settings['book']['formId'] = $form['#id'];
  drupal_add_js($settings, 'setting');
  drupal_add_js(drupal_get_path('module', 'book'). '/book.js');
  drupal_add_js('misc/progress.js');

  // Need this for AJAX.
  $form['#cache'] = TRUE;

  $form['book'] = array(
    '#type' => 'fieldset',
    '#title' => t('Book outline'),
    '#weight' => 10,
    '#collapsible' => TRUE,
    '#collapsed' => TRUE,
    '#tree' => TRUE,
  );
  foreach (array('menu_name', 'mlid', 'nid', 'router_path', 'has_children', 'options', 'module', 'original_bid') as $key) {
    $form['book'][$key] = array(
      '#type' => 'value',
      '#value' => $node->book[$key],
    );
  }

  $form['book']['plid'] = _book_parent_select($node->book);

  $form['book']['weight'] = array(
    '#type' => 'weight',
    '#title' => t('Weight'),
    '#default_value' => $node->book['weight'],
    '#delta' => 15,
    '#weight' => 5,
    '#description' => t('Pages at a given level are ordered first by weight and then by title.'),
  );
  $options = array();

  foreach (book_get_books() as $book) {
    $options[$book['nid']] = $book['title'];
  }
  $nid = isset($node->nid) ? $node->nid : 'new';
  if (user_access('create new books') && ($nid == 'new' || ($nid != $node->book['original_bid']))) {
    // The node can become a new book, if it is not one already.
    $options = array($nid => '<'. t('create a new book') .'>') + $options;
  }
  if (!$node->book['mlid']) {
    // The node is not currently in a the hierarchy.
    $options = array(0 => '<'. t('none') .'>') + $options;
  }

  // Add a drop-down to select the destination book.
  $form['book']['bid'] = array(
    '#type' => 'select',
    '#title' => t('Book'),
    '#default_value' => $node->book['bid'],
    '#options' => $options,
    '#access' => (bool)$options,
    '#description' => t('Your page will be a part of the selected book.'),
    '#weight' => -5,
  );
}

/**
 * Menu callback; show the outline form for a single node.
 */
function book_outline($node) {
  drupal_set_title(check_plain($node->title));
  return drupal_get_form('book_outline_form', $node);
}

/**
 * Build the form to handle all book outline operations via the outline tab.
 *
 * @see book_outline_form_submit()
 * @see book_remove_button_submit()
 *
 * @ingroup forms
 */
function book_outline_form(&$form_state, $node) {

  if (!isset($node->book)) {
    // The node is not part of any book yet - set default options.
    $node->book = _book_link_defaults($node->nid);
  }
  else {
    $node->book['original_bid'] = $node->book['bid'];
  }
  $form['#node'] = $node;
  $form['#id'] = 'book-outline';
  _book_add_form_elements($form, $node);

  $form['book']['#collapsible'] = FALSE;

  $form['book']['update'] = array(
    '#type' => 'submit',
    '#value' => $node->book['original_bid'] ? t('Update book outline') : t('Add to book outline'),
    '#weight' => 15,
  );

  $form['book']['remove'] = array(
    '#type' => 'submit',
    '#value' => t('Remove from book outline'),
    '#access' => $node->nid != $node->book['bid'] && $node->book['bid'],
    '#weight' => 20,
    '#submit' => array('book_remove_button_submit'),
  );

  return $form;
}

/**
 * Button submit function to redirect to removal confirm form.
 *
 * @see book_outline_form()
 */
function book_remove_button_submit($form,  &$form_state) {
  $form_state['redirect'] = 'node/'. $form['#node']->nid .'/outline/remove';
}

/**
 * Menu callback; builds a form to confirm removal of a node from the book.
 *
 * @see book_remove_form_submit()
 *
 * @ingroup forms
 */
function book_remove_form(&$form_state, $node) {
  $form['#node'] = $node;

  return confirm_form($form, t('Are you sure you want to remove %title from the book hierarchy?', array('%title' => $node->title)), 'node/'. $node->nid, array('yes' => t('Remove')));
}

/**
 * Confirm form submit function to remove a node from the book.
 *
 * @see book_remove_form()
 */
function book_remove_form_submit($form, &$form_state) {
  $node = $form['#node'];
  if ($node->nid != $node->book['bid']) {
    // Only allowed when this is not a book (top-level page).
    menu_link_delete($node->book['mlid']);
    db_query('DELETE FROM {book} WHERE nid = %d', $node->nid);
    drupal_set_message(t('The post has been removed from the book.'));
  }
  $form_state['redirect'] = 'node/'. $node->nid;
}

/**
 * Common helper function to handles additions and updates to the book outline.
 *
 * Performs all additions and updates to the book outline through node addition,
 * node editing, node deletion, or the outline tab.
 */
function _book_update_outline(&$node) {
  if (empty($node->book['bid'])) {
    return FALSE;
  }
  $new = empty($node->book['mlid']);

  $node->book['link_path'] = 'node/'. $node->nid;
  $node->book['link_title'] = $node->title;
  $node->book['parent_mismatch'] = FALSE; // The normal case.

  if ($node->book['bid'] == $node->nid) {
    $node->book['plid'] = 0;
    $node->book['menu_name'] = book_menu_name($node->nid);
  }
  else {
    // Check in case the parent is not is this book; the book takes precedence.
    if (!empty($node->book['plid'])) {
      $parent = db_fetch_array(db_query("SELECT * FROM {book} WHERE mlid = %d", $node->book['plid']));
    }
    if (empty($node->book['plid']) || !$parent || $parent['bid'] != $node->book['bid']) {
      $node->book['plid'] = db_result(db_query("SELECT mlid FROM {book} WHERE nid = %d", $node->book['bid']));
      $node->book['parent_mismatch'] = TRUE; // Likely when JS is disabled.
    }
  }
  if (menu_link_save($node->book)) {
    if ($new) {
      // Insert new.
      db_query("INSERT INTO {book} (nid, mlid, bid) VALUES (%d, %d, %d)", $node->nid, $node->book['mlid'], $node->book['bid']);
    }
    else {
      if ($node->book['bid'] != db_result(db_query("SELECT bid FROM {book} WHERE nid = %d", $node->nid))) {
        // Update the bid for this page and all children.
        book_update_bid($node->book);
      }
    }
    return TRUE;
  }
  // Failed to save the menu link
  return FALSE;
}

/**
 * Handles book outline form submissions from the outline tab.
 *
 * @see book_outline_form()
 */
function book_outline_form_submit($form, &$form_state) {
  $node = $form['#node'];
  $form_state['redirect'] = "node/". $node->nid;
  $book_link = $form_state['values']['book'];
  if (!$book_link['bid']) {
    drupal_set_message(t('No changes were made'));
    return;
  }

  $book_link['menu_name'] = book_menu_name($book_link['bid']);
  $node->book = $book_link;
  if (_book_update_outline($node)) {
    if ($node->book['parent_mismatch']) {
      // This will usually only happen when JS is disabled.
      drupal_set_message(t('The post has been added to the selected book. You may now position it relative to other pages.'));
      $form_state['redirect'] = "node/". $node->nid ."/outline";
    }
    else {
      drupal_set_message(t('The book outline has been updated.'));
    }
  }
  else {
    drupal_set_message(t('There was an error adding the post to the book.'));
  }
}

/**
 * Update the bid for a page and its children when it is moved to a new book.
 *
 * @param $book_link
 *   A fully loaded menu link that is part of the book hierarchy.
 */
function book_update_bid($book_link) {

  for ($i = 1; $i <= MENU_MAX_DEPTH && $book_link["p$i"]; $i++) {
    $match[] = "p$i = %d";
    $args[] = $book_link["p$i"];
  }
  $result = db_query("SELECT mlid FROM {menu_links} WHERE ". implode(' AND ', $match), $args);

  $mlids = array();
  while ($a = db_fetch_array($result)) {
    $mlids[] = $a['mlid'];
  }
  if ($mlids) {
    db_query("UPDATE {book} SET bid = %d WHERE mlid IN (". implode(',', $mlids) .")", $book_link['bid']);
  }
}

/**
 * Get the book menu tree for a page, and return it as a linear array.
 *
 * @param $book_link
 *   A fully loaded menu link that is part of the book hierarchy.
 * @return
 *   A linear array of menu links in the order that the links are shown in the
 *   menu, so the previous and next pages are the elements before and after the
 *   element corresponding to $node.  The children of $node (if any) will come
 *   immediately after it in the array.
 */
function book_get_flat_menu($book_link) {
  static $flat = array();

  if (!isset($flat[$book_link['mlid']])) {
    // Call menu_tree_full_data() to take advantage of the menu system's caching.
    $tree = menu_tree_all_data($book_link['menu_name'], $book_link);
    $flat[$book_link['mlid']] = array();
    _book_flatten_menu($tree, $flat[$book_link['mlid']]);
  }
  return $flat[$book_link['mlid']];
}

/**
 * Recursive helper function for book_get_flat_menu().
 */
function _book_flatten_menu($tree, &$flat) {
  foreach ($tree as $data) {
    if (!$data['link']['hidden']) {
      $flat[$data['link']['mlid']] = $data['link'];
      if ($data['below']) {
        _book_flatten_menu($data['below'], $flat);
      }
    }
  }
}

/**
 * Fetches the menu link for the previous page of the book.
 */
function book_prev($book_link) {
  // If the parent is zero, we are at the start of a book.
  if ($book_link['plid'] == 0) {
    return NULL;
  }
  $flat = book_get_flat_menu($book_link);
  // Assigning the array to $flat resets the array pointer for use with each().
  $curr = NULL;
  do {
    $prev = $curr;
    list($key, $curr) = each($flat);
  } while ($key && $key != $book_link['mlid']);

  if ($key == $book_link['mlid']) {
    // The previous page in the book may be a child of the previous visible link.
    if ($prev['depth'] == $book_link['depth'] && $prev['has_children']) {
      // The subtree will have only one link at the top level - get its data.
      $data = array_shift(book_menu_subtree_data($prev));
      // The link of interest is the last child - iterate to find the deepest one.
      while ($data['below']) {
        $data = end($data['below']);
      }
      return $data['link'];
    }
    else {
      return $prev;
    }
  }
}

/**
 * Fetches the menu link for the next page of the book.
 */
function book_next($book_link) {
  $flat = book_get_flat_menu($book_link);
  // Assigning the array to $flat resets the array pointer for use with each().
  do {
    list($key, $curr) = each($flat);
  } while ($key && $key != $book_link['mlid']);
  if ($key == $book_link['mlid']) {
    return current($flat);
  }
}

/**
 * Format the menu links for the child pages of the current page.
 */
function book_children($book_link) {
  $flat = book_get_flat_menu($book_link);

  $children = array();

  if ($book_link['has_children']) {
    // Walk through the array until we find the current page.
    do {
      $link = array_shift($flat);
    } while ($link && ($link['mlid'] != $book_link['mlid']));
    // Continue though the array and collect the links whose parent is this page.
    while (($link = array_shift($flat)) && $link['plid'] == $book_link['mlid']) {
      $data['link'] = $link;
      $data['below'] = '';
      $children[] = $data;
    }
  }
  return $children ? menu_tree_output($children) : '';
}

/**
 * Generate the corresponding menu name from a book ID.
 */
function book_menu_name($bid) {
  return 'book-toc-'. $bid;
}

/**
 * Build an active trail to show in the breadcrumb.
 */
function book_build_active_trail($book_link) {
  static $trail;

  if (!isset($trail)) {
    $trail = array();
    $trail[] = array('title' => t('Home'), 'href' => '<front>', 'options' => array());

    $tree = menu_tree_all_data($book_link['menu_name'], $book_link);
    $curr = array_shift($tree);

    while ($curr) {
      if ($curr['link']['href'] == $book_link['href']) {
        $trail[] = $curr['link'];
        $curr = FALSE;
      }
      else {
        if ($curr['below'] && $curr['link']['in_active_trail']) {
          $trail[] = $curr['link'];
          $tree = $curr['below'];
        }
        $curr = array_shift($tree);
      }
    }
  }
  return $trail;
}

/**
 * Implementation of hook_nodeapi().
 *
 * Appends book navigation to all nodes in the book, and handles book outline
 * insertions and updates via the node form.
 */
function book_nodeapi(&$node, $op, $teaser, $page) {
  switch ($op) {
    case 'load':
      // Note - we cannot use book_link_load() because it will call node_load()
      $info['book'] = db_fetch_array(db_query('SELECT * FROM {book} b INNER JOIN {menu_links} ml ON b.mlid = ml.mlid WHERE b.nid = %d', $node->nid));
      if ($info['book']) {
        $info['book']['href'] = $info['book']['link_path'];
        $info['book']['title'] = $info['book']['link_title'];
        $info['book']['options'] = unserialize($info['book']['options']);
        return $info;
      }
      break;
    case 'view':
    if (!$teaser) {
        if (!empty($node->book['bid']) && $node->build_mode == NODE_BUILD_NORMAL) {

          $node->content['book_navigation'] = array(
            '#value' => theme('book_navigation', $node->book),
            '#weight' => 100,
          );

          if ($page) {
            menu_set_active_trail(book_build_active_trail($node->book));
            menu_set_active_menu_name($node->book['menu_name']);
          }
        }
      }
      break;
    case 'presave':
      // Always save a revision for non-administrators.
      if (!empty($node->book['bid']) && !user_access('administer nodes')) {
        $node->revision = 1;
      }
      break;
    case 'insert':
    case 'update':
      if (!empty($node->book['bid'])) {
        if ($node->book['bid'] == 'new') {
          // New nodes that are their own book.
          $node->book['bid'] = $node->nid;
        }
        $node->book['nid'] = $node->nid;
        $node->book['menu_name'] = book_menu_name($node->book['bid']);
        _book_update_outline($node);
      }
      break;
    case 'delete':
      if (!empty($node->book['bid'])) {
        if ($node->nid == $node->book['bid']) {
          // Handle deletion of a top-level post.
          $result = db_query("SELECT b.nid FROM {menu_links} ml INNER JOIN {book} b on b.mlid = ml.mlid WHERE ml.plid = %d", $node->book['mlid']);
          while ($child = db_fetch_array($result)) {
            $child_node = node_load($child['nid']);
            $child_node->book['bid'] = $child_node->nid;
            _book_update_outline($child_node);
          }
        }
        menu_link_delete($node->book['mlid']);
        db_query('DELETE FROM {book} WHERE mlid = %d', $node->book['mlid']);
      }
      break;
    case 'prepare':
      // Prepare defaults for the add/edit form.
      if (empty($node->book) && (user_access('add content to books') || user_access('administer book outlines'))) {
        $node->book = array();
        if (empty($node->nid) && isset($_GET['parent']) && is_numeric($_GET['parent'])) {
          // Handle "Add child page" links:
          $parent = book_link_load($_GET['parent']);
          if ($parent && $parent['access']) {
            $node->book['bid'] = $parent['bid'];
            $node->book['plid'] = $parent['mlid'];
            $node->book['menu_name'] = $parent['menu_name'];
          }
        }
        // Set defaults.
        $node->book += _book_link_defaults(!empty($node->nid) ? $node->nid : 'new');
      }
      else {
        if (isset($node->book['bid']) && !isset($node->book['original_bid'])) {
          $node->book['original_bid'] = $node->book['bid'];
        }
      }
      break;
  }
}

/**
 * Form altering function for the confirm form for a single node deletion.
 */
function book_form_node_delete_confirm_alter(&$form, $form_state) {

  $node = node_load($form['nid']['#value']);

  if (isset($node->book) && $node->book['has_children']) {
    $form['book_warning'] = array(
      '#value' => '<p>'. t('%title is part of a book outline, and has associated child pages. If you proceed with deletion, the child pages will be relocated automatically.', array('%title' => $node->title)) .'</p>',
      '#weight' => -10,
    );
  }
}

/**
 * Return an array with default values for a book link.
 */
function _book_link_defaults($nid) {
  return array('original_bid' => 0, 'menu_name' => '', 'nid' => $nid, 'bid' => 0, 'router_path' => 'node/%', 'plid' => 0, 'mlid' => 0, 'has_children' => 0, 'weight' => 0, 'module' => 'book', 'options' => array());
}

/**
 * Prepares the links to the children of the page and the previous/up/next navigation.
 *
 * These navigation elements are added to the content of a node in the book
 * outline when it is viewed as a page and in similar contexts.
 *
 * @ingroup themeable
 */
function theme_book_navigation($book_link) {
  $output = '';
  $links = '';

  if ($book_link['mlid']) {
    $tree = book_children($book_link);

    if ($prev = book_prev($book_link)) {
      drupal_add_link(array('rel' => 'prev', 'href' => url($prev['href'])));
      $links .= l(t('‹ ') . $prev['title'], $prev['href'], array('attributes' => array('class' => 'page-previous', 'title' => t('Go to previous page'))));
    }
    if ($book_link['plid'] && $parent = book_link_load($book_link['plid'])) {
      drupal_add_link(array('rel' => 'up', 'href' => url($parent['href'])));
      $links .= l(t('up'), $parent['href'], array('attributes' => array('class' => 'page-up', 'title' => t('Go to parent page'))));
    }
    if ($next = book_next($book_link)) {
      drupal_add_link(array('rel' => 'next', 'href' => url($next['href'])));
      $links .= l($next['title'] . t(' ›'), $next['href'], array('attributes' => array('class' => 'page-next', 'title' => t('Go to next page'))));
    }

    if (isset($tree) || isset($links)) {
      $output = '<div class="book-navigation">';
      if (isset($tree)) {
        $output .= $tree;
      }
      if (isset($links)) {
        $output .= '<div class="page-links clear-block">'. $links .'</div>';
      }
      $output .= '</div>';
    }
  }

  return $output;
}

/**
 * A recursive helper function for book_toc().
 */
function _book_toc_recurse($tree, $indent, &$toc, $exclude) {
  foreach ($tree as $data) {
    if (!in_array($data['link']['mlid'], $exclude)) {
      $toc[$data['link']['mlid']] = $indent .' '. truncate_utf8($data['link']['title'], 30, TRUE, TRUE);
      if ($data['below'] && $data['link']['depth'] < MENU_MAX_DEPTH - 1) {
        _book_toc_recurse($data['below'], $indent .'--', $toc, $exclude);
      }
    }
  }
}

/**
 * Returns an array of book pages in table of contents order.
 *
 * @param $bid
 *   The ID of the book whose pages are to be listed.
 * @param $exclude
 *   Optional array of mlid values.  Any link whose mlid is in this array
 *   will be excluded (along with its children).
 * @return
 *   An array of mlid, title pairs for use as options for selecting a book page.
 */
function book_toc($bid, $exclude = array()) {

  $tree = menu_tree_all_data(book_menu_name($bid));
  $toc = array();
  _book_toc_recurse($tree, '', $toc, $exclude);

  return $toc;
}

/**
 * Menu callback; prints a listing of all books.
 */
function book_render() {
  $book_list = array();
  foreach (book_get_books() as $book) {
    $book_list[] = l($book['title'], $book['href'], $book['options']);
  }

  return theme('item_list', $book_list);
}

/**
 * Menu callback; Generates various representation of a book page and its children.
 *
 * The function delegates the generation of output to helper functions.
 * The function name is derived by prepending 'book_export_' to the
 * given output type. So, e.g., a type of 'html' results in a call to
 * the function book_export_html().
 *
 * @param $type
 *   A string encoding the type of output requested. The following
 *   types are currently supported in book module:
 *
 *   - html: HTML (printer friendly output)
 *
 *   Other types may be supported in contributed modules.
 * @param $nid
 *   An integer representing the node id (nid) of the node to export
 * @return
 *   A string representing the node and its children in the book hierarchy
 *   in a format determined by the $type parameter.
 */
function book_export($type, $nid) {

  $type = drupal_strtolower($type);

  $export_function = 'book_export_'. $type;

  if (function_exists($export_function)) {
    print call_user_func($export_function, $nid);
  }
  else {
    drupal_set_message(t('Unknown export format.'));
    drupal_not_found();
  }
}

/**
 * This function is called by book_export() to generate HTML for export.
 *
 * The given node is /embedded to its absolute depth in a top level
 * section/. For example, a child node with depth 2 in the hierarchy
 * is contained in (otherwise empty) &lt;div&gt; elements
 * corresponding to depth 0 and depth 1. This is intended to support
 * WYSIWYG output - e.g., level 3 sections always look like level 3
 * sections, no matter their depth relative to the node selected to be
 * exported as printer-friendly HTML.
 *
 * @param $nid
 *   An integer representing the node id (nid) of the node to export.
 * @return
 *   A string containing HTML representing the node and its children in
 *   the book hierarchy.
 */
function book_export_html($nid) {
  if (user_access('access printer-friendly version')) {
    $content = '';
    $node = node_load($nid);
    if (isset($node->book)) {
      $depth = $node->book['depth'];
      for ($i = 1; $i < $depth; $i++) {
        $content .= "<div class=\"section-$i\">\n";
      }
      $tree = book_menu_subtree_data($node->book);
      $content .= book_export_traverse($tree, 'book_node_visitor_html_pre', 'book_node_visitor_html_post');

      for ($i = 1; $i < $depth; $i++) {
        $content .= "</div>\n";
      }
    }
    return theme('book_export_html', check_plain($node->title), $content);
  }
  else {
    drupal_access_denied();
  }
}

/**
 * How the book's HTML export should be themed
 *
 * @ingroup themeable
 */
function theme_book_export_html($title, $content) {
  global $base_url, $language;
  $html = "<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Transitional//EN\" \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\">\n";
  $html .= '<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">';
  $html .= "<head>\n<title>". $title ."</title>\n";
  $html .= '<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />';
  $html .= '<base href="'. $base_url .'/" />'."\n";
  $html .= "<style type=\"text/css\">\n@import url(misc/print.css);\n";
  if (defined('LANGUAGE_RTL') && $language->direction == LANGUAGE_RTL) {
    $html .= "@import url(misc/print-rtl.css);\n";
  }
  $html .= "</style>\n";
  $html .= "</head>\n<body>\n". $content ."\n</body>\n</html>\n";
  return $html;
}

/**
 * Traverse the book tree to build printable or exportable output.
 *
 * During the traversal, the $visit_pre() callback is applied to each
 * node, and is called recursively for each child of the node (in weight,
 * title order). Finally, the output of the $visit_post() callback is
 * appended before returning the generated output.
 *
 * @param $tree
 *   A subtree of the book menu hierarchy, rooted at the current page.
 * @param $visit_pre
 *   A function callback to be called upon visiting a node in the tree.
 * @param $visit_post
 *   A function callback to be called after visiting a node in the tree,
 *   but before recursively visiting children.
 * @return
 *   The output generated in visiting each node.
 */
function book_export_traverse($tree, $visit_pre, $visit_post) {
  $output = '';

  foreach ($tree as $data) {
    // Note- access checking is already performed when building the tree.
    $node = node_load($data['link']['nid'], FALSE);

    if ($node) {
      $depth = $node->book['depth'];
      if (function_exists($visit_pre)) {
        $output .= call_user_func($visit_pre, $node, $depth);
      }
      else {
        // Use the default function.
        $output .= book_node_visitor_html_pre($node, $depth);
      }

      if ($data['below']) {
        $output .= book_export_traverse($data['below'], $visit_pre, $visit_post);
      }

      if (function_exists($visit_post)) {
        $output .= call_user_func($visit_post, $node, $depth);
      }
      else {
        // Use the default function.
        $output .= book_node_visitor_html_post($node, $depth);
      }
    }
  }
  return $output;
}

/**
 * Generates printer-friendly HTML for a node.
 *
 * This function is a 'pre-node' visitor function.
 *
 * @see book_export_traverse().
 *
 * @param $node
 *   The node to generate output for.
 * @param $depth
 *   The depth of the given node in the hierarchy. This
 *   is used only for generating output.
 * @return
 *   The HTML generated for the given node.
 */
function book_node_visitor_html_pre($node, $depth) {

  $node->build_mode = NODE_BUILD_PRINT;
  $node = node_build_content($node, FALSE, FALSE);

  $output = "<div id=\"node-". $node->nid ."\" class=\"section-$depth\">\n";
  $output .= "<h1 class=\"book-heading\">". check_plain($node->title) ."</h1>\n";
  $output .= drupal_render($node->content);

  return $output;
}

/**
 * Finishes up generation of printer-friendly HTML after visiting a node.
 *
 * This function is a 'post-node' visitor function.
 *
 * @see book_export_traverse().
 *
 * @param $node
 *   The node to generate output for.
 * @param $depth
 *   The depth of the given node in the hierarchy. This
 *   is used only for generating output.
 * @return
 *   The HTML appended after the given node.
 */
function book_node_visitor_html_post($node, $depth) {
  return "</div>\n";
}

/**
 * Build the table portion of the form for the book administration page.
 *
 * @see book_admin_edit()
 */
function _book_admin_table($node) {
  $form = array(
    '#theme' => 'book_admin_table',
    '#tree' => TRUE,
  );

  $tree = book_menu_subtree_data($node->book);
  _book_admin_table_tree($tree, $form);
  return $form;
}

/**
 * Recursive helper to build the main table in the book administration page form.
 *
 * @see book_admin_edit()
 */
function _book_admin_table_tree($tree, &$form) {
  foreach ($tree as $data) {
    $form[] = array(
      'nid' => array('#type' => 'value', '#value' => $data['link']['nid']),
      'depth' => array('#type' => 'value', '#value' => $data['link']['depth']),
      'href' => array('#type' => 'value', '#value' => $data['link']['href']),
      'title' => array(
        '#type' => 'textfield',
        '#default_value' => $data['link']['link_title'],
        '#maxlength' => 255,
      ),
      'weight' => array(
        '#type' => 'weight',
        '#default_value' => $data['link']['weight'],
        '#delta' => 15,
      ),
    );
    if ($data['below']) {
      _book_admin_table_tree($data['below'], $form);
    }
  }

  return $form;
}

/**
 * Theme function for the book administration page form.
 *
 * @ingroup themeable
 */
function theme_book_admin_table($form) {

  $header = array(t('Title'), t('Weight'), array('data' => t('Operations'), 'colspan' => '3'));

  $rows = array();
  $destination = drupal_get_destination();
  $access = user_access('administer nodes');
  foreach (element_children($form) as $key) {
    $nid = $form[$key]['nid']['#value'];
    $href = $form[$key]['href']['#value'];
    $rows[] = array(
      '<div style="padding-left: '. (25 * $form[$key]['depth']['#value']) .'px;">'. drupal_render($form[$key]['title']) .'</div>',
      drupal_render($form[$key]['weight']),
      l(t('view'), $href),
      $access ? l(t('edit'), 'node/'. $nid .'/edit', array('query' => $destination)) : '&nbsp',
      $access ? l(t('delete'), 'node/'. $nid .'/delete', array('query' => $destination) )  : '&nbsp',
    );
  }

  return theme('table', $header, $rows);
}

/**
 * Build the form to administrate the hierarchy of a single book.
 *
 * @see book_admin_edit_submit()
 *
 * @ingroup forms.
 */
function book_admin_edit($form_state, $node) {

    drupal_set_title(check_plain($node->title));
    $form = array();

    $form['#node'] = $node;
    $form['table'] = _book_admin_table($node);
    $form['save'] = array(
      '#type' => 'submit',
      '#value' => t('Save book pages'),
    );
  return $form;
}

/**
 * Handle submission of the book administrative page form.
 *
 * @see book_admin_edit()
 */
function book_admin_edit_submit($form, &$form_state) {
  foreach ($form_state['values']['table'] as $row) {
    $node = node_load($row['nid'], FALSE);

    if ($row['title'] != $node->title || $row['weight'] != $node->book['weight']) {
      $node->title = $row['title'];
      $node->book['link_title'] = $row['title'];
      $node->book['weight'] = $row['weight'];
      $node->revision = 1;

      node_save($node);
      watchdog('content', 'book: updated %title.', array('%title' => $node->title), WATCHDOG_NOTICE, l(t('view'), 'node/'. $node->nid));
    }
  }
  // Insure we have the current title - it may have been changed in the form.
  $title = db_result(db_query("SELECT title FROM {node} WHERE nid = %d", $form['#node']->nid));
  drupal_set_message(t('Updated book %title.', array('%title' => $title)));
}

/**
 * Returns an administrative overview of all books.
 */
function book_admin_overview() {
  $rows = array();
  foreach (book_get_books() as $book) {
    $rows[] = array(l($book['title'], $book['href'], $book['options']), l(t('edit order and titles'), "admin/content/book/". $book['nid']));
  }
  $headers = array(t('Book'), t('Operations'));

  return theme('table', $headers, $rows);
}

/**
 * Determine if a given node type is in the list of types allowed for books.
 */
function book_type_is_allowed($type) {
  return in_array($type, variable_get('book_allowed_types', array('book')));
}

/**
 * Builds and returns the book settings form.
 *
 * @see book_admin_settings_validate()
 *
 * @ingroup forms
 */
function book_admin_settings() {

  $types = node_get_types('names');
  $form['book_allowed_types'] = array(
    '#type' => 'checkboxes',
    '#title' => t('Allowed book outline types'),
    '#default_value' => variable_get('book_allowed_types', array('book')),
    '#options' => $types,
    '#description' => t('Select content types which users with the %add-perm permission will be allowed to add to the book hierarchy. Users with the %outline-perm permission can add all content types.', array('%add-perm' => t('add content to books'),  '%outline-perm' => t('administer book outlines'))),
    '#required' => TRUE,
  );
  $form['book_child_type'] = array(
    '#type' => 'radios',
    '#title' => t('Default child page type'),
    '#default_value' => variable_get('book_child_type', 'book'),
    '#options' => $types,
    '#description' => t('The content type for the %add-child link must be one of those selected as an allowed book outline type.', array('%add-child' => t('Add child page'))),
    '#required' => TRUE,
  );
  $form['#validate'][] = 'book_admin_settings_validate';
  return system_settings_form($form);
}

/**
 * Validate the book settings form.
 *
 * @see book_admin_settings()
 */
function book_admin_settings_validate($form, &$form_state) {
  $child_type = $form_state['values']['book_child_type'];
  if (empty($form_state['values']['book_allowed_types'][$child_type])) {
    form_set_error('book_child_type', t('The content type for the %add-child link must be one of those selected as an allowed book outline type.', array('%add-child' => t('Add child page'))));
  }
}

/**
 * Implementation of hook_node_type().
 *
 * Update book module's persistent variables if the machine-readable name of a
 * node type is changed.
 */
function book_node_type($op, $type) {

  switch ($op){
    case 'update':
      if (!empty($type->old_type) && $type->old_type != $type->type) {
        // Update the list of node types that are allowed to be added to books.
        $allowed_types = variable_get('book_allowed_types', array('book'));
        $key = array_search($type->old_type, $allowed_types);
        if ($key !== FALSE) {
          $allowed_types[$type->type] = $allowed_types[$key] ? $type->type : 0;
          unset($allowed_types[$key]);
          variable_set('book_allowed_types', $allowed_types);
        }
        // Update the setting for the "Add child page" link.
        if (variable_get('book_child_type', 'book') == $type->old_type) {
          variable_set('book_child_type', $type->type);
        }
      }
      break;
  }
}

/**
 * Implementation of hook_help().
 */
function book_help($path, $arg) {
  switch ($path) {
    case 'admin/help#book':
      $output = '<p>'. t('The <em>book</em> module is suited for creating structured, multi-page hypertexts such as site resource guides, manuals, and Frequently Asked Questions (FAQs). It permits a document to have chapters, sections, subsections, etc. Authors with suitable permissions can add pages to a collaborative book,  placing them into the existing document by adding them to a table of contents menu.') .'</p>';
      $output .= '<p>'. t('Pages in the book hierarchy have navigation elements at the bottom of the page for moving through the text.  These link to the previous and next pages in the book, as well as a link labeled <em>up</em>, leading to the level above in the structure.  More comprehensive navigation may be provided by enabling the <em>book navigation block</em> on the <a href="@admin-block">block administration page</a>.', array('@admin-block' => url('admin/build/block'))) .'</p>';
      $output .= '<p>'. t('Users can select the <em>printer-friendly version</em> link visible at the bottom of a book page to generate a printer-friendly display of the page and all of its subsections. ') .'</p>';
      $output .= '<p>'. t("Users with the <em>administer book outlines</em> permission can add content of any type to a book, placing it into the existing book structure through the edit form or through the interface that's available by clicking on the <em>outline</em> tab while viewing that post.", array('%book' => node_get_types('name', 'book'))) .'</p>';
      $output .= '<p>'. t('Administrators can view a list of all books on the <a href="@admin-node-book">book administration page</a>.  In this list there is a link to an outline page for each book, from which is it possible to change the titles of sections, or to change their weight, thus reordering sections.', array('@admin-node-book' => url('admin/content/book'))) .'</p>';
      $output .= '<p>'. t('For more information please read the configuration and customization handbook <a href="@book">Book page</a>.', array('@book' => 'http://drupal.org/handbook/modules/book/')) .'</p>';
      return $output;
    case 'admin/content/book':
      return '<p>'. t('The book module offers a means to organize content, authored by many users, in an online manual, outline or FAQ.') .'</p>';
    case 'node/%/outline':
      return '<p>'. t('The outline feature allows you to include posts in the <a href="@book">book hierarchy</a>, as well as move them within the hierarchy or to <a href="@book-admin">reorder an entire book</a>.', array('@book' => url('book'), '@book-admin' => url('admin/content/book'))) .'</p>';
  }
}

/**
 * Like menu_link_load(), but adds additional data from the {book} table.
 *
 * Do not call when loading a node, since this function may call node_load().
 */
function book_link_load($mlid) {
  if ($item = db_fetch_array(db_query("SELECT * FROM {menu_links} ml INNER JOIN {book} b ON b.mlid = ml.mlid LEFT JOIN {menu_router} m ON m.path = ml.router_path WHERE ml.mlid = %d", $mlid))) {
    _menu_link_translate($item);
    return $item;
  }
  return FALSE;
}

/**
 * Get the data representing a subtree of the book hierarchy.
 *
 * The root of the subtree will be the link passed as a parameter, so the
 * returned tree will contain this item and all its descendents in the menu tree.
 *
 * @param $item
 *   A fully loaded menu link.
 * @return
 *   An subtree of menu links in an array, in the order they should be rendered.
 */
function book_menu_subtree_data($item) {
  static $tree = array();

  $cid = 'links:'. $item['menu_name'] .':subtree:'. $item['mlid'];

  if (!isset($tree[$cid])) {
    $cache = cache_get($cid, 'cache_menu');
    if ($cache && isset($cache->data)) {
      $data = $cache->data;
    }
    else {
      $i = 1;
      $match = array();
      while ($i <= MENU_MAX_DEPTH && $item["p$i"]) {
        $match[] = "p$i = %d";
        $args[] = $item["p$i"];
        $i++;
      }
      $sql = "
        SELECT b.*, m.load_functions, m.to_arg_functions, m.access_callback, m.access_arguments, m.page_callback, m.page_arguments, m.title, m.title_callback, m.title_arguments, m.type, ml.*
        FROM {menu_links} ml LEFT JOIN {menu_router} m ON m.path = ml.router_path
        INNER JOIN {book} b ON ml.mlid = b.mlid
        WHERE ml.hidden >= 0 AND ". implode(' AND ', $match) ."
        ORDER BY p1 ASC, p2 ASC, p3 ASC, p4 ASC, p5 ASC";

      $data['tree'] = menu_tree_data(db_query($sql, $args), array(), $item['depth']);
      $data['node_links'] = array();
      menu_tree_collect_node_links($data['tree'], $data['node_links']);
      // Cache the data.
      cache_set($cid, $data, 'cache_menu');
    }
    // Check access for the current user to each item in the tree.
    menu_tree_check_access($data['tree'], $data['node_links']);
    $tree[$cid] = $data['tree'];
  }

  return $tree[$cid];
}

