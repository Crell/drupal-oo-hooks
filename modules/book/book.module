<?php
// $Id$

/**
 * @file
 * Allows users to collaboratively author a book.
 */

/**
 * Implementation of hook_node_info().
 */
function book_node_info() {
  return array('book' => array('name' => t('book page'), 'base' => 'book'));
}

/**
 * Implementation of hook_perm().
 */
function book_perm() {
  return array('create book pages', 'maintain books', 'edit own book pages', 'export books', 'see printer-friendly version');
}

/**
 * Implementation of hook_access().
 */
function book_access($op, $node) {
  global $user;

  if ($op == 'create') {
    // Only registered users can create book pages.  Given the nature
    // of the book module this is considered to be a good/safe idea.
    return user_access('create book pages');
  }

  if ($op == 'update') {
    // Only registered users can update book pages.  Given the nature
    // of the book module this is considered to be a good/safe idea.
    // One can only update a book page if there are no suggested updates
    // of that page waiting for approval.  That is, only updates that
    // don't overwrite the current or pending information are allowed.

    if ((user_access('maintain books') && !$node->moderate) || ($node->uid == $user->uid && user_access('edit own book pages'))) {
      return TRUE;
    }
    else {
       // do nothing. node-access() will determine further access
    }
  }
}

/**
 * Implementation of hook_link().
 */
function book_link($type, $node = 0, $main = 0) {

  $links = array();

  if ($type == 'node' && isset($node->parent)) {
    if (!$main) {
      if (book_access('create', $node)) {
        $links[] = l(t('add child page'), "node/add/book/parent/$node->nid");
      }
      if (user_access('see printer-friendly version')) {
        $links[] = l(t('printer-friendly version'), 'book/export/html/'. $node->nid, array('title' => t('Show a printer-friendly version of this book page and its sub-pages.')));
      }
      if (user_access('export books')) {
        $links[] = l(t('export DocBook XML'), 'book/export/docbook/'. $node->nid, array('title' => t('Export this book page and its sub-pages as DocBook XML.')));
        $links[] = l(t('export OPML'), 'book/export/opml/'. $node->nid, array('title' => t('Export this book page and its sub-pages as OPML.')));
      }
    }
  }

  return $links;
}

/**
 * Implementation of hook_menu().
 */
function book_menu($may_cache) {
  $items = array();

  if ($may_cache) {
    $items[] = array(
      'path' => 'book',
      'title' => t('books'),
      'access' => user_access('access content'),
      'type' => MENU_NORMAL_ITEM,
      'weight' => 5);
    $items[] = array(
      'path' => 'node/add/book',
      'title' => t('book page'),
      'access' => user_access('create book pages'));
    $items[] = array(
      'path' => 'admin/node/book',
      'title' => t('books'),
      'callback' => 'book_admin',
      'access' => user_access('administer nodes'),
      'type' => MENU_LOCAL_TASK,
      'weight' => -1);
    $items[] = array(
      'path' => 'admin/node/book/list',
      'title' => t('list'),
      'type' => MENU_DEFAULT_LOCAL_TASK);
    $items[] = array(
      'path' => 'admin/node/book/orphan',
      'title' => t('orphan pages'),
      'callback' => 'book_admin_orphan',
      'type' => MENU_LOCAL_TASK,
      'weight' => 8);
    $items[] = array('path' => 'book', 'title' => t('books'),
      'callback' => 'book_render',
      'access' => user_access('access content'),
      'type' => MENU_SUGGESTED_ITEM);
    $items[] = array(
      'path' => 'book/export',
      'callback' => 'book_export',
      'access' => (user_access('export books') || user_access('see printer-friendly version')) && user_access('access content'),
      'type' => MENU_CALLBACK);
  }
  else {
    // To avoid SQL overhead, check whether we are on a node page and whether the
    // user is allowed to maintain books.
    if (arg(0) == 'node' && is_numeric(arg(1)) && user_access('maintain books')) {
      // Only add the outline-tab for non-book pages:
      $result = db_query(db_rewrite_sql("SELECT n.nid FROM {node} n WHERE n.nid = %d AND n.type != 'book'"), arg(1));
      if (db_num_rows($result) > 0) {
        $items[] = array('path' => 'node/'. arg(1) .'/outline', 'title' => t('outline'),
          'callback' => 'book_outline', 'access' => user_access('maintain books'),
          'type' => MENU_LOCAL_TASK, 'weight' => 2);
      }
    }
  }

  return $items;
}

/**
 * Implementation of hook_block().
 *
 * Displays the book table of contents in a block when the current page is a
 * single-node view of a book node.
 */
function book_block($op = 'list', $delta = 0) {
  $block = array();
  if ($op == 'list') {
    $block[0]['info'] = t('Book navigation');
    return $block;
  }
  else if ($op == 'view') {
    // Only display this block when the user is browsing a book:
    if (arg(0) == 'node' && is_numeric(arg(1))) {
      $result = db_query(db_rewrite_sql('SELECT n.nid, n.title, b.parent FROM {node} n INNER JOIN {book} b ON n.vid = b.vid WHERE n.nid = %d'), arg(1));
      if (db_num_rows($result) > 0) {
        $node = db_fetch_object($result);

        $path = book_location($node);
        $path[] = $node;

        $expand = array();
        foreach ($path as $key => $node) {
          $expand[] = $node->nid;
        }

        $block['subject'] = check_plain($path[0]->title);
        $block['content'] = book_tree($expand[0], 5, $expand);
      }
    }

    return $block;
  }
}

/**
 * Implementation of hook_load().
 */
function book_load($node) {
  global $user;

  $book = db_fetch_object(db_query('SELECT parent, weight FROM {book} WHERE vid = %d', $node->vid));

  if (arg(2) == 'edit' && !user_access('administer nodes')) {
    // If a user is about to update a book page, we overload some
    // fields to reflect the changes.
    if ($user->uid) {
      $book->uid = $user->uid;
      $book->name = $user->name;
    }
    else {
      $book->uid = 0;
      $book->name = '';
    }
  }

  return $book;
}

/**
 * Implementation of hook_insert().
 */
function book_insert($node) {
  db_query("INSERT INTO {book} (nid, vid, parent, weight) VALUES (%d, %d, %d, %d)", $node->nid, $node->vid, $node->parent, $node->weight);
}

/**
 * Implementation of hook_update().
 */
function book_update($node) {
  if ($node->revision) {
    db_query("INSERT INTO {book} (nid, vid, parent, weight) VALUES (%d, %d, %d, %d)", $node->nid, $node->vid, $node->parent, $node->weight);
  }
  else {
    db_query("UPDATE {book} SET parent = %d, weight = %d WHERE vid = %d", $node->parent, $node->weight, $node->vid);
  }
}

/**
 * Implementation of hook_delete().
 */
function book_delete(&$node) {
  db_query('DELETE FROM {book} WHERE nid = %d', $node->nid);
}

/**
 * Implementation of hook_execute().
 */
function book_execute(&$node) {
  // Set default values for non-administrators.
  if (!user_access('administer nodes')) {
    $node->weight = 0;
    $node->revision = 1;
  }
}

/**
 * Implementation of hook_validate().
 */
function book_validate($node) {
  node_validate_title($node);
}

/**
 * Implementation of hook_form().
 */
function book_form(&$node) {
  $form['parent'] = array(
    '#type' => 'select', '#title' => t('Parent'), '#default_value' => ($node->parent ? $node->parent : arg(4)), '#options' => book_toc($node->nid), '#weight' => -15,
    '#description' => t('The parent that this page belongs in. Note that pages whose parent is &lt;top-level&gt; are regarded as independent, top-level books.')
  );

  $form['title'] = array('#type' => 'textfield', '#title' => t('Title'), '#required' => TRUE, '#default_value' => $node->title);
  $form['body'] = array(
    '#type' => 'textarea', '#title' => t('Body'), '#default_value' => $node->body, '#rows' => 20, '#required' => TRUE
  );
  $form = array_merge($form, filter_form($node->format));

  $form['log'] = array(
    '#type' => 'fieldset', '#title' => t('Log message'), '#collapsible' => TRUE, '#collapsed' => TRUE
  );
  $form['log']['message'] = array(
    '#type' => 'textarea', '#default_value' => $node->log, '#weight' => 18,
    '#description' => t('An explanation of the additions or updates being made to help other authors understand your motivations.')
  );

  if (user_access('administer nodes')) {
    $form['weight'] = array(
        '#type' => 'weight', '#title' => t('Weight'),  '#default_value' => $node->weight, '#delta' => 15, '#weight' => -14,
        '#description' => t('Pages at a given level are ordered first by weight and then by title.')
    );
  }
  else {
    // If a regular user updates a book page, we create a new revision
    // authored by that user:
    $form['revision'] = array('#type' => 'hidden', '#value' => 1);
  }

  return $form;
}

/**
 * Implementation of function book_outline()
 * Handles all book outline operations.
 */
function book_outline() {

  $op = $_POST['op'];
  $edit = $_POST['edit'];
  $node = node_load(arg(1));

  if ($node->nid) {
    switch ($op) {
      case t('Add to book outline'):
        db_query('INSERT INTO {book} (nid, vid, parent, weight) VALUES (%d, %d, %d, %d)', $node->nid, $node->vid, $edit['parent'], $edit['weight']);
        db_query("UPDATE {node_revisions} SET log = '%s' WHERE vid = %d", $edit['log'], $node->vid);
        drupal_set_message(t('The post has been added to the book.'));
        drupal_goto("node/$node->nid");
        break;

      case t('Update book outline'):
        db_query('UPDATE {book} SET parent = %d, weight = %d WHERE vid = %d', $edit['parent'], $edit['weight'], $node->vid);
        db_query("UPDATE {node_revisions} SET log = '%s' WHERE vid = %d", $edit['log'], $node->vid);
        drupal_set_message(t('The book outline has been updated.'));
        drupal_goto("node/$node->nid");
        break;

      case t('Remove from book outline'):
        db_query('DELETE FROM {book} WHERE nid = %d', $node->nid);
        drupal_set_message(t('The post has been removed from the book.'));
        drupal_goto("node/$node->nid");
        break;

      default:
        $page = db_fetch_object(db_query('SELECT * FROM {book} WHERE vid = %d', $node->vid));

        $form['parent'] = array(
          '#type' => 'select', '#title' => t('Parent'), '#default_value' => $page->parent,
          '#options' => book_toc($node->nid), '#description' => t('The parent page in the book.')
        );

        $form['weight'] = array(
          '#type' => 'weight', '#title' => t('Weight'), '#default_value' => $page->weight, '#delta' => 15,
          '#description' => t('Pages at a given level are ordered first by weight and then by title.')
        );

        $form['log'] = array(
          '#type' => 'textarea', '#title' => t('Log message'),
          '#default_value' => $node->log, '#description' => t('An explanation to help other authors understand your motivations to put this post into the book.')
        );

        if ($page->nid) {
          $form['update'] = array('#type' => 'submit', '#value' => t('Update book outline'));
          $form['remove'] = array('#type' => 'submit', '#value' => t('Remove from book outline'));
        }
        else {
          $form['add'] = array('#type' => 'submit', '#value' => t('Add to book outline'));
        }

        drupal_set_title(check_plain($node->title));
        return drupal_get_form('book_outline', $form);
    }
  }
}

/**
 * Return the path (call stack) to a certain book page.
 */
function book_location($node, $nodes = array()) {
  $parent = db_fetch_object(db_query(db_rewrite_sql('SELECT n.nid, n.title, b.parent, b.weight FROM {node} n INNER JOIN {book} b ON n.vid = b.vid WHERE n.nid = %d'), $node->parent));
  if ($parent->title) {
    $nodes = book_location($parent, $nodes);
    array_push($nodes, $parent);
  }
  return $nodes;
}

/**
 * Accumulates the nodes up to the root of the book from the given node in the $nodes array.
 */
function book_location_down($node, $nodes = array()) {
  $last_direct_child = db_fetch_object(db_query(db_rewrite_sql('SELECT n.nid, n.title, b.parent, b.weight FROM {node} n INNER JOIN {book} b ON n.nid = b.nid WHERE n.status = 1 AND b.parent = %d ORDER BY b.weight DESC, n.title DESC'), $node->nid));
  if ($last_direct_child) {
    array_push($nodes, $last_direct_child);
    $nodes = book_location_down($last_direct_child, $nodes);
  }
  return $nodes;
}

/**
 * Fetches the node object of the previous page of the book.
 */
function book_prev($node) {
  // If the parent is zero, we are at the start of a book so there is no previous.
  if ($node->parent == 0) {
    return NULL;
  }

  // Previous on the same level:
  $direct_above = db_fetch_object(db_query(db_rewrite_sql("SELECT n.nid, n.title, b.weight FROM {node} n INNER JOIN {book} b ON n.vid = b.vid WHERE b.parent = %d AND n.status = 1 AND n.moderate = 0 AND (b.weight < %d OR (b.weight = %d AND n.title < '%s')) ORDER BY b.weight DESC, n.title DESC"), $node->parent, $node->weight, $node->weight, $node->title));
  if ($direct_above) {
    // Get last leaf of $above.
    $path = book_location_down($direct_above);

    return $path ? (count($path) > 0 ? array_pop($path) : NULL) : $direct_above;
  }
  else {
    // Direct parent:
    $prev = db_fetch_object(db_query(db_rewrite_sql('SELECT n.nid, n.title FROM {node} n INNER JOIN {book} b ON n.vid = b.vid WHERE n.nid = %d AND n.status = 1 AND n.moderate = 0'), $node->parent));
    return $prev;
  }
}

/**
 * Fetches the node object of the next page of the book.
 */
function book_next($node) {
  // get first direct child
  $child = db_fetch_object(db_query(db_rewrite_sql('SELECT n.nid, n.title, b.weight FROM {node} n INNER JOIN {book} b ON n.vid = b.vid WHERE b.parent = %d AND n.status = 1 AND n.moderate = 0 ORDER BY b.weight ASC, n.title ASC'), $node->nid));
  if ($child) {
    return $child;
  }

  // No direct child: get next for this level or any parent in this book.
  array_push($path = book_location($node), $node); // Path to top-level node including this one.

  while (($leaf = array_pop($path)) && count($path)) {
    $next = db_fetch_object(db_query(db_rewrite_sql("SELECT n.nid, n.title, b.weight FROM {node} n INNER JOIN {book} b ON n.vid = b.vid WHERE b.parent = %d AND n.status = 1 AND n.moderate = 0 AND (b.weight > %d OR (b.weight = %d AND n.title > '%s')) ORDER BY b.weight ASC, n.title ASC"), $leaf->parent, $leaf->weight, $leaf->weight, $leaf->title));
    if ($next) {
      return $next;
    }
  }
}

/**
 * Returns the content of a given node.  If $teaser if true, returns
 * the teaser rather than full content.  Displays the most recently
 * approved revision of a node (if any) unless we have to display this
 * page in the context of the moderation queue.
 */
function book_content($node, $teaser = FALSE) {
  $op = $_POST['op'];

  // Extract the page body.
  $node = node_prepare($node, $teaser);

  return $node;
}

/**
 * Implementation of hook_view().
 *
 * If not displayed on the main page, we render the node as a page in the
 * book with extra links to the previous and next pages.
 */
function book_view(&$node, $teaser = FALSE, $page = FALSE) {
  $node = book_content($node, $teaser);
}

/**
 * Implementation of hook_nodeapi().
 *
 * Appends book navigation to all nodes in the book.
 */
function book_nodeapi(&$node, $op, $teaser, $page) {
  switch ($op) {
    case 'view':
      if (!$teaser) {
        $book = db_fetch_array(db_query('SELECT * FROM {book} WHERE vid = %d', $node->vid));
        if ($book) {
          if ($node->moderate && user_access('administer nodes')) {
            drupal_set_message(t("The post has been submitted for moderation and won't be accessible until it has been approved."));
          }

          foreach ($book as $key => $value) {
            $node->$key = $value;
          }

          $path = book_location($node);
          // Construct the breadcrumb:
          $node->breadcrumb = array(); // Overwrite the trail with a book trail.
          foreach ($path as $level) {
            $node->breadcrumb[] = array('path' => 'node/'. $level->nid, 'title' =>  $level->title);
          }
          $node->breadcrumb[] = array('path' => 'node/'. $node->nid);

          $node->body .= theme('book_navigation', $node);

          if ($page) {
            menu_set_location($node->breadcrumb);
          }
        }
      }
      break;
  }
}

/**
 * Prepares both the custom breadcrumb trail and the forward/backward
 * navigation for a node presented as a book page.
 *
 * @ingroup themeable
 */
function theme_book_navigation($node) {
  if ($node->nid) {
    $output .= '<div class="book">';

    if ($tree = book_tree($node->nid)) {
      $output .= '<div class="tree">'. $tree .'</div>';
    }

    if ($prev = book_prev($node)) {
      drupal_add_link(array('rel' => 'prev', 'href' => url('node/'. $prev->nid)));
      $links .= '<div class="prev">';
      $links .= l(t('previous'), 'node/'. $prev->nid, array('title' => t('View the previous page.')));
      $links .= '</div>';
      $titles .= '<div class="prev">'. check_plain($prev->title) .'</div>';
    }
    else {
      $links .= '<div class="prev">&nbsp;</div>'; // Make an empty div to fill the space.
    }
    if ($next = book_next($node)) {
      drupal_add_link(array('rel' => 'next', 'href' => url('node/'. $next->nid)));
      $links .= '<div class="next">';
      $links .= l(t('next'), 'node/'. $next->nid, array('title' => t('View the next page.')));
      $links .= '</div>';
      $titles .= '<div class="next">'. check_plain($next->title) .'</div>';
    }
    else {
      $links .= '<div class="next">&nbsp;</div>'; // Make an empty div to fill the space.
    }
    if ($node->parent) {
      drupal_add_link(array('rel' => 'index', 'href' => url('node/'. $node->parent)));
      $links .= '<div class="up">';
      $links .= l(t('up'), 'node/'. $node->parent, array('title' => t('View this page\'s parent section.')));
      $links .= '</div>';
    }

    $output .= '<div class="nav">';
    $output .= ' <div class="links">'. $links .'</div>';
    $output .= ' <div class="titles">'. $titles .'</div>';
    $output .= '</div>';
    $output .= '</div>';
  }

  return $output;
}

/**
 * This is a helper function for book_toc().
 */
function book_toc_recurse($nid, $indent, $toc, $children, $exclude) {
  if ($children[$nid]) {
    foreach ($children[$nid] as $foo => $node) {
      if (!$exclude || $exclude != $node->nid) {
        $toc[$node->nid] = $indent .' '. $node->title;
        $toc = book_toc_recurse($node->nid, $indent .'--', $toc, $children, $exclude);
      }
    }
  }

  return $toc;
}

/**
 * Returns an array of titles and nid entries of book pages in table of contents order.
 */
function book_toc($exclude = 0) {
  $result = db_query(db_rewrite_sql('SELECT n.nid, n.title, b.parent, b.weight FROM {node} n INNER JOIN {book} b ON n.vid = b.vid WHERE n.status = 1 ORDER BY b.weight, n.title'));

  while ($node = db_fetch_object($result)) {
    if (!$children[$node->parent]) {
      $children[$node->parent] = array();
    }
    array_push($children[$node->parent], $node);
  }

  $toc = array();

  // If the user is an administrator, add the top-level book page;
  // only administrators can start new books.
  if (user_access('administer nodes')) {
    $toc[0] = '<'. t('top-level') .'>';
  }

  $toc = book_toc_recurse(0, '', $toc, $children, $exclude);

  return $toc;
}

/**
 * This is a helper function for book_tree()
 */
function book_tree_recurse($nid, $depth, $children, $unfold = array()) {
  if ($depth > 0) {
    if ($children[$nid]) {
      foreach ($children[$nid] as $foo => $node) {
        if (in_array($node->nid, $unfold)) {
          if ($tree = book_tree_recurse($node->nid, $depth - 1, $children, $unfold)) {
            $output .= '<li class="expanded">';
            $output .= l($node->title, 'node/'. $node->nid);
            $output .= '<ul>'. $tree .'</ul>';
            $output .= '</li>';
          }
          else {
            $output .= '<li class="leaf">'. l($node->title, 'node/'. $node->nid) .'</li>';
          }
        }
        else {
          if ($tree = book_tree_recurse($node->nid, 1, $children)) {
            $output .= '<li class="collapsed">'. l($node->title, 'node/'. $node->nid) .'</li>';
          }
          else {
            $output .= '<li class="leaf">'. l($node->title, 'node/'. $node->nid) .'</li>';
          }
        }
      }
    }
  }

  return $output;
}

/**
 * Returns an HTML nested list (wrapped in a menu-class div) representing the book nodes
 * as a tree.
 */
function book_tree($parent = 0, $depth = 3, $unfold = array()) {
  $result = db_query(db_rewrite_sql('SELECT n.nid, n.title, b.parent, b.weight FROM {node} n INNER JOIN {book} b ON n.vid = b.vid WHERE n.status = 1 AND n.moderate = 0 ORDER BY b.weight, n.title'));

  while ($node = db_fetch_object($result)) {
    $list = $children[$node->parent] ? $children[$node->parent] : array();
    array_push($list, $node);
    $children[$node->parent] = $list;
  }

  if ($tree = book_tree_recurse($parent, $depth, $children, $unfold)) {
    return '<div class="menu"><ul>'. $tree .'</ul></div>';
  }
}

/**
 * Menu callback; prints a listing of all books.
 */
function book_render() {
  $result = db_query(db_rewrite_sql('SELECT n.nid, n.title, b.weight FROM {node} n INNER JOIN {book} b ON n.vid = b.vid WHERE b.parent = 0 AND n.status = 1 AND n.moderate = 0 ORDER BY b.weight, n.title'));

  $books = array();
  while ($node = db_fetch_object($result)) {
    $books[] = l($node->title, 'node/'. $node->nid);
  }

  return theme('item_list', $books);
}

/**
 * Menu callback; Generates various representation of a book page with
 * all descendants and prints the requested representation to output.
 *
 * Notes: For HTML output, the given node is /embedded to its absolute
 * depth in a top level section/.  For example, a child node with
 * depth 2 in the hierarchy is contained in (otherwise empty) <div>
 * elements corresponding to depth 0 and depth 1.  This is intended to
 * support WYSIWYG output - e.g., level 3 sections always look like
 * level 3 sections, no matter their depth relative to the node
 * selected to be exported as printer-friendly HTML.
 *
 * DocBook XML and OPML outputs do not attempt to embed a node to its
 * absolute level in the parent book.

 *    For DocBook output, the exported node will be a document fragment
 * unless the node is a level 0 node (book), specifically
 *    <ul>
 *      <li>a <chapter> for level 1 elements, </li>
 *      <li>a <section> for levels 2 and deeper.</li>
 *    </ul>
 *
 *    For OPML output, the exported node will be the top level element
 * in the OPML outline.
 *
 * @param type
 *   - a string encoding the type of output requested.
 *       The following types are supported:
 *          1) HTML (printer friendly output)
 *          2) DocBook XML
 *          3) OPML (Outline Processor Markup Language) outlines
 * @param nid
 *   - an integer representing the node id (nid) of the node to export
 *
 */
function book_export($type = 'html', $nid = FALSE) {
  $type = drupal_strtolower($type);
  $node = node_load($nid);
  if ($node) {
    $depth = _book_get_depth($nid);
    switch ($type) {
      case 'docbook':
        if (user_access('export books')) {
          $xml = "<?xml version='1.0'?>\n";
          $xml .= "<!DOCTYPE book PUBLIC \"-//OASIS//DTD Docbook XML V4.1.2//EN\" \"http://www.oasis-open.org/docbook/xml/4.1.2/docbookx.dtd\">\n";
          $xml .= book_recurse($nid, $depth, 'book_node_visitor_xml_pre', 'book_node_visitor_xml_post');
          drupal_set_header('Content-Type: text/xml; charset=utf-8');
          print $xml;
        }
        else {
          drupal_access_denied();
        }
        break;
      case 'html':
        if (user_access('see printer-friendly version')) {
          for ($i = 1; $i < $depth; $i++) {
            $output .= "<div class=\"section-$i\">\n";
          }
          $output .= book_recurse($nid, $depth, 'book_node_visitor_html_pre', 'book_node_visitor_html_post');
          for ($i = 1; $i < $depth; $i++) {
            $output .= "</div>\n";
          }
          print theme('book_export_html', check_plain($node->title), $output);
        }
        else {
          drupal_access_denied();
        }
        break;
      case 'opml':
        if (user_access('export books')) {
          $output .= book_recurse($nid, $depth, 'book_node_visitor_opml_pre', 'book_node_visitor_opml_post');
          $opml  = "<?xml version='1.0'?>\n";
          $opml .= "<opml version='1.0'>\n";
          $opml .= "<head>\n<title>". check_plain($node->title) ."</title>\n";
          $opml .= "</head>\n<body>\n". $output . "\n</body>\n</opml>\n";
          drupal_set_header('Content-Type: text/xml; charset=utf-8');
          print $opml;
        }
        else {
          drupal_access_denied();
        }
        break;
      default:
        drupal_not_found();
    }
  }
  else {
    drupal_not_found();
  }
}

/**
 * How the book's HTML export should be themed
 *
 * @ingroup themeable
 */
function theme_book_export_html($title, $content) {
  global $base_url;
  $html = "<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Transitional//EN\" \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\">\n";
  $html .= '<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">';
  $html .= "<head>\n<title>". $title ."</title>\n";
  $html .= '<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />';
  $html .= '<base href="'. $base_url .'/" />' . "\n";
  $html .= "<style type=\"text/css\">\n@import url(misc/print.css);\n</style>\n";
  $html .= "</head>\n<body>\n". $content . "\n</body>\n</html>\n";
  return $html;
}

/**
 * Given a node, this function returns the depth of the node in its hierarchy.
 * A root node has depth 1, and children of a node of depth n have depth (n+1).
 *
 * @param node
 *   - the node whose depth to compute.
 * @return
 *   - the depth of the given node in its hierarchy.  Returns 0 if the node
 *  does not exist or is not part of a book hierarchy.
 */
function _book_get_depth($nid) {
  $depth = 0;
  if ($nid) {
    while ($nid) {
      $result = db_query(db_rewrite_sql('SELECT b.parent FROM {book} b WHERE b.nid = %d'), $nid);
      $obj =  db_fetch_object($result);
      $parent = $obj->parent;
      if ($nid == $parent->parent) {
        $nid = 0;
      }
      else {
        $nid = $parent;
      }
      $depth++;
    }
    return $depth;
  }
  else {
    return 0;
  }
}

/**
 * Traverses the book tree.  Applies the $visit_pre() callback to each
 * node, is called recursively for each child of the node (in weight,
 * title order).  Finally appends the output of the $visit_post()
 * callback to the output before returning the generated output.
 *
 * @param nid
 *  - the node id (nid) of the root node of the book hierarchy.
 * @param depth
 *  - the depth of the given node in the book hierarchy.
 * @param visit_pre
 *  - a function callback to be called upon visiting a node in the tree
 * @param visit_post
 *  - a function callback to be called after visiting a node in the tree,
 *    but before recursively visiting children.
 * @return
 *  - the output generated in visiting each node
 */
function book_recurse($nid = 0, $depth = 1, $visit_pre, $visit_post) {
  $result = db_query(db_rewrite_sql('SELECT n.nid, n.title, b.weight FROM {node} n INNER JOIN {book} b ON n.vid = b.vid WHERE n.status = 1 AND n.nid = %d AND n.moderate = 0 ORDER BY b.weight, n.title'), $nid);
  while ($page = db_fetch_object($result)) {
    // Load the node:
    $node = node_load($page->nid);

    if ($node) {
      if (function_exists($visit_pre)) {
        $output .= call_user_func($visit_pre, $node, $depth, $nid);
      }
      else {
        $output .= book_node_visitor_html_pre($node, $depth, $nid);
      }

      $children = db_query(db_rewrite_sql('SELECT n.nid, n.title, b.weight FROM {node} n INNER JOIN {book} b ON n.vid = b.vid WHERE n.status = 1 AND b.parent = %d AND n.moderate = 0 ORDER BY b.weight, n.title'), $node->nid);
      while ($childpage = db_fetch_object($children)) {
          $childnode = node_load($childpage->nid);
          if ($childnode->nid != $node->nid) {
              $output .= book_recurse($childnode->nid, $depth+1, $visit_pre, $visit_post);
          }
      }
      if (function_exists($visit_post)) {
        $output .= call_user_func($visit_post, $node, $depth);
      }
      else { # default
        $output .= book_node_visitor_html_post($node, $depth);
      }
    }
  }

  return $output;
}

/**
 * Generates printer-friendly HTML for a node.  This function
 * is a 'pre-node' visitor function for book_recurse().
 *
 * @param $node
 *   - the node to generate output for.
 * @param $depth
 *   - the depth of the given node in the hierarchy. This
 *   is used only for generating output.
 * @param $nid
 *   - the node id (nid) of the given node. This
 *   is used only for generating output.
 * @return
 *   - the HTML generated for the given node.
 */
function book_node_visitor_html_pre($node, $depth, $nid) {
  // Output the content:
  if (node_hook($node, 'content')) {
    $node = node_invoke($node, 'content');
  }
  // Allow modules to change $node->body before viewing.
  node_invoke_nodeapi($node, 'print', $node->body, false);

  $output .= "<div id=\"node-". $node->nid ."\" class=\"section-$depth\">\n";
  $output .= "<h1 class=\"book-heading\">". check_plain($node->title) ."</h1>\n";

  if ($node->body) {
    $output .= $node->body;
  }
  return $output;
}

/**
 * Finishes up generation of printer-friendly HTML after visiting a
 * node. This function is a 'post-node' visitor function for
 * book_recurse().
 */
function book_node_visitor_html_post($node, $depth) {
  return "</div>\n";
}

/**
 * Generates XML for a given node. This function is a 'pre-node'
 * visitor function for book_recurse().  The generated XML is valid
 * DocBook, but each node's HTML content is wrapped in a CDATA
 * section, and put inside a <literallayout> element.  The node body
 * has an md5-hash applied; the value of this is stored as node
 * metadata to allow importing code to determine if contents have
 * changed.  The weight of a node is also stored as metadata to
 * allow the node to be properly re-imported.
 *
 * @param $node
 *   - the node to generate output for.
 * @param $depth
 *   - the depth of the given node in the hierarchy. This
 *   is currently not used.
 * @param $nid
 *   - the node id (nid) of the given node. This
 *   is used only for generating output (e.g., id attribute)
 * @return
 *   - the generated XML for the given node.
 */
function book_node_visitor_xml_pre($node, $depth, $nid) {
  // Output the content:
  if (node_hook($node, 'content')) {
    $node = node_invoke($node, 'content');
  }
  // Allow modules to change $node->body before viewing.
  node_invoke_nodeapi($node, 'export_xml', $node->body, false);

  $releaseinfo  = "<releaseinfo>\n";
  $releaseinfo .= "md5-hash:" . md5($node->body) . "\n";
  $releaseinfo .= "weight:". $node->weight . "\n";
  $releaseinfo .= "depth:". $depth . "\n";
  $releaseinfo .= "</releaseinfo>\n";

  $title = "<title>". check_plain($node->title) ."</title>\n";

  // wrap the node body in a CDATA declaration
  $content = "<literallayout>";
  $content .= "<![CDATA[";
  if ($node->body) {
    $content .= $node->body;
  }
  $content .= "]]>";
  $content .= "</literallayout>\n";

  if ($depth == 1) {
      $output .= "<book>\n";
      $output .= $title;
      $output .= "<bookinfo>\n$releaseinfo</bookinfo>\n";
      $output .= "<preface>\n";
      $output .= "<title>Preface</title>\n";
      $output .= $content;
      $output .= "</preface>\n";
  }
  else if ($depth == 2) {
      $output .= "<chapter id=\"node-".$node->nid ."\">\n";
      $output .= "<chapterinfo>\n$releaseinfo</chapterinfo>\n";
      $output .= $title;
      $output .= $content;
  }
  else {
      $output .= "<section id=\"node-".$node->nid ."\">\n";
      $output .= "<sectioninfo>\n$releaseinfo</sectioninfo>\n";
      $output .= $title;
      $output .= $content;
  }

  return $output;
}

/**
 * Completes the XML generation for the node. This function is a
 * 'post-node' visitor function for book_recurse().
 */
function book_node_visitor_xml_post($node, $depth) {
  if ($depth == 1) {
    return "</book>\n";
  }
  else if ($depth == 2) {
    return "</chapter>\n";
  }
  else {
    return "</section>\n";
  }
}

/**
 * Generates OPML for a node.  This function is a 'pre-node' visitor
 * function for book_recurse().
 *
 * @param $node
 *   - the node to generate output for.
 * @param $depth
 *   - the depth of the given node in the hierarchy. This is used only
 *   for generating output.
 * @param $nid
 *   - the node id (nid) of the given node. This is used only for
 *   generating output.
 * @return
 *   - the OPML generated for the given node.
 */
function book_node_visitor_opml_pre($node, $depth, $nid) {
  // Output the content:
  if (node_hook($node, 'content')) {
    $node = node_invoke($node, 'content');
  }

  $output .= "<outline type=\"id:node-". $node->nid ."\"\n";
  $text = check_plain($node->title);
  $output .= "text=\"$text\">\n";
  return $output;
}

/**
 * Finishes up generation of OPML after visiting a node. This function
 * is a 'post-node' visitor function for book_recurse().
 */
function book_node_visitor_opml_post($node, $depth) {
  return "</outline>\n";
}

function _book_admin_table($nodes = array()) {
  $form = array(
    '#theme' => 'book_admin_table',
    '#tree' => TRUE,
  );

  foreach ($nodes as $node) {
    $form = array_merge($form, _book_admin_table_tree($node, 0));
  }

  return $form;
}

function _book_admin_table_tree($node, $depth) {
  $form = array();

  $form[] = array(
    'nid' => array('#type' => 'value', '#value' => $node->nid),
    'depth' => array('#type' => 'value', '#value' => $depth),
    'title' => array(
      '#type' => 'textfield',
      '#default_value' => $node->title,
      '#maxlength' => 255,
    ),
    'weight' => array(
      '#type' => 'weight',
      '#default_value' => $node->weight,
      '#delta' => 15,
    ),
  );

  $children = db_query(db_rewrite_sql('SELECT n.nid, b.weight FROM {node} n INNER JOIN {book} b ON n.vid = b.vid WHERE b.parent = %d ORDER BY b.weight, n.title'), $node->nid);
  while ($child = db_fetch_object($children)) {
    $form = array_merge($form, _book_admin_table_tree(node_load($child->nid), $depth + 1));
  }

  return $form;
}

function theme_book_admin_table($form) {
  $header = array(t('Title'), t('Weight'), array('data' => t('Operations'), 'colspan' => '3'));

  $rows = array();
  foreach (element_children($form) as $key) {
    $nid = $form[$key]['nid']['#value'];
    $rows[] = array(
      '<div style="padding-left: '. (25 * $form[$key]['depth']['#value']) .'px;">'. form_render($form[$key]['title']) .'</div>',
      form_render($form[$key]['weight']),
      l(t('view'), 'node/'. $nid),
      l(t('edit'), 'node/'. $nid .'/edit'),
      l(t('delete'), 'node/'. $nid .'/delete')
    );
  }

  return theme('table', $header, $rows);
}

/**
 * Display an administrative view of the hierarchy of a book.
 */
function book_admin_edit($nid) {
  $node = node_load($nid);
  if ($node->nid) {
    drupal_set_title(check_plain($node->title));
    $form = array();

    $form['table'] = _book_admin_table(array($node));
    $form['save'] = array(
      '#type' => 'submit',
      '#value' => t('Save book pages'),
    );

    return drupal_get_form('book_admin_edit', $form);
  }
  else {
    drupal_not_found();
  }
}

/**
 * Menu callback; displays a listing of all orphaned book pages.
 */
function book_admin_orphan() {
  $result = db_query(db_rewrite_sql('SELECT n.nid, n.title, n.status, b.parent FROM {node} n INNER JOIN {book} b ON n.vid = b.vid'));

  $pages = array();
  while ($page = db_fetch_object($result)) {
    $pages[$page->nid] = $page;
  }

  $orphans = array();
  if (count($pages)) {
    foreach ($pages as $page) {
      if ($page->parent && empty($pages[$page->parent])) {
        $orphans[] = node_load($page->nid);
      }
    }
  }

  if (count($orphans)) {
    $form = array();

    $form['table'] = _book_admin_table($orphans);
    $form['save'] = array(
      '#type' => 'submit',
      '#value' => t('Save book pages'),
    );

    return drupal_get_form('book_admin_edit', $form);
  }
  else {
    return '<p>'. t('There are no orphan pages.') .'</p>';
  }
}

function book_admin_edit_execute($form_id, $form_values) {
  foreach ($form_values['table'] as $row) {
    $node = node_load($row['nid']);

    if ($row['title'] != $node->title || $row['weight'] != $node->weight) {
      $node->title = $row['title'];
      $node->weight = $row['weight'];

      node_save($node);
      watchdog('content', t('%type: updated %title.', array('%type' => theme('placeholder', t('book')), '%title' => theme('placeholder', $node->title))), WATCHDOG_NOTICE, l(t('view'), 'node/'. $node->nid));
    }
  }

  if (is_numeric(arg(3))) {
    // Updating pages in a single book.
    $book = node_load(arg(3));
    drupal_set_message(t('Updated book %title.', array('%title' => theme('placeholder', $book->title))));
  }
  else {
    // Updating the orphan pages.
    drupal_set_message(t('Updated orphan book pages.'));
  }
}

/**
 * Menu callback; displays the book administration page.
 */
function book_admin($nid = 0) {
  $op = $_POST['op'];
  $edit = $_POST['edit'];

  if ($nid) {
    return book_admin_edit($nid);
  }
  else {
    return book_admin_overview();
  }
}

/**
 * Returns an administrative overview of all books.
 */
function book_admin_overview() {
  $result = db_query(db_rewrite_sql('SELECT n.nid, n.title, b.weight FROM {node} n INNER JOIN {book} b ON n.vid = b.vid WHERE b.parent = 0 ORDER BY b.weight, n.title'));
  while ($book = db_fetch_object($result)) {
    $rows[] = array(l($book->title, "node/$book->nid"), l(t('outline'), "admin/node/book/$book->nid"));
  }
  $headers = array(t('Book'), t('Operations'));

  return theme('table', $headers, $rows);
}

/**
 * Implementation of hook_help().
 */
function book_help($section) {
  switch ($section) {
    case 'admin/help#book':
      $output = '<p>'. t('The <em>book</em> content type is suited for creating structured, multi-page hypertexts such as site resource guides, manuals, and Frequently Asked Questions (FAQs).  It permits a document to have chapters, sections, subsections, etc.  Authors with suitable permissions can add pages to a collaborative book,  placing them into the existing document by adding them to a table of contents menu. ') .'</p>';
      $output .= '<p>'. t('Books have additional <em>previous</em>, <em>up</em>, and <em>next</em> navigation elements at the bottom of each page for moving through the text.  Additional navigation may be provided by enabling the <em>book navigation block</em> on the <a href="%admin-block">block administration page</a>.', array('%admin-block' => url('admin/block'))) .'</p>';
      $output .= '<p>'. t('Users can select the <em>printer-friendly version</em> link visible at the bottom of a book page to generate a printer-friendly display of the page and all of its subsections.   They can choose to <em>export</em> the page and its subsections as DocBook XML (for offline editing, or production of print or other electronic publication formats), or as an outline (titles only), by selecting the <em>export DocBook XML</em> and <em>export OPML</em> links respectively.  DocBook export currently treats node content as preformatted text.') .'</p>';
      $output .= '<p>'. t('Administrators can view a book outline, from which is it possible to change the titles of sections, and their <i>weight</i> (thus reordering sections).   From this outline, it is also possible to edit and/or delete book pages.   Many content types besides pages (for example, blog entries, stories, and polls) can be added to a collaborative book by choosing the <em>outline</em> tab when viewing the post.') .'</p>';
      $output .= t('<p>You can</p>
<ul>
<li>create new book pages: <a href="%node-add-book">create content &gt;&gt; book page</a>.</li>
<li>administer individual books (choose a book from list): <a href="%admin-node-book">administer &gt;&gt; content &gt;&gt; books</a>.</li>
<li>set workflow and other global book settings on the book configuration page: <a href="%admin-node-configure-types-book" title="book page content type">administer &gt;&gt; content &gt;&gt; configure &gt;&gt; content types &gt;&gt; book page</a>.</li>
<li>enable the book navigation block: <a href="%admin-block">administer &gt;&gt; block</a>.</li>
<li>control who can create, edit, and maintain book pages by setting access permissions: <a href="%admin-access">administer &gt;&gt; access control</a>.</li>
</ul>
', array('%node-add-book' => url('node/add/book'), '%admin-node-book' => url('admin/node/book'), '%admin-node-configure-types-book' => url('admin/node/configure/types/book'), '%admin-block' => url('admin/block'), '%admin-access' => url('admin/access')));
      $output .= '<p>'. t('For more information please read the configuration and customization handbook <a href="%book">Book page</a>.', array('%book' => 'http://www.drupal.org/handbook/modules/book/')) .'</p>';
      return $output;
    case 'admin/modules#description':
      return t('Allows users to collaboratively author a book.');
    case 'admin/node/book':
      return t('<p>The book module offers a mean to organize content, authored by many users, in an online manual, outline or FAQ.</p>');
    case 'admin/node/book/orphan':
      return t('<p>Pages in a book are like a tree. As pages are edited, reorganized and removed, child pages might be left with no link to the rest of the book.  Such pages are referred to as "orphan pages".  On this page, administrators can review their books for orphans and reattach those pages as desired.</p>');
    case 'node/add#book':
      return t("A book is a collaborative writing effort: users can collaborate writing the pages of the book, positioning the pages in the right order, and reviewing or modifying pages previously written.  So when you have some information to share or when you read a page of the book and you didn't like it, or if you think a certain page could have been written better, you can do something about it.");
  }

  if (arg(0) == 'node' && is_numeric(arg(1)) && arg(2) == 'outline') {
    return t('The outline feature allows you to include posts in the <a href="%book">book hierarchy</a>.', array('%book' => url('book')));
  }
}


