<?php
// $Id$

function node_help() {
  global $mod;

  if ($mod == "node") {
    foreach (module_list() as $name) {
      if (module_hook($name, "node") && $name != "node") {
        print "<h3>". ucfirst($name) ." type</h3>";
        print module_invoke($name, "help");
      }
    }
  }
}

function node_teaser($body) {

  $size = 400;

  /*
  ** If we have a short body, return the entire body:
  */

  if (strlen($body) < $size) {
    return $body;
  }

  /*
  ** If we have a long body, try not to split paragraphs:
  */

  if ($length = strpos($body, "\n", $size)) {
    return substr($body, 0, $length + 1);
  }

  /*
  ** If we have a long body, try not to split sentences:
  */

  return substr($body, 0, strpos($body, ". ", $size) + 1);

}

function node_invoke($node, $name, $arg = 0) {
  if (is_array($node)) {
    $function = $node["type"] ."_$name";
  }
  else if (is_object($node)) {
    $function = $node->type ."_$name";
  }
  else if (is_string($node)) {
    $function = $node ."_$name";
  }

  if (function_exists($function)) {
    return ($arg ? $function($node, $arg) : $function($node));
  }
}

function node_load($conditions) {

  /*
  ** Turn the conditions into a query:
  */

  foreach ($conditions as $key => $value) {
    $cond[] = "n.". check_query($key) ." = '". check_query($value) ."'";
  }

  /*
  ** Retrieve the node:
  */

  $node = db_fetch_object(db_query("SELECT n.*, u.uid, u.name FROM node n LEFT JOIN users u ON u.uid = n.uid WHERE ". implode(" AND ", $cond)));

  /*
  ** Unserialize the revisions field:
  */

  if ($node->revisions) {
    $node->revisions = unserialize($node->revisions);
  }

  /*
  ** Call the node specific callback (if any) and piggy-back the
  ** results to the node or overwrite some values:
  */

  if ($extra = module_invoke($node->type, "load", $node)) {
    foreach ($extra as $key => $value) {
      $node->$key = $value;
    }
  }

  return $node;
}

function node_save($node, $filter) {

  $fields = array("nid", "uid", "type", "title", "teaser", "body", "revisions", "score", "status", "comment", "promote", "static", "moderate", "created", "changed", "users", "votes");

  foreach ($filter as $key => $value) {
    /*
    ** Only save those fields specified by the filter.  If the filter
    ** does not specify a default value, use the value of the $node's
    ** corresponding field instead.
    */

    if (is_numeric($key)) {
      if (isset($node->$value)) {
          // The above check is mandatory.
        $edit->$value = $node->$value;
      }
    }
    else {
      if (isset($value)) {
          // The above check is mandatory.
        $edit->$key = $value;
      }
    }
  }

  $node = $edit;

  /*
  ** Serialize the revisions field:
  */

  if ($node->revisions) {
    $node->revisions = serialize($node->revisions);
  }

  /*
  ** Apply filters to some default node fields:
  */

  if (empty($node->nid)) {

    /*
    ** Insert a new node:
    */

    // Set some required fields:
    $node->created = time();
    $node->changed = time();
    $node->nid = db_result(db_query("SELECT MAX(nid) + 1 FROM node"));
    $node->nid = empty($node->nid) ? 1 : $node->nid;

    // Prepare the query:
    foreach ($node as $key => $value) {
      if (in_array($key, $fields)) {
        $k[] = check_query($key);
        $v[] = "'". check_query($value) ."'";
      }
    }

    // Insert the node into the database:
    db_query("INSERT INTO node (". implode(", ", $k) .") VALUES (". implode(", ", $v) .")");

    // Call the node specific callback (if any):
    module_invoke($node->type, "insert", $node);
  }
  else {

    /*
    ** Update an existing node:
    */

    // Set some required fields:
    $node->changed = time();

    // Prepare the query:
    foreach ($node as $key => $value) {
      if (in_array($key, $fields)) {
        $q[] = check_query($key) ." = '". check_query($value) ."'";
      }
    }

    // Update the node in the database:
    db_query("UPDATE node SET ". implode(", ", $q) ." WHERE nid = '$node->nid'");

    // Call the node specific callback (if any):
    module_invoke($node->type, "update", $node);

  }

  /*
  ** Return the node ID:
  */

  return $node->nid;

}

function node_view($node, $main = 0) {
  global $theme;

  $node = array2object($node);

  /*
  ** The "view" hook can be implemented to overwrite the default function
  ** to display nodes.
  */

  if (module_hook($node->type, "view")) {
    node_invoke($node, "view", $main);
  }
  else {

    /*
    ** Default behavior:
    */

    $theme->node($node, $main);
  }
}

function node_access($op, $node = 0) {

  if (user_access("administer nodes")) {
    return 1;
  }
  else {

    /*
    ** Convert the node to an object if necessary:
    */

    $node = array2object($node);

    /*
    ** Construct a function:
    */

    if ($node->type) {
      $type = $node->type;
    }
    else {
      $type = $node;
    }

    $function = $type ."_access";

    if (function_exists($function)) {
      return $function($op, $node);
    }
    else {
      return 0;
    }
  }
}

function node_perm() {
  return array("administer nodes", "access content", "post content");
}

function node_search($keys) {
  global $PHP_SELF;

  // Return the results of performing a search using the indexed search
  // for this particular type of node.
  //
  // Pass an array to the "do_search" function which dictates what it
  // will search through, and what it will search for
  //
  // "keys"'s value is the keywords entered by the user
  //
  // "type"'s value is used to identify the node type in the search
  // index.
  //
  // "select"'s value is used to relate the data from the specific nodes
  // table to the data that the search_index table has in it, and the the
  // do_search functino will rank it.
  //
  // The select must always provide the following fields - lno, title,
  // created, uid, name, count
  //
  $find = do_search(array("keys" => $keys, "type" => "node", "select" => "select s.lno as lno, n.title as title, n.created as created, u.uid as uid, u.name as name, s.count as count FROM search_index s, node n LEFT JOIN users u ON n.uid = u.uid WHERE s.lno = n.nid AND s.type = 'node' AND s.word like '%' AND n.status = 1"));

  return $find;
}

function node_conf_options() {
  $output .= form_select(t("Default number of nodes to display"), "default_nodes_main", variable_get("default_nodes_main", 10), array(1 => 1, 2 => 2, 3 => 3, 4 => 4, 5 =>  5, 6 => 6, 7 => 7, 8 => 8, 9 => 9, 10 => 10, 15 => 15, 20 => 20, 25 => 25, 30 => 30), t("The default maximum number of nodes to display on the main page."));
  return $output;
}

function node_conf_filters() {
  $output .= form_select(t("Enable HTML tags"), "filter_html", variable_get("filter_html", 0), array("Disabled", "Enabled"), t("Allow HTML and PHP tags in user-contributed content."));
  $output .= form_textfield(t("Allowed HTML tags"), "allowed_html", variable_get("allowed_html", "<a> <b> <dd> <dl> <dt> <i> <li> <ol> <u> <ul>"), 64, 255, t("If enabled, optionally specify tags which should not be stripped.  'STYLE' attributes, 'ON' attributes and unclosed tags are always stripped."));
  $output .= "<hr />";
  $output .= form_select(t("Enable link tags"), "filter_link", variable_get("filter_link", 0), array("Disabled", "Enabled"), t("Substitute special [[nodesubject|text]] tags. Your browser will display 'text', and when you click on it your browser will open the node with the subject 'nodesubject'. Please be aware that you'll need to copy the subject of the target node exactly in order to use this feature."));
  $output .= "<hr />";
  return $output;
}

function node_filter_html($text) {
  $text = eregi_replace("([ \f\r\t\n\'\"])style=[^>]+>", "\\1", $text);
  $text = eregi_replace("([ \f\r\t\n\'\"])on[a-z]+=[^>]+>", "\\1", $text);
  $text = strip_tags($text, variable_get("allowed_html", ""));
  return $text;
}

function node_filter_link($text) {
  $pat = '\[{2}([^\|]+)(\|([^\|]+)?)?\]{2}';                   // [link|description]
  $dst = str_replace('%5C1', '\\1', format_tag('\\1', '\\3')); // [link|description]
  return ereg_replace($pat, $dst, $text);
}

function node_filter_line($text) {

  /*
  ** This "line break filter" will try to get the line breaks right
  ** regardless of the user's input.  Its goal aspires a consistent
  ** mark-up and use of line breaks and paragraphs.
  */

  /*
  ** If HTML mark-up is being used, strip regular line breaks:
  */

  if (strstr($text, "<br />") || strstr($text, "<p>")) {
    $text = ereg_replace("[\r\n]", "", $text);
  }

  /*
  ** Replace '<br>', '<br />', '<p>' and '<p />' by '\n':
  */

  $text = eregi_replace("<br />", "\n", $text);
  $text = eregi_replace("<br />", "\n", $text);
  $text = eregi_replace("<p>", "\n", $text);
  $text = eregi_replace("<p />", "\n", $text);

  /*
  ** Replace '\r\n' by '\n':
  */

  $text = ereg_replace("\r\n", "\n", $text);

  /*
  ** Replace some new line charachters:
  */

  while (strpos($text, "\n\n\n")) {
    $text = ereg_replace("\n\n\n", "\n\n", $text);
  }

  /*
  ** Replace some common "artifacts":
  */

  $list = "blockquote|li|ol|ul|table|th|td|tr|pre";
  $text = preg_replace(array("/\n\s*<([\/])($list)/", "/($list)>\s*\n/"), array("<$1$2", "$1>"), $text);

  return trim($text);
}

function node_comment_mode($nid) {
  return db_result(db_query("SELECT comment FROM node WHERE nid = '%s'", $nid));
}

function node_filter($text) {
  if (variable_get("filter_html", 0)) $text = node_filter_html($text);
  if (variable_get("filter_link", 0)) $text = node_filter_link($text);
  return node_filter_line($text);
}

function node_link($type, $node = 0, $main = 0) {

  if ($type == "admin" && user_access("administer nodes")) {
    $links[] = la(t("content management"), array("mod" => "node"));
  }

  if ($type == "page" && user_access("post content")) {
    $links[] = lm(t("submit"), array("mod" => "node", "op" => "add"), "", array("title" => t("Submit or suggest new content.")));
  }

  if ($type == "node") {
    if ($node->links) {
      $links = $node->links;
    }

    if ($main == 1 && $node->teaser != $node->body) {
      $links[] = l(t("read more"), array("id" => $node->nid), "node", "", array("title" => t("Read the rest of this posting.")));
    }

    if (user_access("administer nodes")) {
       $links[] = la(t("administer"), array("mod" => "node", "op" => "edit", "id" => $node->nid), "", array("title" => t("Administer this node.")));
    }
  }

  return $links ? $links : array();
}

function node_admin_settings($edit = array()) {
  global $op;

  if ($op == t("Save configuration")) {
    /*
    ** Save the configuration options:
    */

    foreach ($edit as $name => $value) {
      variable_set($name, $value);
    }
  }

  if ($op == t("Reset to defaults")) {
    /*
    ** Reset the configuration options to their default value:
    */

    foreach ($edit as $name => $value) {
      variable_del($name);
    }
  }

  $output .= "<h3>". t("Global node settings") ."</h3>";
  $output .= node_conf_options();

  foreach (module_list() as $name) {
    if (module_hook($name, "conf_options") && module_hook($name, "node")) {
      $output .= "<h3>". ucfirst(module_invoke($name, "node", "name") ." settings") ."</h3>";
      $output .= module_invoke($name, "conf_options");
    }
  }

  $output .= form_submit(t("Save configuration"));
  $output .= form_submit(t("Reset to defaults"));

  return form($output);
}

function node_admin_edit($node) {

  if (is_numeric($node)) {
    $node = node_load(array("nid" => $node));
  }

  /*
  ** Edit node:
  */

  $output .= "<h3>". t("Edit") ." ". module_invoke($node->type, "node", "name") ."</h3>";

  $output .= node_form($node);

  /*
  ** Edit revisions:
  */

  if ($node->revisions) {
    $output .= "<h3>". t("Edit revisions") ."</h3>";
    $output .= "<table border=\"1\" cellpadding=\"2\" cellspacing=\"2\">";
    $output .= " <tr><th>older revisions</th><th colspan=\"3\">operations</th></tr>";
    foreach ($node->revisions as $key => $revision) {
      $output .= " <tr><td>". t("revision #%r revised by %u on %d", array("%r" => $key, "%u" => format_name(user_load(array("uid" => $revision["uid"]))), "%d" => format_date($revision["timestamp"], "small"))) . ($revision["history"] ? "<br /><small>". $revision["history"] ."</small>" : "") ."</td><td>". l(t("view revision"), array("id" => $node->nid, "revision" => $key)) ."</td><td>". la(t("rollback revision"), array("mod" => "node", "op" => "rollback+revision", "id" => $node->nid, "revision" => $key)) ."</td><td>". la(t("delete revision"), array("mod" => "node", "op" => "delete+revision", "id" => $node->nid, "revision" => $key)) ."</td></tr>";
    }
    $output .= "</table>";
  }

  /*
  ** Display the node form extensions:
  */

  foreach (module_list() as $name) {
    $output .= module_invoke($name, "node_link", $node);
  }

  return $output;

}

function node_admin_nodes() {
  global $query;

  $queries = array(array("ORDER BY n.created DESC", "new nodes"), array("ORDER BY n.changed DESC", "updated nodes"), array("WHERE n.status = 1 AND n.moderate = 0 ORDER BY n.nid DESC", "published nodes"), array("WHERE n.status = 0 AND n.moderate = 0 ORDER BY n.nid DESC", "non-published nodes"), array("WHERE n.status = 1 AND n.moderate = 1 ORDER BY n.nid DESC", "pending nodes"), array("WHERE n.status = 1 AND n.promote = 1 ORDER BY n.nid DESC", "promoted nodes"));

  $result = db_query("SELECT n.*, u.name, u.uid FROM node n LEFT JOIN users u ON n.uid = u.uid ". $queries[$query ? $query : 1][0] ." LIMIT 50");

  foreach ($queries as $key => $value) {
    $links[] = la($value[1], array("mod" => "node", "op" => "nodes", "query" => $key));
  }

  $output .= "<small>". implode(" :: ", $links) ."</small><hr />";

  $output .= "<table border=\"1\" cellpadding=\"2\" cellspacing=\"2\">\n";
  $output .= " <tr><th>title</th><th>type</th><th>author</th><th>status</th><th colspan=\"2\">operations</th></tr>\n";
  while ($node = db_fetch_object($result)) {
    $output .= "<tr><td>". l(check_output($node->title), array("id" => $node->nid)) ."</td><td>$node->type</td><td nowrap=\"nowrap\">". format_name($node) ."</td><td>". ($node->status ? t("published") : t("not published")) ."</td><td nowrap=\"nowrap\">". la(t("edit node"), array("mod" => "node", "op" => "edit", "id" => $node->nid)) ."</td><td nowrap=\"nowrap\">". la(t("delete node"), array("mod" => "node", "op" => "delete", "id" => $node->nid)) ."</td></tr>";
  }
  $output .= "</table>";

  return $output;
}

/*
** Return the revision with the specified revision number.
*/

function node_revision_load($node, $revision) {
  return $node->revisions[$revision]["node"];
}

/*
** Create and return a new revision of the given node.
*/

function node_revision_create($node) {
  global $user;

  /*
  ** 'revision' is the name of the field used to indicicate that we
  ** have to create a new revision of a node.
  */

  if ($node->nid && $node->revision) {
    $prev = node_load(array("nid" => $node->nid));
    $node->revisions = $prev->revisions;
    unset($prev->revisions);
    $node->revisions[] = array("uid" => $user->uid, "timestamp" => time(), "node" => $prev, "history" => $node->history);
  }

  return $node;
}

/*
** Roll-back to the revision with the specified revision number.
*/

function node_revision_rollback($node, $revision) {
  global $user;

  /*
  ** Extract the specified revision:
  */

  $rev = $node->revisions[$revision]["node"];

  /*
  ** Inherit all the past revisions:
  */

  $rev->revisions = $node->revisions;

  /*
  ** Save the original/current node:
  */

  $rev->revisions[] = array("uid" => $user->uid, "timestamp" => time(), "node" => $node);

  /*
  ** Remove the specified revision:
  */

  unset($rev->revisions[$revision]);

  /*
  ** Save the node:
  */

  foreach ($node as $key => $value) {
    $filter[] = $key;
  }

  node_save($rev, $filter);

  watchdog("special", "$node->type: rollbacked to revision #$revision of '$node->title'");
}

/*
** Delete the revision with specified revision number.
*/

function node_revision_delete($node, $revision) {

  unset($node->revisions[$revision]);

  node_save($node, array("nid", "revisions"));

  watchdog("special", "$node->type: removed revision #$revision of '$node->title'");
}

/*
** Return a list of all the existing revision numbers.
*/

function node_revision_list($node) {
  if (is_array($node->revisions)) {
    return array_keys($node->revisions);
  }
  else {
    return array();
  }
}

function node_admin() {
  global $op, $id, $revision, $edit;

  if (user_access("administer nodes")) {

    /*
    ** Compile a list of the administrative links:
    */

    $links[] = la(t("nodes"), array("mod" => "node", "op" => "nodes"));
    $links[] = la(t("search content"), array("mod" => "node", "op" => "search"));
    $links[] = la(t("settings"), array("mod" => "node", "op" => "settings"));
    $links[] = la(t("help"), array("mod" => "node", "op" => "help"));

    print "<small>". implode(" &middot; ", $links) ."</small><hr />";

    switch ($op) {
      case "help":
        print node_help();
        break;
      case "search":
        print search_type("node", drupal_url(array("mod" => "node", "op" => "search"), "admin"));
        break;
      case t("Save configuration"):
      case t("Reset to defaults"):
      case "settings":
        print node_admin_settings($edit);
        break;
      case "edit":
        print node_admin_edit($id);
        break;
      case "delete":
        print node_delete(array("nid" => $id));
        break;
      case "rollback revision":
        print node_revision_rollback(node_load(array("nid" => $id)), $revision);
        print node_admin_edit($id);
        break;
      case "delete revision":
        print node_revision_delete(node_load(array("nid" => $id)), $revision);
        print node_admin_edit($id);
        break;
      case t("Preview"):
        print node_preview($edit);
        break;
      case t("Submit"):
        print node_submit($edit);
        break;
      case t("Delete"):
        print node_delete($edit);
        break;
      default:
        print node_admin_nodes();
    }
  }
  else {
    print message_access();
  }
}

function node_block() {
  global $theme;

  $block[0][subject] = t("Syndicate");
  $block[0][content] = "<div align=\"center\">". lm("<img src=\"". $theme->image("xml.gif") ."\" width=\"36\" height=\"14\" border=\"0\" alt=\"XML\" />", array("mod" => "node", "op" => "feed"), "", array("title" => t("Read the XML version of this page."))) ."</div>\n";
  $block[0][info] = "Syndicate";

  return $block;
}

function node_feed() {

  $result = db_query("SELECT nid, type FROM node WHERE promote = '1' AND status = '1' ORDER BY created DESC LIMIT 15");

  while ($node = db_fetch_object($result)) {
    $item = node_load(array("nid" => $node->nid, "type" => $node->type));

    $link = path_uri() .drupal_url(array("id" => $item->nid), "node");

    $items .= format_rss_item($item->title, $link, $item->teaser);
  }

  $output .= "<?xml version=\"1.0\" encoding=\"ISO-8859-1\" ?>\n";
  // $output .= "<!DOCTYPE rss [<!ENTITY % HTMLlat1 PUBLIC \"-//W3C//ENTITIES Latin 1 for XHTML//EN\" \"http://www.w3.org/TR/xhtml1/DTD/xhtml-lat1.ent\">\n";
  $output .= "<rss version=\"0.91\">\n";
  $output .= format_rss_channel(variable_get("site_name", "drupal") ." - ". variable_get("site_slogan", ""), path_uri(), variable_get("site_mission", ""), $items);
  $output .= "</rss>\n";

  header("Content-Type: text/xml");

  print $output;

}


function node_validate($node, &$error) {

  global $user;

  /*
  ** Convert the node to an object if necessary:
  */

  $node = array2object($node);

  /*
  ** Validate the title field:
  */

  if (isset($node->title) && !$node->title) {
    $error["title"] = "<div style=\"color: red;\">". t("You have to specify a valid title.") ."</div>";
  }

  if (user_access("administer nodes")) {

    /*
    ** Setup default values if required:
    */

    if (!$node->created) {
      $node->created = time();
    }

    if (!$node->date) {
      $node->date = date("M j, Y g:i a", $node->created);
    }

    /*
    ** Validate the "authored by"-field:
    */

    if (empty($node->name)) {
      /*
      ** The use of empty() is mandatory in the context of usernames
      ** as the empty string denotes the anonymous user.  In case we
      ** are dealing with an anomymous user we set the user ID to 0.
      */
      $node->uid = 0;
    }
    else if ($account = user_load(array("name" => $node->name))) {
      $node->uid = $account->uid;
    }
    else {
      $error["name"] = "<div style=\"color: red;\">". t("The name '%u' does not exist.", array ("%u" => $node->name)) ."</div>";
    }

    /*
    ** Validate the "authored on"-field:
    */

    if (strtotime($node->date) > 1000) {
      $node->created = strtotime($node->date);
    }
    else {
      $error["date"] = "<div style=\"color: red;\">". t("You have to specifiy a valid date.") ."</div>";
    }

  }

  /*
  ** Do node type specific validation checks.
  */

  $function = $node->type ."_validate";
  if (function_exists($function)) {
    $node = $function($node, $error);
  }

  return $node;
}


function node_form($edit, $error = NULL) {

  /*
  ** Save the referer.  We record where the user came from such that we
  ** can redirect him after having completed the node forms.
  */

  referer_save();

  /*
  ** Validate the node:
  */

  if (!$error) {
  /* Only validate if we don't already know the errors. */
  $edit = node_validate($edit, $error);
  }

  /*
  ** Generate a teaser when necessary:
  */

  if ($edit->body && !$edit->teaser) {
    $edit->teaser = node_teaser($edit->body);
  }

  /*
  ** Get the node specific bits:
  */

  $function = $edit->type ."_form";
  if (function_exists($function)) {
    $form .= $function($edit, $help, $error, $param);
  }

  /*
  ** Add the help text:
  */

  if ($help) {
    $output .= "<p>$help</p>";
  }

  $output .= "<table border=\"0\" cellpadding=\"2\" cellspacing=\"2\">";
  $output .= " <tr>";
  $output .= "  <td valign=\"top\">";

  /*
  ** Add the default fields:
  */

  $output .= form_textfield(t("Title"), "title", $edit->title, 60, 64, $error["title"]);

  /*
  ** Add the node specific fields:
  */

  $output .= $form;

  /*
  ** Add the hidden fields:
  */

  if ($edit->nid) {
    $output .= form_hidden("nid", $edit->nid);
  }

  if (isset($edit->uid)) {
      /*
      ** The use of isset() is mandatory in the context of user IDs as uid
      ** 0 denotes the anonymous user.
      */
    $output .= form_hidden("uid", $edit->uid);
  }

  if ($edit->created) {
    $output .= form_hidden("created", $edit->created);
  }

  $output .= form_hidden("type", $edit->type);

  /*
  ** Add the buttons:
  */

  $output .= form_submit(t("Preview"));

  if ($edit->title && $edit->type && !$error) {
    $output .= form_submit(t("Submit"));
  }

  if ($edit->nid && node_access("delete", $edit)) {
    $output .= form_submit(t("Delete"));
  }

  /*
  ** Add the admin specific parts:
  */

  if (user_access("administer nodes")) {
    $output .= "</td><td align=\"left\" valign=\"top\">";
    $output .= form_textfield(t("Authored by"), "name", $edit->name, 20, 25, $error["name"]);
    $output .= form_textfield(t("Authored on"), "date", $edit->date, 20, 25, $error["date"]);
    $output .= "<br />";
    $output .= form_select(t("Set public/published"), "status", $edit->status, array("Disabled", "Enabled"));
    $output .= form_select(t("Queue for moderation"), "moderate", $edit->moderate, array("Disabled", "Enabled"));
    $output .= form_select(t("Promote to front page"), "promote", $edit->promote, array("Disabled", "Enabled"));
    $output .= form_select(t("Static on front page"), "static", $edit->static, array("Disabled", "Enabled"));
    $output .= form_select(t("Allow users comments"), "comment", $edit->comment, array("Disabled", "Read only", "Read/Write"));
    $output .= form_select(t("Create new revision"), "revision", $edit->revision, array("Disabled", "Enabled"));
  }

  $output .= "  </td>";
  $output .= " </tr>";
  $output .= "</table>";

  return form($output, ($param["method"] ? $param["method"] : "post"), $param["action"], $param["options"]);
}

function node_add($type) {
  global $user;

  if (!user_access("post content")) {
    return message_access();
  }

  /*
  ** If a node type has been specified, validate it existence.  If no
  ** (valid) node type has been provied, display a node type overview.
  */

  if ($type && node_access("create", $type)) {
    // Initialize settings
    $output = node_form(array("uid" => $user->uid, "name" => $user->name, "type" => $type, "status" => 1, "moderate" => 1, "comment" => 2));
  }
  else {

    /*
    ** Compile a list with the different node types and their explanation:
    */

    foreach (module_list() as $name) {
      if (module_hook($name, "node") && node_access("create", array("type" => $name))) {
        $output .= "<li>";
        $output .= " ". lm(module_invoke($name, "node", "name"), array("mod" => "node", "op" => "add", "type" => $name), "", array("title" => t("Add a new %s.", array("%s" => module_invoke($name, "node", "name")))));
        $output .= " <div style=\"margin-left: 20px;\">". module_invoke($name, "node", "description") ."</div>";
        $output .= "</li>";
      }
    }

    $output = t("Choose the appropriate item from the list:") ."<ul>$output</ul>";

  }

  return $output;
}

function node_edit($id) {
  global $user;

  if (!user_access("post content")) {
    return message_access();
  }

  $node = node_load(array("nid" => $id));

  if (node_access("update", $node)) {
    $output = node_form($node);
  }
  else {
    $output = message_access();
  }

  return $output;
}

function node_preview($node, $error = NULL) {

  if (!user_access("post content")) {
    return message_access();
  }

  /*
  ** Convert the array to an object:
  */

  $node = array2object($node);

  /*
  ** Load the user's name when needed:
  */

  if (isset($node->name)) {
    /*
    ** The use of isset() is mandatory in the context of user IDs as uid
    ** 0 denotes the anonymous user.
    */

    if ($user = user_load(array("name" => $node->name))) {
      $node->uid = $user->uid;
    }
    else {
      $node->uid = 0; // anonymous user
    }
  }
  else if ($node->uid) {
    $user = user_load(array("uid" => $node->uid));
    $node->name = $user->name;
  }

  /*
  ** Set the created time when needed:
  */

  if (empty($node->nid)) {
    $node->created = time();
  }

  /*
  ** Apply the required filters:
  */

  if ($node->nid) {
    $view = array_merge($node, module_invoke($node->type, "save", "update", $node));
  }
  else {
    $view = array_merge($node, module_invoke($node->type, "save", "create", $node));
  }

  /*
  ** Display a preview of the node:
  */

  node_view($view);

  return node_form($node, $error);
}

function node_submit($node) {
  global $user, $theme;
  
  if (user_access("post content")) {

    /*
    ** Fixup the node when required:
    */

    $node = node_validate($node, $error);

    /*
    ** If something went wrong, go back to the preview form:
    */

    if ($error) {
      return node_preview($node, $error);
    }

    /*
    ** Create a new revision when required:
    */

    $node = node_revision_create($node);

    if ($node->nid) {

      /*
      ** Check whether the current user has the proper access rights to
      ** perform this operation:
      */

      if (node_access("update", $node)) {

        /*
        ** Compile a list of the node fields and their default values that users
        ** and administrators are allowed to save when updating a node.
        */

        if (user_access("administer nodes")) {
          $fields = array("nid", "uid", "body", "comment", "created", "promote", "static", "moderate", "revisions", "status", "teaser", "title", "type" => $node->type);
        }
        else {
          $fields = array("nid", "uid" => ($user->uid ? $user->uid : 0), "body", "teaser", "title", "type" => $node->type);
        }

        $nid = node_save($node, array_merge($fields, module_invoke($node->type, "save", "update", $node)));

        /*
        ** Update terms of the node
        */

        if (function_exists("taxonomy_node_save")) {
          taxonomy_node_save($nid, $node->taxonomy);
        }

        watchdog("special", "$node->type: updated '$node->title'");
        $output = t("The node has been updated.");
      }
      else {
        watchdog("warning", "$node->type: not authorized to update node");
        $output = t("You are not authorized to update this node.");
      }

    }
    else {

      /*
      ** Check whether the current user has the proper access rights to
      ** perform this operation:
      */

      if (node_access("create", $node)) {

        /*
        ** Verify a user's submission rate and avoid duplicate nodes being
        ** inserted:
        */

        throttle("node", variable_get("max_node_rate", 900));

        /*
        ** Compile a list of the node fields and their default values that users
        ** and administrators are allowed to save when inserting a new node.
        */

        if (user_access("administer nodes")) {
          $fields = array("uid", "body", "comment" => 2, "promote", "moderate", "status" => 1, "teaser", "title", "type" => $node->type);
        }
        else {
          $fields = array("uid" => ($user->uid ? $user->uid : 0), "body", "comment" => 2, "teaser", "title", "type" => $node->type);
        }

        $nid = node_save($node, array_merge($fields, module_invoke($node->type, "save", "create", $node)));

        /*
        ** Insert terms of the node
        */

        if (function_exists("taxonomy_node_save")) {
          taxonomy_node_save($nid, $node->taxonomy);
        }

        watchdog("special", "$node->type: added '$node->title'");
        $output = t("Thanks for your submission.");
      }
      else {
        watchdog("warning", "$node->type: not authorized to create node");
        $output = t("You are not authorized to create this node.");
      }
    }

    /*
    ** Reload the node from the database:
    */

    $node = node_load(array("nid" => $nid));

    /*
    ** For usability's sake, make sure to present the user with some
    ** useful links as where to go next.
    */

    if ($referer = referer_load()) {
      $links[] = "<a href=\"$referer\">". t("return") ."</a>";
    }

    if ($nid && node_access("view", $node)) {
      $links[] = l(t("view"), array("id" => $nid));
    }

    if ($nid && node_access("update", $node)) {
      $links[] = lm(t("edit"), array("mod" => "node", "op" => "edit", "id" => $nid));
    }

    $output .= "<p>". $theme->links($links) ."</p>";
  }
  else {
    $output = message_access();
  }

  return $output;
}

function node_delete($edit) {

  if (!user_access("post content")) {
    return message_access();
  }

  $node = node_load(array("nid" => $edit["nid"]));

  if (node_access("delete", $node)) {

    if ($edit["confirm"]) {

      /*
      ** Delete the specified node and its comments:
      */

      db_query("DELETE FROM node WHERE nid = '$node->nid'");
      db_query("DELETE FROM comments WHERE nid = '$node->nid'");

      /*
      ** Delete any taxonomy terms
      */

      if (function_exists("taxonomy_node_delete")) {
        taxonomy_node_delete($nid, $node->taxonomy);
      }

      /*
      ** Call the node specific callback (if any):
      */

      module_invoke($node->type, "delete", $node);

      watchdog("special", "$node->type: deleted '$node->title'");
      $output = t("The node has been deleted.");
    }
    else {
      $output .= form_item(t("Confirm deletion"), check_output($node->title));
      $output .= form_hidden("nid", $node->nid);
      $output .= form_hidden("confirm", 1);
      $output .= form_submit(t("Delete"));
      $output = form($output);
    }
  }
  else {
    watchdog("warning", "$node->type: not authorized to remove node");
    $output = t("You are not authorized to remove this node.");
  }

  return $output;
}

function node_page() {
  global $op, $id, $user, $edit, $type, $theme, $or, $and;

  if ($op == "feed") {
    node_feed();
    return;
  }

  /*
  ** Try to find a good title:
  */

  if ($type) {
    $title = ucfirst(module_invoke($type, "node", "name"));
  }
  else if ($edit["type"]) {
    $title = ucfirst(module_invoke($edit["type"], "node", "name"));
  }
  else {
    $title = t("Submission form");
  }

  $theme->header();

  switch ($op) {
    case "add":
      $theme->box($title, node_add($type));
      break;
    case "edit":
      $theme->box($title, node_edit($id));
      break;
    case t("Preview"):
      $theme->box($title, node_preview($edit));
      break;
    case t("Submit"):
      $theme->box($title, node_submit($edit));
      break;
    case t("Delete"):
      $theme->box($title, node_delete($edit));
      break;
    default:
      if (user_access("access content")) {
        // prepare query
        if ($or) {
          foreach ((explode(",", $or)) as $t) {
            $terms[] = "'".check_query($t)."'";
          }
        }
        else if ($and) {
          foreach ((explode(",", $and)) as $t) {
            $terms[] = "'".check_query($t)."'";
          }
        }

        if ($or) {
          // this is an OR of terms
          $result = db_query("SELECT DISTINCT(n.nid), type FROM node n LEFT JOIN term_node r ON n.nid = r.nid WHERE tid IN (".implode(",", $terms).") AND ". ($id ? "nid = '$id'" : "promote = '1'") ." AND status = '1' ORDER BY static DESC, created DESC LIMIT ". ($user->nodes ? $user->nodes : variable_get("default_nodes_main", 10)));
        }
        else if ($and) {
          // this is an AND
          $result = db_query("SELECT n.nid, type, count(*) AS c FROM node n LEFT JOIN term_node r ON n.nid = r.nid WHERE tid IN (".implode(",", $terms).")  AND ". ($id ? "nid = '$id'" : "promote = '1'") ." AND status = '1' GROUP BY n.nid HAVING c = ".count($terms)." ORDER BY static DESC, created DESC LIMIT ". ($user->nodes ? $user->nodes : variable_get("default_nodes_main", 10)));
        }
        else {
          $result = db_query("SELECT nid, type FROM node WHERE ". ($id ? "nid = '$id'" : "promote = '1'") ." AND status = '1' ORDER BY static DESC, created DESC LIMIT ". ($user->nodes ? $user->nodes : variable_get("default_nodes_main", 10)));
        }

        while ($node = db_fetch_object($result)) {
          node_view(node_load(array("nid" => $node->nid, "type" => $node->type)), 1);
        }
      }
    }

  $theme->footer();
}

function node_update_index() {

  // Return an array of values to dictate how to update the search index
  // for this particular type of node.
  //
  // "last_update"'s value is used with variable_set to set the
  // last time this node type had an index update run.
  //
  // "node_type"'s value is used to identify the node type in the search
  // index.
  //
  // "select"'s value is used to select the node id and text fields from
  // the table we are indexing. In this case, we also check against the
  // last run date for the nodes update.
  return array("last_update" => "node_cron_last",
         "node_type" => "node",
         "select" => "SELECT n.nid as lno, n.title as text1, n.body as text2 FROM node n WHERE n.status = 1 AND moderate = 0 and (created > " . variable_get("node_cron_last", 1) . " or changed > " . variable_get("node_cron_last", 1) . ")");
}

?>